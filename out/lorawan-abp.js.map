{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaWANStack.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMac.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/system/lorawan_data_structures.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacCommand.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Ticker.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/lora-radio-drv/SX1276_LoRaRadio.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timeout.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/InterruptIn.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timeout.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timer.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/TimerEvent.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue_posix.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-trace/source/mbed_trace.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalInOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaWANInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaWANStack.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorawan_types.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaRadio.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacCommand.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/aes.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/phy/LoRaPHY.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacChannelPlan.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/cmac.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/system/LoRaWANTimer.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_irq_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/ccm.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/cipher.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacCrypto.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/hal/mbed_ticker_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/cipher_wrap.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/gcm.c","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/math.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/inc/mbedtls/cipher.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/phy/LoRaPHYEU868.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/demos/lorawan-abp/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/us_ticker.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/platform_util.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_critical.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/Sht31/Sht31.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxBzEA;;AAEA;;;;;;;;;;;;;;AR40DA;;;;;;;;;;;;;;AIp3DA;;;AAGA;;;;;;;;;;;;;;AS6FA;;;;;AAMA;;;;;;;;;ALxGA;;;;;AKoEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM2dA;;;;;;AxBhPA;AACA;;;;;;;;;;;;AAqxBA;;AAAA;;AACA;;;;;;AwBxjCA;;;;;;;;;;;;;;AAubA;;;;;AYrWA;;;;;;;;;;;;;;;;;;AlBpDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkB8FA;;;;;;AlB5BA;;;;;;;;;;;;;;;;;;;;;;;;;Abw7BA;AAtIA;;;;;;;;;;AkBnIA;;;;;;;;;;AvBzCA;;;;;AsCrpBA;;;;;;AjCgbA;;;;;;;;;;;;;;;;;;;;AL4zCA;;;;;;;;;;;;AuB9iCA;;;;;;;AlByQA;;;;;;;;;;A+B/7BA;;;;;AAGA;;;;;;;;;;;;;;;;;;;AlBpEA;;;;AiBqEA;;;;;AXmsBA;;;;;AAxSA;;;;;;;;;;;AxBxNA;AAAA;;;;AkBtPA;;;;AIkUA;AAAA;;;;;;;;AThYA;;;;AKwDA;;;;;;;;;AIsFA;AACA;;;;;;;;;;;;;AE0QA;;;;;AZrZA;;;;;;;;;;;;;;;;;;AYgmCA;;;;;AY1lCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxBoJA;;;;;;;;;AP0RA;;;;;;;;;;AanZA;;;;;AMuzBA;;;;;AC9xBA;;;;;;AAWA;;;;;ADieA;;;;;AAymBA;;;;;AiBh5BA;;;;;AA8DA;;;;;AArEA;;;;;;;;;;;;;AzC8rCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkB15CA;;;;;;;;;;;;;;;;;;;;;AOzBA;;;;;;;;;;A3BgOA;;;;AqCzIA;;;;;;;;;;;;;;;;;;;;;;;;;;AXseA;;;;AarcA;;;;;AfqGA;AACA;AAgEA;;;;;;;;;;;;;;AE2hCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AcxmCA;;;;;;;AzB/LA;;;;AWdA;;;;;;;;;;AAmuCA;;;;;;;;;;;;;;AApyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiBxNA;;;;;AzC+8CA;;;;;AwB1fA;;;;;AWtqCA;;;;;;AnC+lCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwB/lCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A1BqMA;;;;;;;;;;;;;;;;;;A0B4WA;;;;AxB6+BA;;;;AyCtyCA;;;;;;;;;;;;;;ApCjBA;;;;;ALs1BA;;;;;;;;;;;AA4DA;;;;;;AWtoCA;;;;;;;;AWmFA;;;;AExFA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AFiGA;;;;AgBSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ad0hBA;;;;AAxRA;;;;;AzBkBA;;;;;;;;;;;;AuBjTA;;;;AAKA;;;;;AgBZA;;;;;;;;;AAoCA;;;;;;;;;;;;;;AA4GA;;;;;;;;;;;;;;;AdoUA;;;;;;;;;;;;;AxBubA;;;;AAp2BA;;;;;AmCnCA;;;;;AbkBA;;;;;AAzFA;;;;;AjBgUA;AAAA;;;;;AiBjQA;;;;;;;;;;;;;;;;;;;;;;;;;;AA1DA;;;;;AV6bA;;;;;AZvTA;;;;;AALA;;;;;;;;;;AYsUA;;;;;AZsrBA;;;;AA4lBA;;;;;;;;;;;;;AK1/CA;;;;;;;;;;;;;;;;ALwhCA;;;;AwBvsBA;;;;AnBzUA;;;;;;;;AmB8UA;;;;AFhjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEi0BA;;;;;AxBi2BA;;;;;;;;;;;;;;;;Aa7qDA;;;;;AAZA;;;;;;;;ASEA;;;;;;;;;AtB2GA;;;;AAVA;;;;;;;;;Aa3FA;;;;;Ab0GA;;;;AAVA;;;;;;;;AyBjHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AdeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANo2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALxvBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+LA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwBxSA;;;;;AdRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVmTA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFnFA;;;;AAAA;;;;AADA;;;;;;;;AOseA;;;;APvJA;;;;AAAA;;;;AOqJA;;;;AADA;;;;;;;;;;;;;;;;APleA;;;;AEwiCA;;;;AKvlBA;;;;AAPA;;;;AAFA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApJA;;;;AAAA;;;;AAAA;;;;AAAA;;;;;;;;AANA;;;;AAAA;;;;AAAA;;;;;;;;AAFA;;;;;;;;;;;;;;;;;;;;AA3FA;;;;;;;;;;;;;;;;AAVA;;;;;;;;AADA;;;;AAAA;;;;AAHA;;;;AAJA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;;;;;AANA;;;;;;;;AAiCA;;;;AA5CA;;;;AADA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAuqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5rBA;;;;;;;;;;;;;;;;AAZA;;;;;;;;AADA;;;;AAAA;;;;AAJA;;;;AAJA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAHA;;;;;;;;;;;;AAiCA;;;;AApDA;;;;AACA;;;;AADA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAyvBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvaA;;;;AAHA;;;;AADA;;;;;;;;;;;;AATA;;;;AAJA;;;;AAJA;;;;;;;;;;;;AAnYA;;;;;;;;;;;;AAPA;;;;AAs0BA;;;;;;;;;;;;;;;;;;;;AA70BA","file":"/Users/janjon01/repos/mbed-simulator/out/lorawan-abp.js","sourcesContent":["/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <string.h>\n#include <stdlib.h>\n#include \"platform/Callback.h\"\n#include \"events/EventQueue.h\"\n\n#include \"LoRaWANStack.h\"\n\n#include \"mbed-trace/mbed_trace.h\"\n#define TRACE_GROUP \"LSTK\"\n\n#define INVALID_PORT                0xFF\n#define MAX_CONFIRMED_MSG_RETRIES   255\n/**\n * Control flags for transient states\n */\n#define IDLE_FLAG                   0x00000000\n#define TX_ONGOING_FLAG             0x00000001\n#define MSG_RECVD_FLAG              0x00000002\n#define CONNECTED_FLAG              0x00000004\n#define USING_OTAA_FLAG             0x00000008\n#define TX_DONE_FLAG                0x00000010\n\nusing namespace mbed;\nusing namespace events;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n#if (MBED_CONF_LORA_PHY == 0 || MBED_CONF_LORA_PHY == 4 || MBED_CONF_LORA_PHY == 6 || MBED_CONF_LORA_PHY == 7)\n#define LORAWAN_COMPLIANCE_TEST_DATA_SIZE                  16\n#elif (MBED_CONF_LORA_PHY == 1 || MBED_CONF_LORA_PHY == 2 || MBED_CONF_LORA_PHY == 8 || MBED_CONF_LORA_PHY == 9)\n#define LORAWAN_COMPLIANCE_TEST_DATA_SIZE                  11\n#else\n#error \"Must set LoRa PHY layer parameters.\"\n#endif\n#endif //defined(LORAWAN_COMPLIANCE_TEST)\n\n/**\n * Bit mask for message flags\n */\n\n#define MSG_FLAG_MASK                         0x0F\n\n/*****************************************************************************\n * Constructor                                                               *\n ****************************************************************************/\nLoRaWANStack::LoRaWANStack()\n: _loramac(),\n  _device_current_state(DEVICE_STATE_NOT_INITIALIZED),\n  _lw_session(),\n  _tx_msg(),\n  _rx_msg(),\n  _tx_metadata(),\n  _rx_metadata(),\n  _num_retry(1),\n  _ctrl_flags(IDLE_FLAG),\n  _app_port(INVALID_PORT),\n  _link_check_requested(false),\n  _automatic_uplink_ongoing(false),\n  _ready_for_rx(true),\n  _queue(NULL)\n{\n    _tx_metadata.stale = true;\n    _rx_metadata.stale = true;\n\n#ifdef MBED_CONF_LORA_APP_PORT\n    if (is_port_valid(MBED_CONF_LORA_APP_PORT)) {\n        _app_port = MBED_CONF_LORA_APP_PORT;\n    } else {\n        tr_error(\"User defined port in .json is illegal.\");\n    }\n#endif\n}\n\n/*****************************************************************************\n * Public Methods                                                            *\n ****************************************************************************/\nvoid LoRaWANStack::bind_radio_driver(LoRaRadio &radio)\n{\n    radio_events.tx_done = mbed::callback(this, &LoRaWANStack::tx_interrupt_handler);\n    radio_events.rx_done = mbed::callback(this, &LoRaWANStack::rx_interrupt_handler);\n    radio_events.rx_error = mbed::callback(this, &LoRaWANStack::rx_error_interrupt_handler);\n    radio_events.tx_timeout = mbed::callback(this, &LoRaWANStack::tx_timeout_interrupt_handler);\n    radio_events.rx_timeout = mbed::callback(this, &LoRaWANStack::rx_timeout_interrupt_handler);\n\n    _loramac.bind_radio_driver(radio);\n\n    radio.lock();\n    radio.init_radio(&radio_events);\n    radio.unlock();\n}\n\nlorawan_status_t LoRaWANStack::initialize_mac_layer(EventQueue *queue)\n{\n    if (!queue) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    tr_debug(\"Initializing MAC layer\");\n    _queue = queue;\n\n    return state_controller(DEVICE_STATE_IDLE);\n}\n\nlorawan_status_t LoRaWANStack::set_lora_callbacks(const lorawan_app_callbacks_t *callbacks)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    if (!callbacks || !callbacks->events) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _callbacks.events = callbacks->events;\n\n    if (callbacks->link_check_resp) {\n        _callbacks.link_check_resp = callbacks->link_check_resp;\n    }\n\n    if (callbacks->battery_level) {\n        _callbacks.battery_level = callbacks->battery_level;\n        _loramac.set_batterylevel_callback(callbacks->battery_level);\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaWANStack::connect()\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    lorawan_status_t status = _loramac.prepare_join(NULL, MBED_CONF_LORA_OVER_THE_AIR_ACTIVATION);\n\n    if (LORAWAN_STATUS_OK != status) {\n        return status;\n    }\n\n    return handle_connect(MBED_CONF_LORA_OVER_THE_AIR_ACTIVATION);\n}\n\nlorawan_status_t LoRaWANStack::connect(const lorawan_connect_t &connect)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    if (!(connect.connect_type == LORAWAN_CONNECTION_OTAA)\n            && !(connect.connect_type == LORAWAN_CONNECTION_ABP)) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    bool is_otaa = (connect.connect_type == LORAWAN_CONNECTION_OTAA);\n\n    lorawan_status_t status = _loramac.prepare_join(&connect, is_otaa);\n\n    if (LORAWAN_STATUS_OK != status) {\n        return status;\n    }\n\n    return handle_connect(is_otaa);\n}\n\nlorawan_status_t LoRaWANStack::add_channels(const lorawan_channelplan_t &channel_plan)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.add_channel_plan(channel_plan);\n}\n\nlorawan_status_t LoRaWANStack::remove_a_channel(uint8_t channel_id)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.remove_single_channel(channel_id);\n}\n\nlorawan_status_t LoRaWANStack::drop_channel_list()\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.remove_channel_plan();\n}\n\nlorawan_status_t LoRaWANStack::get_enabled_channels(lorawan_channelplan_t &channel_plan)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.get_channel_plan(channel_plan);\n}\n\nlorawan_status_t LoRaWANStack::set_confirmed_msg_retry(uint8_t count)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    if (count >= MAX_CONFIRMED_MSG_RETRIES) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _num_retry = count;\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaWANStack::set_channel_data_rate(uint8_t data_rate)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.set_channel_data_rate(data_rate);\n}\n\n\nlorawan_status_t LoRaWANStack::enable_adaptive_datarate(bool adr_enabled)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    _loramac.enable_adaptive_datarate(adr_enabled);\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaWANStack::stop_sending(void)\n{\n    if (_loramac.clear_tx_pipe() == LORAWAN_STATUS_OK) {\n        if (_device_current_state == DEVICE_STATE_SENDING) {\n            _ctrl_flags &= ~TX_DONE_FLAG;\n            _ctrl_flags &= ~TX_ONGOING_FLAG;\n            _loramac.set_tx_ongoing(false);\n            _device_current_state = DEVICE_STATE_IDLE;\n            return LORAWAN_STATUS_OK;\n        }\n    }\n\n    return LORAWAN_STATUS_BUSY;\n}\n\nint16_t LoRaWANStack::handle_tx(const uint8_t port, const uint8_t *data,\n                                uint16_t length, uint8_t flags,\n                                bool null_allowed, bool allow_port_0)\n{\n    if (!null_allowed && !data) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n    // add a link check request with normal data, until the application\n    // explicitly removes it.\n    if (_link_check_requested) {\n        set_link_check_request();\n    }\n\n    if (!_lw_session.active) {\n        return LORAWAN_STATUS_NO_ACTIVE_SESSIONS;\n    }\n\n    if (_loramac.tx_ongoing()) {\n        return LORAWAN_STATUS_WOULD_BLOCK;\n    }\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    if (_compliance_test.running) {\n        return LORAWAN_STATUS_COMPLIANCE_TEST_ON;\n    }\n#endif\n\n    lorawan_status_t status;\n\n    if (_loramac.nwk_joined() == false) {\n        return LORAWAN_STATUS_NO_NETWORK_JOINED;\n    }\n\n    status = set_application_port(port, allow_port_0);\n\n    if (status != LORAWAN_STATUS_OK) {\n        tr_error(\"Illegal application port definition.\");\n        return status;\n    }\n\n    // All the flags mutually exclusive. In addition to that MSG_MULTICAST_FLAG cannot be\n    // used for uplink.\n    switch (flags & MSG_FLAG_MASK) {\n        case MSG_UNCONFIRMED_FLAG:\n        case MSG_CONFIRMED_FLAG:\n        case MSG_PROPRIETARY_FLAG:\n            break;\n\n        default:\n            tr_error(\"Invalid send flags\");\n            return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    int16_t len = _loramac.prepare_ongoing_tx(port, data, length, flags, _num_retry);\n\n    status = state_controller(DEVICE_STATE_SCHEDULING);\n\n    // send user the length of data which is scheduled now.\n    // user should take care of the pending data.\n    return (status == LORAWAN_STATUS_OK) ? len : (int16_t) status;\n}\n\nint16_t LoRaWANStack::handle_rx(uint8_t *data, uint16_t length, uint8_t &port, int &flags, bool validate_params)\n{\n    if (!_lw_session.active) {\n        return LORAWAN_STATUS_NO_ACTIVE_SESSIONS;\n    }\n\n    // No messages to read.\n    if (!_rx_msg.receive_ready) {\n        return LORAWAN_STATUS_WOULD_BLOCK;\n    }\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    if (_compliance_test.running) {\n        return LORAWAN_STATUS_COMPLIANCE_TEST_ON;\n    }\n#endif\n\n    if (data == NULL || length == 0) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    int received_flags = convert_to_msg_flag(_rx_msg.msg.mcps_indication.type);\n    if (validate_params) {\n        // Check received message port and flags match with the ones requested by user\n        received_flags &= MSG_FLAG_MASK;\n\n        if (_rx_msg.msg.mcps_indication.port != port || !(flags & received_flags)) {\n            return LORAWAN_STATUS_WOULD_BLOCK;\n        }\n    }\n\n    // Report values back to user\n    port = _rx_msg.msg.mcps_indication.port;\n    flags = received_flags;\n\n    const uint8_t *base_ptr = _rx_msg.msg.mcps_indication.buffer;\n    uint16_t base_size = _rx_msg.msg.mcps_indication.buffer_size;\n    bool read_complete = false;\n\n    // check the length of received message whether we can fit into user\n    // buffer completely or not\n    if (_rx_msg.msg.mcps_indication.buffer_size > length\n            && _rx_msg.prev_read_size == 0) {\n        // we can't fit into user buffer. Invoke counter measures\n        _rx_msg.pending_size = _rx_msg.msg.mcps_indication.buffer_size - length;\n        base_size = length;\n        _rx_msg.prev_read_size = base_size;\n        memcpy(data, base_ptr, base_size);\n    } else if (_rx_msg.prev_read_size == 0) {\n        _rx_msg.pending_size = 0;\n        _rx_msg.prev_read_size = 0;\n        memcpy(data, base_ptr, base_size);\n        read_complete = true;\n    }\n\n    // If its the pending read then we should copy only the remaining part of\n    // the buffer. Due to checks above, in case of a pending read, this block\n    // will be the only one to get invoked\n    if (_rx_msg.pending_size > 0 && _rx_msg.prev_read_size > 0) {\n        memcpy(data, base_ptr + _rx_msg.prev_read_size, base_size);\n    }\n\n    // we are done handing over received buffer to user. check if there is\n    // anything pending. If not, memset the buffer to zero and indicate\n    // that no read is in progress\n    if (read_complete) {\n        _rx_msg.msg.mcps_indication.buffer = NULL;\n        _rx_msg.msg.mcps_indication.buffer_size = 0;\n        _rx_msg.receive_ready = false;\n    }\n\n    return base_size;\n}\n\nlorawan_status_t LoRaWANStack::set_link_check_request()\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    _link_check_requested = true;\n    if (!_callbacks.link_check_resp) {\n        tr_error(\"Must assign a callback function for link check request. \");\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _loramac.setup_link_check_request();\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaWANStack::remove_link_check_request()\n{\n    _link_check_requested = false;\n}\n\nlorawan_status_t LoRaWANStack::shutdown()\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return state_controller(DEVICE_STATE_SHUTDOWN);\n}\n\nlorawan_status_t LoRaWANStack::set_device_class(const device_class_t &device_class)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    if (device_class == CLASS_B) {\n        return LORAWAN_STATUS_UNSUPPORTED;\n    }\n    _loramac.set_device_class(device_class, mbed::callback(this, &LoRaWANStack::handle_ack_expiry_for_class_c));\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t  LoRaWANStack::acquire_tx_metadata(lorawan_tx_metadata &tx_metadata)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    if (!_tx_metadata.stale) {\n        tx_metadata = _tx_metadata;\n        _tx_metadata.stale = true;\n        return LORAWAN_STATUS_OK;\n    }\n\n    return LORAWAN_STATUS_METADATA_NOT_AVAILABLE;\n}\n\nlorawan_status_t LoRaWANStack::acquire_rx_metadata(lorawan_rx_metadata &metadata)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    if (!_rx_metadata.stale) {\n        metadata = _rx_metadata;\n        _rx_metadata.stale = true;\n        return LORAWAN_STATUS_OK;\n    }\n\n    return LORAWAN_STATUS_METADATA_NOT_AVAILABLE;\n}\n\nlorawan_status_t LoRaWANStack::acquire_backoff_metadata(int& backoff)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    int id = _loramac.get_backoff_timer_event_id();\n\n    if (_loramac.get_backoff_timer_event_id() > 0) {\n        backoff = _queue->time_left(id);\n        return LORAWAN_STATUS_OK;\n    }\n\n    backoff = -1;\n    return LORAWAN_STATUS_METADATA_NOT_AVAILABLE;\n}\n\n/*****************************************************************************\n * Interrupt handlers                                                        *\n ****************************************************************************/\nvoid LoRaWANStack::tx_interrupt_handler(void)\n{\n    const int ret = _queue->call(this, &LoRaWANStack::process_transmission);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaWANStack::rx_interrupt_handler(const uint8_t *payload, uint16_t size,\n                                        int16_t rssi, int8_t snr)\n{\n    if (!_ready_for_rx || size > sizeof _rx_payload) {\n        return;\n    }\n\n    _ready_for_rx = false;\n    memcpy(_rx_payload, payload, size);\n\n    const uint8_t *ptr = _rx_payload;\n    const int ret = _queue->call(this, &LoRaWANStack::process_reception,\n                                 ptr, size, rssi, snr);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaWANStack::rx_error_interrupt_handler(void)\n{\n    const int ret = _queue->call(this, &LoRaWANStack::process_reception_timeout,\n                                 false);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaWANStack::tx_timeout_interrupt_handler(void)\n{\n    const int ret = _queue->call(this, &LoRaWANStack::process_transmission_timeout);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaWANStack::rx_timeout_interrupt_handler(void)\n{\n    const int ret = _queue->call(this, &LoRaWANStack::process_reception_timeout,\n                                 true);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\n/*****************************************************************************\n * Processors for deferred interrupts                                        *\n ****************************************************************************/\nvoid LoRaWANStack::process_transmission_timeout()\n{\n    // this is a fatal error and should not happen\n    tr_debug(\"TX Timeout\");\n    _loramac.on_radio_tx_timeout();\n    _ctrl_flags |= TX_ONGOING_FLAG;\n    _ctrl_flags &= ~TX_DONE_FLAG;\n    state_controller(DEVICE_STATE_STATUS_CHECK);\n    state_machine_run_to_completion();\n}\n\nvoid LoRaWANStack::process_transmission(void)\n{\n    tr_debug(\"Transmission completed\");\n    _loramac.on_radio_tx_done();\n\n    make_tx_metadata_available();\n\n    if (_device_current_state == DEVICE_STATE_JOINING) {\n        _device_current_state = DEVICE_STATE_AWAITING_JOIN_ACCEPT;\n    }\n\n    if (_device_current_state == DEVICE_STATE_SENDING) {\n        if (_loramac.get_mcps_confirmation()->req_type == MCPS_CONFIRMED) {\n            _ctrl_flags |= TX_ONGOING_FLAG;\n            _ctrl_flags &= ~TX_DONE_FLAG;\n            tr_debug(\"Awaiting ACK\");\n            _device_current_state = DEVICE_STATE_AWAITING_ACK;\n            return;\n        }\n\n        // Class A unconfirmed message sent, TX_DONE event will be sent to\n        // application when RX2 windows is elapsed, i.e., in process_reception_timeout()\n        _ctrl_flags &= ~TX_ONGOING_FLAG;\n        _ctrl_flags |= TX_DONE_FLAG;\n\n        // In Class C, reception timeout never happens, so we handle the state\n        // progression for TX_DONE in UNCONFIRMED case here\n        if (_loramac.get_device_class() == CLASS_C) {\n            _loramac.post_process_mcps_req();\n            state_controller(DEVICE_STATE_STATUS_CHECK);\n            state_machine_run_to_completion();\n        }\n    }\n}\n\nvoid LoRaWANStack::handle_ack_expiry_for_class_c(void)\n{\n    _ctrl_flags &= ~TX_DONE_FLAG;\n    _ctrl_flags |= TX_ONGOING_FLAG;\n    tr_error(\"Retries exhausted for Class C device\");\n    state_controller(DEVICE_STATE_STATUS_CHECK);\n}\n\nvoid LoRaWANStack::process_reception(const uint8_t *const payload, uint16_t size,\n                                     int16_t rssi, int8_t snr)\n{\n    _device_current_state = DEVICE_STATE_RECEIVING;\n    _ctrl_flags &= ~MSG_RECVD_FLAG;\n\n    _loramac.on_radio_rx_done(payload, size, rssi, snr);\n\n    make_rx_metadata_available();\n\n    if (_loramac.get_mlme_confirmation()->pending) {\n        _loramac.post_process_mlme_request();\n        mlme_confirm_handler();\n    }\n\n    if (!_loramac.nwk_joined()) {\n        return;\n    }\n\n    // if the outgoing message was of CONFIRMED type\n    if (_loramac.get_mcps_confirmation()->req_type == MCPS_CONFIRMED) {\n        // if ack was not received, we will try retransmission after\n        // ACK_TIMEOUT. handle_data_frame() already disables ACK_TIMEOUT timer\n        // if ack was received. Otherwise, following method will be called in\n        // LoRaMac.cpp, on_ack_timeout_timer_event().\n        if (_loramac.get_mcps_indication()->is_ack_recvd) {\n            tr_debug(\"Ack=OK, NbTrials=%d\",\n                     _loramac.get_mcps_confirmation()->nb_retries);\n            _loramac.post_process_mcps_req();\n            _ctrl_flags |= TX_DONE_FLAG;\n            _ctrl_flags &= ~TX_ONGOING_FLAG;\n            state_controller(DEVICE_STATE_STATUS_CHECK);\n        } else {\n            if (!_loramac.continue_sending_process()) {\n                tr_error(\"Retries exhausted for Class A device\");\n                _ctrl_flags &= ~TX_DONE_FLAG;\n                _ctrl_flags |= TX_ONGOING_FLAG;\n                state_controller(DEVICE_STATE_STATUS_CHECK);\n            }\n        }\n    } else {\n        // handle UNCONFIRMED case here, RX slots were turned off due to\n        // valid packet reception\n        _loramac.post_process_mcps_req();\n        _ctrl_flags |= TX_DONE_FLAG;\n        state_controller(DEVICE_STATE_STATUS_CHECK);\n    }\n\n    // handle any pending MCPS indication\n    if (_loramac.get_mcps_indication()->pending) {\n        _loramac.post_process_mcps_ind();\n        _ctrl_flags |= MSG_RECVD_FLAG;\n        state_controller(DEVICE_STATE_STATUS_CHECK);\n    }\n\n    // change the state only if a TX cycle completes for Class A\n    // For class C it's not needed as it will already be in receiving\n    // state, no matter if the TX cycle completed or not.\n    if (!(_ctrl_flags & TX_ONGOING_FLAG)) {\n        // we are done here, update the state\n        state_machine_run_to_completion();\n    }\n\n    if (_loramac.get_mlme_indication()->pending) {\n        tr_debug(\"MLME Indication pending\");\n        _loramac.post_process_mlme_ind();\n        tr_debug(\"Immediate Uplink requested\");\n        mlme_indication_handler();\n    }\n\n    _ready_for_rx = true;\n}\n\nvoid LoRaWANStack::process_reception_timeout(bool is_timeout)\n{\n    // when is_timeout == false, a CRC error took place in the received frame\n    // we treat that erroneous frame as no frame received at all, hence handle\n    // it exactly as we would handle timeout\n    rx_slot_t slot = _loramac.on_radio_rx_timeout(is_timeout);\n\n    if (slot == RX_SLOT_WIN_2 && !_loramac.nwk_joined()) {\n        state_controller(DEVICE_STATE_JOINING);\n        return;\n    }\n\n    /**\n     * LoRaWAN Specification 1.0.2. Section 3.3.6\n     * Main point:\n     *     We indicate successful transmission\n     * of UNCONFIRMED message after RX windows are done with.\n     *     For a CONFIRMED message, it means that we have not received\n     * ack (actually nothing was received), and we should retransmit if we can.\n     *\n     * NOTE: This code block doesn't get hit for Class C as in Class C, RX2 timeout\n     * never occurs.\n     */\n    if (slot == RX_SLOT_WIN_2) {\n        _loramac.post_process_mcps_req();\n\n        if (_loramac.get_mcps_confirmation()->req_type == MCPS_CONFIRMED) {\n            if (_loramac.continue_sending_process()) {\n                return;\n            } else {\n                tr_error(\"Retries exhausted for Class A device\");\n            }\n        }\n\n        state_controller(DEVICE_STATE_STATUS_CHECK);\n        state_machine_run_to_completion();\n    }\n}\n\n/*****************************************************************************\n * Private methods                                                           *\n ****************************************************************************/\nvoid LoRaWANStack::make_tx_metadata_available(void)\n{\n    _tx_metadata.stale = false;\n    _tx_metadata.channel = _loramac.get_mcps_confirmation()->channel;\n    _tx_metadata.data_rate = _loramac.get_mcps_confirmation()->data_rate;\n    _tx_metadata.tx_power = _loramac.get_mcps_confirmation()->tx_power;\n    _tx_metadata.tx_toa = _loramac.get_mcps_confirmation()->tx_toa;\n    _tx_metadata.nb_retries = _loramac.get_mcps_confirmation()->nb_retries;\n}\n\nvoid LoRaWANStack::make_rx_metadata_available(void)\n{\n    _rx_metadata.stale = false;\n    _rx_metadata.rx_datarate = _loramac.get_mcps_indication()->rx_datarate;\n    _rx_metadata.rssi = _loramac.get_mcps_indication()->rssi;\n    _rx_metadata.snr = _loramac.get_mcps_indication()->snr;\n}\n\nbool LoRaWANStack::is_port_valid(const uint8_t port, bool allow_port_0)\n{\n    //Application should not use reserved and illegal port numbers.\n    if (port == 0) {\n        return allow_port_0;\n    } else {\n        return true;\n    }\n}\n\nlorawan_status_t LoRaWANStack::set_application_port(const uint8_t port, bool allow_port_0)\n{\n    if (is_port_valid(port, allow_port_0)) {\n        _app_port = port;\n        return LORAWAN_STATUS_OK;\n    }\n\n    return LORAWAN_STATUS_PORT_INVALID;\n}\n\nvoid LoRaWANStack::state_machine_run_to_completion()\n{\n    if (_loramac.get_device_class() == CLASS_C) {\n        _device_current_state = DEVICE_STATE_RECEIVING;\n        return;\n    }\n\n    _device_current_state = DEVICE_STATE_IDLE;\n}\n\nvoid LoRaWANStack::send_event_to_application(const lorawan_event_t event) const\n{\n    if (_callbacks.events) {\n        const int ret = _queue->call(_callbacks.events, event);\n        MBED_ASSERT(ret != 0);\n        (void)ret;\n    }\n}\n\nvoid LoRaWANStack::send_automatic_uplink_message(const uint8_t port)\n{\n    const int16_t ret = handle_tx(port, NULL, 0, MSG_CONFIRMED_FLAG, true, true);\n    if (ret < 0) {\n        tr_debug(\"Failed to generate AUTOMATIC UPLINK, error code = %d\", ret);\n        send_event_to_application(AUTOMATIC_UPLINK_ERROR);\n    }\n}\n\nint LoRaWANStack::convert_to_msg_flag(const mcps_type_t type)\n{\n    int msg_flag = MSG_UNCONFIRMED_FLAG;\n    switch (type) {\n        case MCPS_UNCONFIRMED:\n            msg_flag = MSG_UNCONFIRMED_FLAG;\n            break;\n\n        case MCPS_CONFIRMED:\n            msg_flag = MSG_CONFIRMED_FLAG;\n            break;\n\n        case MCPS_MULTICAST:\n            msg_flag = MSG_MULTICAST_FLAG;\n            break;\n\n        case MCPS_PROPRIETARY:\n            msg_flag = MSG_PROPRIETARY_FLAG;\n            break;\n\n        default:\n            tr_error(\"Unknown message type!\");\n            MBED_ASSERT(0);\n    }\n\n    return msg_flag;\n}\n\nlorawan_status_t LoRaWANStack::handle_connect(bool is_otaa)\n{\n    if (is_otaa) {\n        tr_debug(\"Initiating OTAA\");\n\n        // In 1.0.2 spec, counters are always set to zero for new connection.\n        // This section is common for both normal and\n        // connection restore at this moment. Will change in future with 1.1 support.\n        _lw_session.downlink_counter = 0;\n        _lw_session.uplink_counter = 0;\n        _ctrl_flags |= USING_OTAA_FLAG;\n    } else {\n        // If current state is SHUTDOWN, device may be trying to re-establish\n        // communication. In case of ABP specification is meddled about frame counters.\n        // It says to reset counters to zero but there is no mechanism to tell the\n        // network server that the device was disconnected or restarted.\n        // At the moment, this implementation does not support a non-volatile\n        // memory storage.\n        //_lw_session.downlink_counter; //Get from NVM\n        //_lw_session.uplink_counter; //Get from NVM\n\n        tr_debug(\"Initiating ABP\");\n        tr_debug(\"Frame Counters. UpCnt=%lu, DownCnt=%lu\",\n                 _lw_session.uplink_counter, _lw_session.downlink_counter);\n        _ctrl_flags &= ~USING_OTAA_FLAG;\n    }\n\n    return state_controller(DEVICE_STATE_CONNECTING);\n}\n\nvoid LoRaWANStack::mlme_indication_handler()\n{\n    if (_loramac.get_mlme_indication()->indication_type == MLME_SCHEDULE_UPLINK) {\n        // The MAC signals that we shall provide an uplink as soon as possible\n#if MBED_CONF_LORA_AUTOMATIC_UPLINK_MESSAGE\n        _automatic_uplink_ongoing = true;\n        tr_debug(\"mlme indication: sending empty uplink to port 0 to acknowledge MAC commands...\");\n        send_automatic_uplink_message(0);\n#else\n\n        send_event_to_application(UPLINK_REQUIRED);\n#endif\n        return;\n    }\n\n    tr_error(\"Unknown MLME Indication type.\");\n}\n\nvoid LoRaWANStack::mlme_confirm_handler()\n{\n    if (_loramac.get_mlme_confirmation()->req_type == MLME_LINK_CHECK) {\n        if (_loramac.get_mlme_confirmation()->status == LORAMAC_EVENT_INFO_STATUS_OK) {\n#if defined(LORAWAN_COMPLIANCE_TEST)\n            if (_compliance_test.running == true) {\n                _compliance_test.link_check = true;\n                _compliance_test.demod_margin = _loramac.get_mlme_confirmation()->demod_margin;\n                _compliance_test.nb_gateways = _loramac.get_mlme_confirmation()->nb_gateways;\n            } else\n#endif\n            {\n                if (_callbacks.link_check_resp) {\n                    const int ret = _queue->call(_callbacks.link_check_resp,\n                                                 _loramac.get_mlme_confirmation()->demod_margin,\n                                                 _loramac.get_mlme_confirmation()->nb_gateways);\n                    MBED_ASSERT(ret != 0);\n                    (void)ret;\n                }\n            }\n        }\n    } else if (_loramac.get_mlme_confirmation()->req_type == MLME_JOIN) {\n        if (_loramac.get_mlme_confirmation()->status == LORAMAC_EVENT_INFO_STATUS_OK) {\n            state_controller(DEVICE_STATE_CONNECTED);\n        } else {\n            tr_error(\"Joining error: %d\", _loramac.get_mlme_confirmation()->status);\n            if (_loramac.get_mlme_confirmation()->status == LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL) {\n                // fatal error\n                _device_current_state = DEVICE_STATE_IDLE;\n                send_event_to_application(CRYPTO_ERROR);\n            } else {\n                // non-fatal, retry if possible\n                _device_current_state = DEVICE_STATE_AWAITING_JOIN_ACCEPT;\n                state_controller(DEVICE_STATE_JOINING);\n            }\n\n        }\n    }\n}\n\nvoid LoRaWANStack::mcps_confirm_handler()\n{\n    // success case\n    if (_loramac.get_mcps_confirmation()->status == LORAMAC_EVENT_INFO_STATUS_OK) {\n        _lw_session.uplink_counter = _loramac.get_mcps_confirmation()->ul_frame_counter;\n        send_event_to_application(TX_DONE);\n        return;\n    }\n\n    // failure case\n    tr_error(\"mcps_confirmation: Error code = %d\", _loramac.get_mcps_confirmation()->status);\n\n    if (_loramac.get_mcps_confirmation()->status == LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT) {\n        send_event_to_application(TX_TIMEOUT);\n        return;\n    }\n\n    // if no ack was received, send TX_ERROR\n    send_event_to_application(TX_ERROR);\n}\n\nvoid LoRaWANStack::mcps_indication_handler()\n{\n    const loramac_mcps_indication_t *mcps_indication = _loramac.get_mcps_indication();\n    if (mcps_indication->status != LORAMAC_EVENT_INFO_STATUS_OK) {\n        tr_error(\"RX_ERROR: mcps_indication status = %d\", mcps_indication->status);\n        send_event_to_application(RX_ERROR);\n        return;\n    }\n\n    _lw_session.downlink_counter = mcps_indication->dl_frame_counter;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    if (_compliance_test.running == true) {\n        _compliance_test.downlink_counter++;\n    }\n#endif\n\n    if (mcps_indication->port == 224) {\n#if defined(LORAWAN_COMPLIANCE_TEST)\n        tr_debug(\"Compliance test command received.\");\n        compliance_test_handler(mcps_indication);\n#else\n        tr_info(\"Compliance test disabled.\");\n#endif\n    } else {\n        if (mcps_indication->is_data_recvd) {\n            // Valid message arrived.\n            _rx_msg.type = LORAMAC_RX_MCPS_INDICATION;\n            _rx_msg.msg.mcps_indication.buffer_size = mcps_indication->buffer_size;\n            _rx_msg.msg.mcps_indication.port = mcps_indication->port;\n            _rx_msg.msg.mcps_indication.buffer = mcps_indication->buffer;\n            _rx_msg.msg.mcps_indication.type = mcps_indication->type;\n\n            // Notify application about received frame..\n            tr_debug(\"Packet Received %d bytes\",\n                     _rx_msg.msg.mcps_indication.buffer_size);\n            _rx_msg.receive_ready = true;\n            send_event_to_application(RX_DONE);\n        }\n\n        /*\n         * If fPending bit is set we try to generate an empty packet\n         * with CONFIRMED flag set. We always set a CONFIRMED flag so\n         * that we could retry a certain number of times if the uplink\n         * failed for some reason\n         * or\n         * Class C and node received a confirmed message so we need to\n         * send an empty packet to acknowledge the message.\n         * This scenario is unspecified by LoRaWAN 1.0.2 specification,\n         * but version 1.1.0 says that network SHALL not send any new\n         * confirmed messages until ack has been sent\n         */\n        if ((_loramac.get_device_class() != CLASS_C && mcps_indication->fpending_status)\n                ||\n                (_loramac.get_device_class() == CLASS_C && mcps_indication->type == MCPS_CONFIRMED)) {\n#if (MBED_CONF_LORA_AUTOMATIC_UPLINK_MESSAGE)\n            tr_debug(\"Sending empty uplink message...\");\n            _automatic_uplink_ongoing = true;\n            send_automatic_uplink_message(mcps_indication->port);\n#else\n            send_event_to_application(UPLINK_REQUIRED);\n#endif\n        }\n    }\n}\n\nlorawan_status_t LoRaWANStack::state_controller(device_states_t new_state)\n{\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    switch (new_state) {\n        case DEVICE_STATE_IDLE:\n            process_idle_state(status);\n            break;\n        case DEVICE_STATE_CONNECTING:\n            process_connecting_state(status);\n            break;\n        case DEVICE_STATE_JOINING:\n            process_joining_state(status);\n            break;\n        case DEVICE_STATE_CONNECTED:\n            process_connected_state();\n            break;\n        case DEVICE_STATE_SCHEDULING:\n            process_scheduling_state(status);\n            break;\n        case DEVICE_STATE_STATUS_CHECK:\n            process_status_check_state();\n            break;\n        case DEVICE_STATE_SHUTDOWN:\n            process_shutdown_state(status);\n            break;\n        default:\n            tr_debug(\"state_controller: Unknown state!\");\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n            break;\n    }\n\n    return status;\n}\n\nvoid LoRaWANStack::process_shutdown_state(lorawan_status_t &op_status)\n{\n    /**\n     * Remove channels\n     * Radio will be put to sleep by the APIs underneath\n     */\n    drop_channel_list();\n    _loramac.disconnect();\n    _lw_session.active = false;\n    _device_current_state = DEVICE_STATE_SHUTDOWN;\n    op_status = LORAWAN_STATUS_DEVICE_OFF;\n    _ctrl_flags &= ~CONNECTED_FLAG;\n    send_event_to_application(DISCONNECTED);\n}\n\nvoid LoRaWANStack::process_status_check_state()\n{\n    if (_device_current_state == DEVICE_STATE_SENDING ||\n            _device_current_state == DEVICE_STATE_AWAITING_ACK) {\n        // this happens after RX2 slot is exhausted\n        // we may or may not have a successful UNCONFIRMED transmission\n        // here. In CONFIRMED case this block is invoked only\n        // when the MAX number of retries are exhausted, i.e., only error\n        // case will fall here. Moreover, it will happen for Class A only.\n        _ctrl_flags &= ~TX_DONE_FLAG;\n        _ctrl_flags &= ~TX_ONGOING_FLAG;\n        _loramac.set_tx_ongoing(false);\n        _loramac.reset_ongoing_tx();\n        mcps_confirm_handler();\n\n    } else if (_device_current_state == DEVICE_STATE_RECEIVING) {\n\n        if ((_ctrl_flags & TX_DONE_FLAG) || (_ctrl_flags & TX_ONGOING_FLAG)) {\n            // for CONFIRMED case, ack validity is already checked\n            // If it was a successful transmission, TX_ONGOING_FLAG will not be set.\n            // If it was indeed set, that means the device was in Class C mode and\n            // CONFIRMED transmission was in place and the ack retries maxed out.\n            _ctrl_flags &= ~TX_DONE_FLAG;\n            _ctrl_flags &= ~TX_ONGOING_FLAG;\n            _loramac.set_tx_ongoing(false);\n            _loramac.reset_ongoing_tx();\n            // if an automatic uplink is ongoing, we should not send a TX_DONE\n            // event to application\n            if (_automatic_uplink_ongoing) {\n                _automatic_uplink_ongoing = false;\n            } else {\n                mcps_confirm_handler();\n            }\n        }\n\n        // handle any received data and send event accordingly\n        if (_ctrl_flags & MSG_RECVD_FLAG) {\n            _ctrl_flags &= ~MSG_RECVD_FLAG;\n            mcps_indication_handler();\n        }\n    }\n}\n\nvoid LoRaWANStack::process_scheduling_state(lorawan_status_t &op_status)\n{\n    if (_device_current_state != DEVICE_STATE_IDLE) {\n        if (_device_current_state != DEVICE_STATE_RECEIVING\n                && _loramac.get_device_class() != CLASS_C) {\n            op_status = LORAWAN_STATUS_BUSY;\n            return;\n        }\n    }\n\n    op_status = _loramac.send_ongoing_tx();\n    if (op_status == LORAWAN_STATUS_OK) {\n        _ctrl_flags |= TX_ONGOING_FLAG;\n        _ctrl_flags &= ~TX_DONE_FLAG;\n        _loramac.set_tx_ongoing(true);\n        _device_current_state = DEVICE_STATE_SENDING;\n    }\n}\n\nvoid LoRaWANStack::process_joining_state(lorawan_status_t &op_status)\n{\n    if (_device_current_state == DEVICE_STATE_CONNECTING) {\n        _device_current_state = DEVICE_STATE_JOINING;\n        tr_debug(\"Sending Join Request ...\");\n        op_status = _loramac.join(true);\n        return;\n    }\n\n    if (_device_current_state == DEVICE_STATE_AWAITING_JOIN_ACCEPT) {\n        _device_current_state = DEVICE_STATE_JOINING;\n        // retry join\n        bool can_continue = _loramac.continue_joining_process();\n\n        if (!can_continue) {\n            send_event_to_application(JOIN_FAILURE);\n            _device_current_state = DEVICE_STATE_IDLE;\n            return;\n        }\n    }\n}\n\nvoid LoRaWANStack::process_connected_state()\n{\n    if (_ctrl_flags & USING_OTAA_FLAG) {\n        tr_debug(\"OTAA Connection OK!\");\n    }\n\n    _lw_session.active = true;\n    send_event_to_application(CONNECTED);\n    _ctrl_flags |= CONNECTED_FLAG;\n\n    _device_current_state = DEVICE_STATE_IDLE;\n}\n\nvoid LoRaWANStack::process_connecting_state(lorawan_status_t &op_status)\n{\n    if (_device_current_state != DEVICE_STATE_IDLE\n            && _device_current_state != DEVICE_STATE_SHUTDOWN) {\n        op_status = LORAWAN_STATUS_BUSY;\n        return;\n    }\n\n    if (_ctrl_flags & CONNECTED_FLAG) {\n        tr_debug(\"Already connected\");\n        op_status = LORAWAN_STATUS_OK;\n        return;\n    }\n\n    _device_current_state = DEVICE_STATE_CONNECTING;\n\n    if (_ctrl_flags & USING_OTAA_FLAG) {\n        process_joining_state(op_status);\n        return;\n    }\n\n    op_status = _loramac.join(false);\n    tr_debug(\"ABP connection OK.\");\n    process_connected_state();\n}\n\nvoid LoRaWANStack::process_idle_state(lorawan_status_t &op_status)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        _device_current_state = DEVICE_STATE_IDLE;\n        process_uninitialized_state(op_status);\n        return;\n    }\n\n    _device_current_state = DEVICE_STATE_IDLE;\n    op_status = LORAWAN_STATUS_OK;\n}\n\nvoid LoRaWANStack::process_uninitialized_state(lorawan_status_t &op_status)\n{\n    op_status = _loramac.initialize(_queue);\n\n    if (op_status == LORAWAN_STATUS_OK) {\n        _device_current_state = DEVICE_STATE_IDLE;\n    }\n}\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n\nlorawan_status_t LoRaWANStack::send_compliance_test_frame_to_mac()\n{\n    loramac_compliance_test_req_t test_req;\n\n    //TODO: What if the port is not 224 ???\n    if (_compliance_test.app_port == 224) {\n        // Clear any normal message stuff before compliance test.\n        memset(&test_req, 0, sizeof(test_req));\n\n        if (_compliance_test.link_check == true) {\n            _compliance_test.link_check = false;\n            _compliance_test.state = 1;\n            test_req.f_buffer_size = 3;\n            test_req.f_buffer[0] = 5;\n            test_req.f_buffer[1] = _compliance_test.demod_margin;\n            test_req.f_buffer[2] = _compliance_test.nb_gateways;\n        } else {\n            switch (_compliance_test.state) {\n                case 4:\n                    _compliance_test.state = 1;\n                    test_req.f_buffer_size = _compliance_test.app_data_size;\n                    test_req.f_buffer[0] = _compliance_test.app_data_buffer[0];\n                    for (uint8_t i = 1; i < MIN(_compliance_test.app_data_size, MBED_CONF_LORA_TX_MAX_SIZE); ++i) {\n                        test_req.f_buffer[i] = _compliance_test.app_data_buffer[i];\n                    }\n                    break;\n                case 1:\n                    test_req.f_buffer_size = 2;\n                    test_req.f_buffer[0] = _compliance_test.downlink_counter >> 8;\n                    test_req.f_buffer[1] = _compliance_test.downlink_counter;\n                    break;\n            }\n        }\n    }\n\n    //TODO: If port is not 224, this might not work!\n    //Is there a test case where same _tx_msg's buffer would be used, when port is not 224???\n    if (!_compliance_test.is_tx_confirmed) {\n        test_req.type = MCPS_UNCONFIRMED;\n        test_req.fport = _compliance_test.app_port;\n        test_req.nb_trials = 1;\n        test_req.data_rate = _loramac.get_default_tx_datarate();\n\n        tr_info(\"Transmit unconfirmed compliance test frame %d bytes.\", test_req.f_buffer_size);\n\n        for (uint8_t i = 0; i < test_req.f_buffer_size; ++i) {\n            tr_info(\"Byte %d, data is 0x%x\", i + 1, ((uint8_t *)test_req.f_buffer)[i]);\n        }\n    } else if (_compliance_test.is_tx_confirmed) {\n        test_req.type = MCPS_CONFIRMED;\n        test_req.fport = _compliance_test.app_port;\n        test_req.nb_trials = _num_retry;\n        test_req.data_rate = _loramac.get_default_tx_datarate();\n\n        tr_info(\"Transmit confirmed compliance test frame %d bytes.\", test_req.f_buffer_size);\n\n        for (uint8_t i = 0; i < test_req.f_buffer_size; ++i) {\n            tr_info(\"Byte %d, data is 0x%x\", i + 1, ((uint8_t *)test_req.f_buffer)[i]);\n        }\n    } else {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    return _loramac.test_request(&test_req);\n}\n\nvoid LoRaWANStack::compliance_test_handler(loramac_mcps_indication_t *mcps_indication)\n{\n    if (_compliance_test.running == false) {\n        // Check compliance test enable command (i)\n        if ((mcps_indication->buffer_size == 4) &&\n                (mcps_indication->buffer[0] == 0x01) &&\n                (mcps_indication->buffer[1] == 0x01) &&\n                (mcps_indication->buffer[2] == 0x01) &&\n                (mcps_indication->buffer[3] == 0x01)) {\n            _compliance_test.is_tx_confirmed = false;\n            _compliance_test.app_port = 224;\n            _compliance_test.app_data_size = 2;\n            _compliance_test.downlink_counter = 0;\n            _compliance_test.link_check = false;\n            _compliance_test.demod_margin = 0;\n            _compliance_test.nb_gateways = 0;\n            _compliance_test.running = true;\n            _compliance_test.state = 1;\n\n            _loramac.enable_adaptive_datarate(true);\n\n#if MBED_CONF_LORA_PHY      == 0\n            _loramac.LoRaMacTestSetDutyCycleOn(false);\n#endif\n            //5000ms\n            _loramac.LoRaMacSetTxTimer(5000);\n\n            //TODO: Should we call lora_state_machine here instead of just setting the state?\n            _device_current_state = DEVICE_STATE_COMPLIANCE_TEST;\n//            lora_state_machine(DEVICE_STATE_COMPLIANCE_TEST);\n            tr_debug(\"Compliance test activated.\");\n        }\n    } else {\n        _compliance_test.state = mcps_indication->buffer[0];\n        switch (_compliance_test.state) {\n            case 0: // Check compliance test disable command (ii)\n                _compliance_test.is_tx_confirmed = true;\n                _compliance_test.app_port = MBED_CONF_LORA_APP_PORT;\n                _compliance_test.app_data_size = LORAWAN_COMPLIANCE_TEST_DATA_SIZE;\n                _compliance_test.downlink_counter = 0;\n                _compliance_test.running = false;\n\n                _loramac.enable_adaptive_datarate(MBED_CONF_LORA_ADR_ON);\n\n#if MBED_CONF_LORA_PHY      == 0\n                _loramac.LoRaMacTestSetDutyCycleOn(MBED_CONF_LORA_DUTY_CYCLE_ON);\n#endif\n                // Go to idle state after compliance test mode.\n                tr_debug(\"Compliance test disabled.\");\n                _loramac.LoRaMacStopTxTimer();\n\n                // Clear any compliance test message stuff before going back to normal operation.\n                _loramac.reset_ongoing_tx();\n                lora_state_machine(DEVICE_STATE_IDLE);\n                break;\n            case 1: // (iii, iv)\n                _compliance_test.app_data_size = 2;\n                break;\n            case 2: // Enable confirmed messages (v)\n                _compliance_test.is_tx_confirmed = true;\n                _compliance_test.state = 1;\n                break;\n            case 3:  // Disable confirmed messages (vi)\n                _compliance_test.is_tx_confirmed = false;\n                _compliance_test.state = 1;\n                break;\n            case 4: // (vii)\n                _compliance_test.app_data_size = mcps_indication->buffer_size;\n\n                _compliance_test.app_data_buffer[0] = 4;\n                for (uint8_t i = 1; i < MIN(_compliance_test.app_data_size, LORAMAC_PHY_MAXPAYLOAD); ++i) {\n                    _compliance_test.app_data_buffer[i] = mcps_indication->buffer[i] + 1;\n                }\n\n                send_compliance_test_frame_to_mac();\n                break;\n            case 5: // (viii)\n                _loramac.setup_link_check_request();\n                break;\n            case 6: // (ix)\n                // Disable TestMode and revert back to normal operation\n                _compliance_test.is_tx_confirmed = true;\n                _compliance_test.app_port = MBED_CONF_LORA_APP_PORT;\n                _compliance_test.app_data_size = LORAWAN_COMPLIANCE_TEST_DATA_SIZE;\n                _compliance_test.downlink_counter = 0;\n                _compliance_test.running = false;\n\n                _loramac.enable_adaptive_datarate(MBED_CONF_LORA_ADR_ON);\n\n#if MBED_CONF_LORA_PHY      == 0\n                _loramac.LoRaMacTestSetDutyCycleOn(MBED_CONF_LORA_DUTY_CYCLE_ON);\n#endif\n                _loramac.join(true);\n                break;\n            case 7: // (x)\n                if (mcps_indication->buffer_size == 3) {\n                    loramac_mlme_req_t mlme_req;\n                    mlme_req.type = MLME_TXCW;\n                    mlme_req.cw_tx_mode.timeout = (uint16_t)((mcps_indication->buffer[1] << 8) | mcps_indication->buffer[2]);\n                    _loramac.mlme_request(&mlme_req);\n                } else if (mcps_indication->buffer_size == 7) {\n                    loramac_mlme_req_t mlme_req;\n                    mlme_req.type = MLME_TXCW_1;\n                    mlme_req.cw_tx_mode.timeout = (uint16_t)((mcps_indication->buffer[1] << 8) | mcps_indication->buffer[2]);\n                    mlme_req.cw_tx_mode.frequency = (uint32_t)((mcps_indication->buffer[3] << 16) | (mcps_indication->buffer[4] << 8)\n                        | mcps_indication->buffer[5]) * 100;\n                    mlme_req.cw_tx_mode.power = mcps_indication->buffer[6];\n                    _loramac.mlme_request(&mlme_req);\n                }\n                _compliance_test.state = 1;\n                break;\n        }\n    }\n}\n#endif\n\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRa MAC layer implementation\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n#include <stdlib.h>\n#include \"LoRaMac.h\"\n\n#include \"mbed-trace/mbed_trace.h\"\n#define TRACE_GROUP \"LMAC\"\n\nusing namespace events;\nusing namespace mbed;\n\n/*\n * LoRaWAN spec 6.2: AppKey is AES-128 key\n */\n#define APPKEY_KEY_LENGTH                           128\n\n/*!\n * Maximum length of the fOpts field\n */\n#define LORA_MAC_COMMAND_MAX_FOPTS_LENGTH           15\n\n/*!\n * LoRaMac duty cycle for the back-off procedure during the first hour.\n */\n#define BACKOFF_DC_1_HOUR                           100\n\n/*!\n * LoRaMac duty cycle for the back-off procedure during the next 10 hours.\n */\n#define BACKOFF_DC_10_HOURS                         1000\n\n/*!\n * LoRaMac duty cycle for the back-off procedure during the next 24 hours.\n */\n#define BACKOFF_DC_24_HOURS                         10000\n\n/*!\n * The frame direction definition for uplink communications.\n */\n#define UP_LINK                                     0\n\n/*!\n * The frame direction definition for downlink communications.\n */\n#define DOWN_LINK                                   1\n\n/**\n * A mask for the network ID.\n */\n#define LORAWAN_NETWORK_ID_MASK                     ( uint32_t )0xFE000000\n\n\nLoRaMac::LoRaMac()\n        : _lora_time(),\n          _lora_phy(_lora_time),\n          _mac_commands(),\n          _channel_plan(),\n          _lora_crypto(),\n          _ev_queue(NULL),\n          _mcps_indication(),\n          _mcps_confirmation(),\n          _mlme_indication(),\n          _mlme_confirmation(),\n          _is_nwk_joined(false),\n          _continuous_rx2_window_open(false),\n          _device_class(CLASS_A)\n{\n    _params.keys.dev_eui = NULL;\n    _params.keys.app_eui = NULL;\n    _params.keys.app_key = NULL;\n\n    memset(_params.keys.nwk_skey, 0, sizeof(_params.keys.nwk_skey));\n    memset(_params.keys.app_skey, 0, sizeof(_params.keys.app_skey));\n    memset(&_ongoing_tx_msg, 0, sizeof(_ongoing_tx_msg));\n\n    _params.dev_nonce = 0;\n    _params.net_id = 0;\n    _params.dev_addr = 0;\n    _params.tx_buffer_len = 0;\n    _params.rx_buffer_len = 0;\n    _params.ul_frame_counter = 0;\n    _params.dl_frame_counter = 0;\n    _params.is_ul_frame_counter_fixed = false;\n    _params.is_rx_window_enabled = true;\n    _params.adr_ack_counter = 0;\n    _params.is_node_ack_requested = false;\n    _params.is_srv_ack_requested = false;\n    _params.ul_nb_rep_counter = 0;\n    _params.timers.mac_init_time = 0;\n    _params.max_ack_timeout_retries = 1;\n    _params.ack_timeout_retry_counter = 1;\n    _params.is_ack_retry_timeout_expired = false;\n    _params.timers.tx_toa = 0;\n\n    _params.multicast_channels = NULL;\n\n    _params.sys_params.adr_on = false;\n    _params.sys_params.max_duty_cycle = 0;\n\n    reset_mcps_confirmation();\n    reset_mlme_confirmation();\n    reset_mcps_indication();\n}\n\nLoRaMac::~LoRaMac()\n{\n}\n\n/***************************************************************************\n * Radio event callbacks - delegated to Radio driver                       *\n **************************************************************************/\n\nconst loramac_mcps_confirm_t *LoRaMac::get_mcps_confirmation() const\n{\n    return &_mcps_confirmation;\n}\n\nconst loramac_mcps_indication_t *LoRaMac::get_mcps_indication() const\n{\n    return &_mcps_indication;\n}\n\nconst loramac_mlme_confirm_t *LoRaMac::get_mlme_confirmation() const\n{\n    return &_mlme_confirmation;\n}\n\nconst loramac_mlme_indication_t *LoRaMac::get_mlme_indication() const\n{\n    return &_mlme_indication;\n}\n\nvoid LoRaMac::post_process_mlme_request()\n{\n    _mlme_confirmation.pending = false;\n}\n\nvoid LoRaMac::post_process_mcps_req()\n{\n    _params.is_last_tx_join_request = false;\n    _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_OK;\n    if (_mcps_confirmation.req_type == MCPS_CONFIRMED) {\n        // An MCPS request for a CONFIRMED message has received an ack\n        // in the downlink message\n        if (_mcps_confirmation.ack_received) {\n            _params.is_node_ack_requested = false;\n            _mcps_confirmation.ack_received = false;\n            _mcps_indication.is_ack_recvd = false;\n            if (_params.is_ul_frame_counter_fixed == false) {\n                _params.ul_frame_counter++;\n            }\n        }\n    } else {\n        //UNCONFIRMED or PROPRIETARY\n        if (_params.is_ul_frame_counter_fixed == false) {\n            _params.ul_frame_counter++;\n        }\n    }\n}\n\nvoid LoRaMac::post_process_mcps_ind()\n{\n    _mcps_indication.pending = false;\n}\n\nvoid LoRaMac::post_process_mlme_ind()\n{\n    _mlme_indication.pending = false;\n}\n\nvoid LoRaMac::on_radio_tx_done(void)\n{\n    tr_info(\"tx_done\");\n\n    lorawan_time_t cur_time = _lora_time.get_current_time();\n\n    if (_device_class != CLASS_C) {\n        _lora_phy.put_radio_to_sleep();\n    } else {\n        // this will open a continuous RX2 window until time==RECV_DELAY1\n        if (!_continuous_rx2_window_open) {\n            open_rx2_window();\n        }\n    }\n\n    if (_params.is_rx_window_enabled == true) {\n        // start timer after which rx1_window will get opened\n        _lora_time.start(_params.timers.rx_window1_timer, _params.rx_window1_delay);\n\n        if (_device_class != CLASS_C) {\n            _lora_time.start(_params.timers.rx_window2_timer, _params.rx_window2_delay);\n        }\n\n        if (_params.is_node_ack_requested) {\n            _lora_time.start(_params.timers.ack_timeout_timer,\n                             _params.rx_window2_delay + _lora_phy.get_ack_timeout());\n        }\n    } else {\n        _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_OK;\n        _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;\n    }\n\n    _params.last_channel_idx = _params.channel;\n\n    _lora_phy.set_last_tx_done(_params.channel, _is_nwk_joined, cur_time);\n\n    _params.timers.aggregated_last_tx_time = cur_time;\n}\n\n/**\n * This part handles incoming frames in response to Radio RX Interrupt\n */\nvoid LoRaMac::handle_join_accept_frame(const uint8_t *payload, uint16_t size)\n{\n    uint32_t mic = 0;\n    uint32_t mic_rx = 0;\n\n    _mlme_confirmation.nb_retries = _params.join_request_trial_counter;\n\n    if (0 != _lora_crypto.decrypt_join_frame(payload + 1, size - 1,\n                                             _params.keys.app_key, APPKEY_KEY_LENGTH,\n                                             _params.rx_buffer + 1)) {\n        _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n        return;\n    }\n\n    _params.rx_buffer[0] = payload[0];\n\n    if (_lora_crypto.compute_join_frame_mic(_params.rx_buffer,\n                                            size - LORAMAC_MFR_LEN,\n                                            _params.keys.app_key,\n                                            APPKEY_KEY_LENGTH,\n                                            &mic) != 0) {\n        _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n        return;\n    }\n\n    mic_rx |= (uint32_t) _params.rx_buffer[size - LORAMAC_MFR_LEN];\n    mic_rx |= ((uint32_t) _params.rx_buffer[size - LORAMAC_MFR_LEN + 1] << 8);\n    mic_rx |= ((uint32_t) _params.rx_buffer[size - LORAMAC_MFR_LEN + 2] << 16);\n    mic_rx |= ((uint32_t) _params.rx_buffer[size - LORAMAC_MFR_LEN + 3] << 24);\n\n    if (mic_rx == mic) {\n        _lora_time.stop(_params.timers.rx_window2_timer);\n        if (_lora_crypto.compute_skeys_for_join_frame(_params.keys.app_key,\n                                                      APPKEY_KEY_LENGTH,\n                                                      _params.rx_buffer + 1,\n                                                      _params.dev_nonce,\n                                                      _params.keys.nwk_skey,\n                                                      _params.keys.app_skey) != 0) {\n            _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n            return;\n        }\n\n        _params.net_id = (uint32_t) _params.rx_buffer[4];\n        _params.net_id |= ((uint32_t) _params.rx_buffer[5] << 8);\n        _params.net_id |= ((uint32_t) _params.rx_buffer[6] << 16);\n\n        _params.dev_addr = (uint32_t) _params.rx_buffer[7];\n        _params.dev_addr |= ((uint32_t) _params.rx_buffer[8] << 8);\n        _params.dev_addr |= ((uint32_t) _params.rx_buffer[9] << 16);\n        _params.dev_addr |= ((uint32_t) _params.rx_buffer[10] << 24);\n\n        _params.sys_params.rx1_dr_offset = (_params.rx_buffer[11] >> 4) & 0x07;\n        _params.sys_params.rx2_channel.datarate = _params.rx_buffer[11] & 0x0F;\n\n        _params.sys_params.recv_delay1 = (_params.rx_buffer[12] & 0x0F);\n\n        if (_params.sys_params.recv_delay1 == 0) {\n            _params.sys_params.recv_delay1 = 1;\n        }\n\n        _params.sys_params.recv_delay1 *= 1000;\n        _params.sys_params.recv_delay2 = _params.sys_params.recv_delay1 + 1000;\n\n        // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\n        _lora_phy.apply_cf_list(&_params.rx_buffer[13], size - 17);\n\n        _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_OK;\n        _is_nwk_joined = true;\n        // Node joined successfully\n        _params.ul_frame_counter = 0;\n        _params.ul_nb_rep_counter = 0;\n\n    } else {\n        _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;\n    }\n}\n\nvoid LoRaMac::check_frame_size(uint16_t size)\n{\n    uint8_t value = _lora_phy.get_max_payload(_mcps_indication.rx_datarate,\n                                              _params.is_repeater_supported);\n\n    if (MAX(0, (int16_t) ((int16_t)size - (int16_t)LORA_MAC_FRMPAYLOAD_OVERHEAD))\n            > (int32_t) value) {\n        tr_error(\"Invalid frame size\");\n    }\n}\n\nbool LoRaMac::message_integrity_check(const uint8_t *const payload,\n                                      const uint16_t size,\n                                      uint8_t *const ptr_pos,\n                                      uint32_t address,\n                                      uint32_t *downlink_counter,\n                                      const uint8_t *nwk_skey)\n{\n    uint32_t mic = 0;\n    uint32_t mic_rx = 0;\n\n    uint16_t sequence_counter = 0;\n    uint16_t sequence_counter_prev = 0;\n    uint16_t sequence_counter_diff = 0;\n\n    sequence_counter = (uint16_t) payload[(*ptr_pos)++];\n    sequence_counter |= (uint16_t) payload[(*ptr_pos)++] << 8;\n\n    mic_rx |= (uint32_t) payload[size - LORAMAC_MFR_LEN];\n    mic_rx |= ((uint32_t) payload[size - LORAMAC_MFR_LEN + 1] << 8);\n    mic_rx |= ((uint32_t) payload[size - LORAMAC_MFR_LEN + 2] << 16);\n    mic_rx |= ((uint32_t) payload[size - LORAMAC_MFR_LEN + 3] << 24);\n\n    sequence_counter_prev = (uint16_t) *downlink_counter;\n    sequence_counter_diff = sequence_counter - sequence_counter_prev;\n    *downlink_counter += sequence_counter_diff;\n    if (sequence_counter < sequence_counter_prev) {\n        *downlink_counter += 0x10000;\n    }\n\n    // sizeof nws_skey must be the same as _params.keys.nwk_skey,\n    _lora_crypto.compute_mic(payload, size - LORAMAC_MFR_LEN,\n                             nwk_skey,\n                             sizeof(_params.keys.nwk_skey) * 8,\n                             address, DOWN_LINK, *downlink_counter, &mic);\n\n    if (mic_rx != mic) {\n        _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\n        return false;\n    }\n\n    if (sequence_counter_diff >= _lora_phy.get_maximum_frame_counter_gap()) {\n        _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOST;\n        _mcps_indication.dl_frame_counter = *downlink_counter;\n        return false;\n    }\n\n    return true;\n}\n\nvoid LoRaMac::extract_data_and_mac_commands(const uint8_t *payload,\n                                            uint16_t size,\n                                            uint8_t fopts_len,\n                                            uint8_t *nwk_skey,\n                                            uint8_t *app_skey,\n                                            uint32_t address,\n                                            uint32_t downlink_counter,\n                                            int16_t rssi,\n                                            int8_t snr)\n{\n    uint8_t frame_len = 0;\n    uint8_t payload_start_index = 8 + fopts_len;\n    uint8_t port = payload[payload_start_index++];\n    frame_len = (size - 4) - payload_start_index;\n\n    _mcps_indication.port = port;\n\n    // special handling of control port 0\n    if (port == 0) {\n        if (fopts_len == 0) {\n            // sizeof nws_skey must be the same as _params.keys.nwk_skey,\n            if (_lora_crypto.decrypt_payload(payload + payload_start_index,\n                                             frame_len,\n                                             nwk_skey,\n                                             sizeof(_params.keys.nwk_skey) * 8,\n                                             address,\n                                             DOWN_LINK,\n                                             downlink_counter,\n                                             _params.rx_buffer) != 0) {\n                _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n            }\n\n            if (_mac_commands.process_mac_commands(_params.rx_buffer, 0, frame_len,\n                                                   snr, _mlme_confirmation,\n                                                   _params.sys_params, _lora_phy)\n                    != LORAWAN_STATUS_OK) {\n                _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                return;\n            }\n\n            if (_mac_commands.has_sticky_mac_cmd()) {\n                set_mlme_schedule_ul_indication();\n                _mac_commands.clear_sticky_mac_cmd();\n            }\n\n            return;\n        }\n\n        _mcps_indication.pending = false;\n        _mcps_confirmation.ack_received = false;\n        _mcps_indication.is_ack_recvd = false;\n\n        return;\n    }\n\n    // normal unicast/multicast port handling\n    if (fopts_len > 0) {\n        // Decode Options field MAC commands. Omit the fPort.\n        if (_mac_commands.process_mac_commands(payload, 8,\n                                               payload_start_index - 1,\n                                               snr,\n                                               _mlme_confirmation,\n                                               _params.sys_params,\n                                               _lora_phy) != LORAWAN_STATUS_OK) {\n            _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n            return;\n        }\n\n        if (_mac_commands.has_sticky_mac_cmd()) {\n            set_mlme_schedule_ul_indication();\n            _mac_commands.clear_sticky_mac_cmd();\n        }\n    }\n\n    // sizeof app_skey must be the same as _params.keys.app_skey\n    if (_lora_crypto.decrypt_payload(payload + payload_start_index,\n                                     frame_len,\n                                     app_skey,\n                                     sizeof(_params.keys.app_skey)*8,\n                                     address,\n                                     DOWN_LINK,\n                                     downlink_counter,\n                                     _params.rx_buffer) != 0) {\n        _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n    } else {\n        _mcps_indication.buffer = _params.rx_buffer;\n        _mcps_indication.buffer_size = frame_len;\n        _mcps_indication.is_data_recvd = true;\n    }\n}\n\nvoid LoRaMac::extract_mac_commands_only(const uint8_t *payload,\n                                        int8_t snr,\n                                        uint8_t fopts_len)\n{\n    uint8_t payload_start_index = 8 + fopts_len;\n    if (fopts_len > 0) {\n        if (_mac_commands.process_mac_commands(payload, 8, payload_start_index,\n                                               snr, _mlme_confirmation,\n                                               _params.sys_params, _lora_phy)\n                != LORAWAN_STATUS_OK) {\n            _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n            return;\n        }\n\n        if (_mac_commands.has_sticky_mac_cmd()) {\n            set_mlme_schedule_ul_indication();\n            _mac_commands.clear_sticky_mac_cmd();\n        }\n    }\n}\n\nvoid LoRaMac::handle_data_frame(const uint8_t *const payload,\n                                const uint16_t size,\n                                uint8_t ptr_pos,\n                                uint8_t msg_type,\n                                int16_t rssi,\n                                int8_t snr)\n{\n    check_frame_size(size);\n\n    bool is_multicast = false;\n    loramac_frame_ctrl_t fctrl;\n    multicast_params_t *cur_multicast_params;\n    uint32_t address = 0;\n    uint32_t downlink_counter = 0;\n    uint8_t app_payload_start_index = 0;\n    uint8_t *nwk_skey = _params.keys.nwk_skey;\n    uint8_t *app_skey = _params.keys.app_skey;\n\n    address = payload[ptr_pos++];\n    address |= ((uint32_t) payload[ptr_pos++] << 8);\n    address |= ((uint32_t) payload[ptr_pos++] << 16);\n    address |= ((uint32_t) payload[ptr_pos++] << 24);\n\n    if (address != _params.dev_addr) {\n        // check if Multicast is destined for us\n        cur_multicast_params = _params.multicast_channels;\n\n        while (cur_multicast_params != NULL) {\n            if (address == cur_multicast_params->address) {\n                is_multicast = true;\n                nwk_skey = cur_multicast_params->nwk_skey;\n                app_skey = cur_multicast_params->app_skey;\n                downlink_counter = cur_multicast_params->dl_frame_counter;\n                break;\n            }\n\n            cur_multicast_params = cur_multicast_params->next;\n        }\n\n        if (!is_multicast) {\n            // We are not the destination of this frame.\n            _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\n            _mcps_indication.pending = false;\n            return;\n        }\n    } else {\n        is_multicast = false;\n        nwk_skey = _params.keys.nwk_skey;\n        app_skey = _params.keys.app_skey;\n        downlink_counter = _params.dl_frame_counter;\n    }\n\n    fctrl.value = payload[ptr_pos++];\n    app_payload_start_index = 8 + fctrl.bits.fopts_len;\n\n    //perform MIC check\n    if (!message_integrity_check(payload, size, &ptr_pos, address,\n                                 &downlink_counter, nwk_skey)) {\n        tr_error(\"MIC failed\");\n        _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\n        _mcps_indication.pending = false;\n        return;\n    }\n\n    // message is intended for us and MIC have passed, stop RX2 Window\n    // Spec: 3.3.4 Receiver Activity during the receive windows\n    _lora_time.stop(_params.timers.rx_window2_timer);\n\n    _mcps_confirmation.ack_received = false;\n    _mcps_indication.is_ack_recvd = false;\n    _mcps_indication.pending = true;\n    _mcps_indication.is_data_recvd = false;\n    _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_OK;\n    _mcps_indication.multicast = is_multicast;\n    _mcps_indication.fpending_status = fctrl.bits.fpending;\n    _mcps_indication.buffer = NULL;\n    _mcps_indication.buffer_size = 0;\n    _mcps_indication.dl_frame_counter = downlink_counter;\n    _mcps_indication.rssi = rssi;\n    _mcps_indication.snr = snr;\n\n    _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_OK;\n\n    _params.adr_ack_counter = 0;\n    _mac_commands.clear_repeat_buffer();\n\n    if (is_multicast) {\n        _mcps_indication.type = MCPS_MULTICAST;\n\n        // Discard if its a repeated message\n        if ((cur_multicast_params->dl_frame_counter == downlink_counter)\n                && (cur_multicast_params->dl_frame_counter != 0)) {\n            _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n            _mcps_indication.dl_frame_counter = downlink_counter;\n            _mcps_indication.pending = false;\n\n            return;\n        }\n\n        cur_multicast_params->dl_frame_counter = downlink_counter;\n\n    } else {\n        if (msg_type == FRAME_TYPE_DATA_CONFIRMED_DOWN) {\n            _params.is_srv_ack_requested = true;\n            _mcps_indication.type = MCPS_CONFIRMED;\n\n            if ((_params.dl_frame_counter == downlink_counter)\n                    && (_params.dl_frame_counter != 0)) {\n                // Duplicated confirmed downlink. Skip indication.\n                // In this case, the MAC layer shall accept the MAC commands\n                // which are included in the downlink retransmission.\n                // It should not provide the same frame to the application\n                // layer again. The MAC layer accepts the acknowledgement.\n                tr_debug(\"Discarding duplicate frame\");\n                _mcps_indication.pending = false;\n                _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n            }\n        } else if (msg_type == FRAME_TYPE_DATA_UNCONFIRMED_DOWN) {\n            _params.is_srv_ack_requested = false;\n            _mcps_indication.type = MCPS_UNCONFIRMED;\n\n            if ((_params.dl_frame_counter == downlink_counter)\n                    && (_params.dl_frame_counter != 0)) {\n                tr_debug(\"Discarding duplicate frame\");\n                _mcps_indication.pending = false;\n                _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n\n                return;\n            }\n        }\n        _params.dl_frame_counter = downlink_counter;\n    }\n\n    // This must be done before parsing the payload and the MAC commands.\n    // We need to reset the MacCommandsBufferIndex here, since we need\n    // to take retransmissions and repetitions into account. Error cases\n    // will be handled in function OnMacStateCheckTimerEvent.\n    if (_params.is_node_ack_requested) {\n        if (fctrl.bits.ack) {\n            _mac_commands.clear_command_buffer();\n            _mcps_confirmation.ack_received = fctrl.bits.ack;\n            _mcps_indication.is_ack_recvd = fctrl.bits.ack;\n        }\n    } else {\n        _mac_commands.clear_command_buffer();\n    }\n\n    uint8_t frame_len = (size - 4) - app_payload_start_index;\n\n    if (frame_len > 0) {\n        extract_data_and_mac_commands(payload, size, fctrl.bits.fopts_len,\n                                      nwk_skey, app_skey, address,\n                                      downlink_counter, rssi, snr);\n    } else {\n        extract_mac_commands_only(payload, snr, fctrl.bits.fopts_len);\n    }\n\n    // Handle proprietary messages.\n    if (msg_type == FRAME_TYPE_PROPRIETARY) {\n        memcpy(_params.rx_buffer, &payload[ptr_pos], size);\n\n        _mcps_indication.type = MCPS_PROPRIETARY;\n        _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_OK;\n        _mcps_indication.buffer = _params.rx_buffer;\n        _mcps_indication.buffer_size = size - ptr_pos;\n    }\n\n    // only stop act timer, if the ack is actually recieved\n    if (_mcps_confirmation.ack_received) {\n        _lora_time.stop(_params.timers.ack_timeout_timer);\n    }\n}\n\nvoid LoRaMac::set_batterylevel_callback(mbed::Callback<uint8_t(void)> battery_level)\n{\n    _mac_commands.set_batterylevel_callback(battery_level);\n}\n\nvoid LoRaMac::on_radio_rx_done(const uint8_t *const payload, uint16_t size,\n                               int16_t rssi, int8_t snr)\n{\n    // stop the RX1 timer here if its the first RX slot.\n    // If the MIC will pass we will stop RX2 timer as well later.\n    // If its RX2, stop RX2 timer.\n    if (_params.rx_slot == RX_SLOT_WIN_1) {\n        _lora_time.stop(_params.timers.rx_window1_timer);\n    } else if (_params.rx_slot == RX_SLOT_WIN_2) {\n        _lora_time.stop(_params.timers.rx_window2_timer);\n    }\n\n    if (_device_class == CLASS_C) {\n        if (!_continuous_rx2_window_open) {\n            open_rx2_window();\n        }\n     } else {\n         _lora_phy.put_radio_to_sleep();\n     }\n\n    loramac_mhdr_t mac_hdr;\n    uint8_t pos = 0;\n    mac_hdr.value = payload[pos++];\n\n    switch (mac_hdr.bits.mtype) {\n\n        case FRAME_TYPE_JOIN_ACCEPT:\n\n            if (nwk_joined()) {\n                _mlme_confirmation.pending = false;\n                return;\n            } else {\n                handle_join_accept_frame(payload, size);\n                _mlme_confirmation.pending = true;\n            }\n\n            break;\n\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\n        case FRAME_TYPE_PROPRIETARY:\n\n            handle_data_frame(payload, size, pos, mac_hdr.bits.mtype, rssi, snr);\n\n            break;\n\n        default:\n            break;\n    }\n}\n\nvoid LoRaMac::on_radio_tx_timeout(void)\n{\n    _lora_time.stop(_params.timers.rx_window1_timer);\n    _lora_time.stop(_params.timers.rx_window2_timer);\n    _lora_time.stop(_params.timers.ack_timeout_timer);\n\n    if (_device_class == CLASS_C) {\n        open_rx2_window();\n    } else {\n        _lora_phy.put_radio_to_sleep();\n    }\n\n    _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\n    _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\n\n    _mac_commands.clear_command_buffer();\n\n    _mcps_confirmation.nb_retries = _params.ack_timeout_retry_counter;\n    _mcps_confirmation.ack_received = false;\n    _mcps_confirmation.tx_toa = 0;\n\n    post_process_mcps_req();\n}\n\nrx_slot_t LoRaMac::on_radio_rx_timeout(bool is_timeout)\n{\n    if (_device_class != CLASS_C) {\n        _lora_phy.put_radio_to_sleep();\n    }\n\n    if (_params.rx_slot == RX_SLOT_WIN_1) {\n        if (_params.is_node_ack_requested == true) {\n            _mcps_confirmation.status = is_timeout ?\n                    LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT :\n                    LORAMAC_EVENT_INFO_STATUS_RX1_ERROR;\n        }\n        _mlme_confirmation.status = is_timeout ?\n                LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT :\n                LORAMAC_EVENT_INFO_STATUS_RX1_ERROR;\n\n        if (_device_class != CLASS_C) {\n            if (_lora_time.get_elapsed_time(_params.timers.aggregated_last_tx_time) >= _params.rx_window2_delay) {\n                _lora_time.stop(_params.timers.rx_window2_timer);\n            }\n        }\n    } else {\n        if (_params.is_node_ack_requested == true) {\n            _mcps_confirmation.status = is_timeout ?\n                    LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT :\n                    LORAMAC_EVENT_INFO_STATUS_RX2_ERROR;\n        }\n\n        _mlme_confirmation.status = is_timeout ?\n                LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT :\n                LORAMAC_EVENT_INFO_STATUS_RX2_ERROR;\n    }\n\n    if (_device_class == CLASS_C) {\n        open_rx2_window();\n    }\n\n    return _params.rx_slot;\n}\n\nbool LoRaMac::continue_joining_process()\n{\n    if (_params.join_request_trial_counter >= _params.max_join_request_trials) {\n        return false;\n    }\n\n    // Schedule a retry\n    if (handle_retransmission() != LORAWAN_STATUS_OK) {\n        return false;\n    }\n\n    return true;\n}\n\nbool LoRaMac::continue_sending_process()\n{\n    if (_params.ack_timeout_retry_counter > _params.max_ack_timeout_retries) {\n        _mac_commands.clear_command_buffer();\n        _params.adr_ack_counter++;\n        return false;\n    }\n\n    // retransmission will be handled in on_ack_timeout() whence the ACK timeout\n    // gets fired\n    return true;\n}\n\nlorawan_status_t LoRaMac::send_join_request()\n{\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n    loramac_mhdr_t mac_hdr;\n    loramac_frame_ctrl_t fctrl;\n\n    _params.sys_params.channel_data_rate = _lora_phy.get_alternate_DR(\n            _params.join_request_trial_counter + 1);\n\n    mac_hdr.value = 0;\n    mac_hdr.bits.mtype = FRAME_TYPE_JOIN_REQ;\n\n    fctrl.value = 0;\n    fctrl.bits.adr = _params.sys_params.adr_on;\n    _params.is_last_tx_join_request = true;\n\n    /* In case of join request retransmissions, the stack must prepare\n     * the frame again, because the network server keeps track of the random\n     * LoRaMacDevNonce values to prevent reply attacks. */\n    status = prepare_frame(&mac_hdr, &fctrl, 0, NULL, 0);\n\n    if (status == LORAWAN_STATUS_OK) {\n        status = schedule_tx();\n    } else {\n        tr_error(\"Retransmission: error %d\", status);\n    }\n\n    return status;\n}\n\n/**\n * This function handles retransmission of failed or unacknowledged\n * outgoing traffic\n */\nlorawan_status_t LoRaMac::handle_retransmission()\n{\n    if (!nwk_joined() && (_mlme_confirmation.req_type == MLME_JOIN)) {\n        return send_join_request();\n    }\n\n    return schedule_tx();\n}\n\n/**\n * This function is called when the backoff_timer gets fired.\n * It is used for re-scheduling an unsent packet in the pipe. This packet\n * can be a Join Request or any other data packet.\n */\nvoid LoRaMac::on_backoff_timer_expiry(void)\n{\n    Lock lock(*this);\n    lorawan_status_t status = schedule_tx();\n    MBED_ASSERT(status==LORAWAN_STATUS_OK);\n    (void) status;\n}\n\nvoid LoRaMac::open_rx1_window(void)\n{\n    Lock lock(*this);\n    tr_debug(\"Opening RX1 Window\");\n    _continuous_rx2_window_open = false;\n    _lora_time.stop(_params.timers.rx_window1_timer);\n    _params.rx_slot = RX_SLOT_WIN_1;\n\n    _params.rx_window1_config.channel = _params.channel;\n    _params.rx_window1_config.dr_offset = _params.sys_params.rx1_dr_offset;\n    _params.rx_window1_config.dl_dwell_time = _params.sys_params.downlink_dwell_time;\n    _params.rx_window1_config.is_repeater_supported = _params.is_repeater_supported;\n    _params.rx_window1_config.is_rx_continuous = false;\n    _params.rx_window1_config.rx_slot = _params.rx_slot;\n\n    if (_device_class == CLASS_C) {\n        _lora_phy.put_radio_to_standby();\n    }\n\n    _mcps_indication.rx_datarate = _params.rx_window1_config.datarate;\n    _lora_phy.rx_config(&_params.rx_window1_config);\n\n    _lora_phy.setup_rx_window(_params.rx_window1_config.is_rx_continuous,\n                              _params.sys_params.max_rx_win_time);\n}\n\nvoid LoRaMac::open_rx2_window()\n{\n    Lock lock(*this);\n    tr_debug(\"Opening RX2 Window\");\n    _lora_time.stop(_params.timers.rx_window2_timer);\n\n    _params.rx_window2_config.channel = _params.channel;\n    _params.rx_window2_config.frequency = _params.sys_params.rx2_channel.frequency;\n    _params.rx_window2_config.dl_dwell_time = _params.sys_params.downlink_dwell_time;\n    _params.rx_window2_config.is_repeater_supported = _params.is_repeater_supported;\n    _params.rx_window2_config.rx_slot = RX_SLOT_WIN_2;\n\n    if (get_device_class() == CLASS_C) {\n        _continuous_rx2_window_open = true;\n        _params.rx_window2_config.is_rx_continuous = true;\n    } else {\n        _continuous_rx2_window_open = false;\n        _params.rx_window2_config.is_rx_continuous = false;\n    }\n\n    _mcps_indication.rx_datarate = _params.rx_window2_config.datarate;\n\n    if (_lora_phy.rx_config(&_params.rx_window2_config)) {\n\n        _lora_phy.setup_rx_window(_params.rx_window2_config.is_rx_continuous,\n                                  _params.sys_params.max_rx_win_time);\n\n        _params.rx_slot = _params.rx_window2_config.is_rx_continuous ?\n                          RX_SLOT_WIN_CLASS_C : RX_SLOT_WIN_2;\n    }\n}\n\nvoid LoRaMac::on_ack_timeout_timer_event(void)\n{\n    Lock lock(*this);\n\n    if (_params.ack_timeout_retry_counter > _params.max_ack_timeout_retries) {\n        if (get_device_class() == CLASS_C) {\n            // no need to use EventQueue as LoRaWANStack and LoRaMac are always\n            // in same context\n            _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n            _ack_expiry_handler_for_class_c.call();\n        }\n        return;\n    }\n\n    tr_debug(\"ACK_TIMEOUT Elapses, Retrying ...\");\n    _lora_time.stop(_params.timers.ack_timeout_timer);\n\n    // reduce data rate on every 2nd attempt if and only if the\n    // ADR is on\n    if ((_params.ack_timeout_retry_counter % 2)\n            && (_params.sys_params.adr_on)) {\n        tr_debug(\"Trading datarate for range\");\n        _params.sys_params.channel_data_rate = _lora_phy.get_next_lower_tx_datarate(_params.sys_params.channel_data_rate);\n    }\n\n    _mcps_confirmation.nb_retries = _params.ack_timeout_retry_counter;\n\n    // Schedule a retry\n    if (handle_retransmission() != LORAWAN_STATUS_OK) {\n        // In a case when enabled channels are not found, PHY layer\n        // resorts to default channels. Next attempt should go forward as the\n        // default channels are always available if there is a base station in the\n        // vicinity. Otherwise something is wrong with the stack, we should assert\n        // here\n        _mac_commands.clear_command_buffer();\n        _params.is_node_ack_requested = false;\n        _mcps_confirmation.ack_received = false;\n        _mcps_confirmation.nb_retries = _params.ack_timeout_retry_counter;\n\n        // now that is a critical failure\n        lorawan_status_t status = handle_retransmission();\n        MBED_ASSERT(status==LORAWAN_STATUS_OK);\n        (void) status;\n    }\n\n    _params.ack_timeout_retry_counter++;\n}\n\nbool LoRaMac::validate_payload_length(uint16_t length,\n                                      int8_t datarate,\n                                      uint8_t fopts_len)\n{\n    uint16_t max_value = 0;\n    uint16_t payloadSize = 0;\n\n    max_value = _lora_phy.get_max_payload(datarate, _params.is_repeater_supported);\n\n    // Calculate the resulting payload size\n    payloadSize = (length + fopts_len);\n\n    // Validation of the application payload size\n    if ((payloadSize <= max_value) &&\n            (payloadSize <= LORAMAC_PHY_MAXPAYLOAD)) {\n        return true;\n    }\n    return false;\n}\n\nvoid LoRaMac::set_mlme_schedule_ul_indication(void)\n{\n    _mlme_indication.indication_type = MLME_SCHEDULE_UPLINK;\n    _mlme_indication.pending = true;\n}\n\n// This is not actual transmission. It just schedules a message in response\n// to MCPS request\nlorawan_status_t LoRaMac::send(loramac_mhdr_t *machdr, const uint8_t fport,\n                               const void *fbuffer, uint16_t fbuffer_size)\n{\n    loramac_frame_ctrl_t fctrl;\n\n    fctrl.value = 0;\n    fctrl.bits.fopts_len = 0;\n    fctrl.bits.fpending = 0;\n    fctrl.bits.ack = false;\n    fctrl.bits.adr_ack_req = false;\n    fctrl.bits.adr = _params.sys_params.adr_on;\n\n    lorawan_status_t status = prepare_frame(machdr, &fctrl, fport, fbuffer,\n                                            fbuffer_size);\n\n    if (status != LORAWAN_STATUS_OK) {\n        return status;\n    }\n\n    // Reset confirm parameters\n    _mcps_confirmation.nb_retries = 0;\n    _mcps_confirmation.ack_received = false;\n    _mcps_confirmation.ul_frame_counter = _params.ul_frame_counter;\n\n    status = schedule_tx();\n\n    return status;\n}\n\nint LoRaMac::get_backoff_timer_event_id(void)\n{\n    return _params.timers.backoff_timer.timer_id;\n}\n\nlorawan_status_t LoRaMac::clear_tx_pipe(void)\n{\n    // check if the event is not already queued\n    if (_ev_queue->time_left(get_backoff_timer_event_id()) > 0) {\n        _lora_time.stop(_params.timers.backoff_timer);\n        _lora_time.stop(_params.timers.ack_timeout_timer);\n        memset(_params.tx_buffer, 0, sizeof _params.tx_buffer);\n        _params.tx_buffer_len = 0;\n        reset_ongoing_tx(true);\n        tr_debug(\"Sending Cancelled\");\n        return LORAWAN_STATUS_OK;\n    }\n\n    return LORAWAN_STATUS_BUSY;\n}\n\nlorawan_status_t LoRaMac::schedule_tx()\n{\n    channel_selection_params_t next_channel;\n    lorawan_time_t backoff_time = 0;\n\n    if (_params.sys_params.max_duty_cycle == 255) {\n        return LORAWAN_STATUS_DEVICE_OFF;\n    }\n\n    if (_params.sys_params.max_duty_cycle == 0) {\n        _params.timers.aggregated_timeoff = 0;\n    }\n\n    calculate_backOff(_params.last_channel_idx);\n\n    next_channel.aggregate_timeoff = _params.timers.aggregated_timeoff;\n    next_channel.current_datarate = _params.sys_params.channel_data_rate;\n    _params.is_dutycycle_on = MBED_CONF_LORA_DUTY_CYCLE_ON;\n    next_channel.dc_enabled = _params.is_dutycycle_on;\n    next_channel.joined = _is_nwk_joined;\n    next_channel.last_aggregate_tx_time = _params.timers.aggregated_last_tx_time;\n\n    lorawan_status_t status = _lora_phy.set_next_channel(&next_channel,\n                                                         &_params.channel,\n                                                         &backoff_time,\n                                                         &_params.timers.aggregated_timeoff);\n\n    switch (status) {\n        case LORAWAN_STATUS_NO_CHANNEL_FOUND:\n        case LORAWAN_STATUS_NO_FREE_CHANNEL_FOUND:\n            return status;\n        case LORAWAN_STATUS_DUTYCYCLE_RESTRICTED:\n            if (backoff_time != 0) {\n                tr_debug(\"DC enforced: Transmitting in %lu ms\", backoff_time);\n                _lora_time.start(_params.timers.backoff_timer, backoff_time);\n            }\n            return LORAWAN_STATUS_OK;\n        default:\n            break;\n    }\n\n    tr_debug(\"TX: Channel=%d, DR=%d\", _params.channel, next_channel.current_datarate);\n\n    uint8_t dr_offset = _lora_phy.apply_DR_offset(_params.sys_params.channel_data_rate,\n                                                  _params.sys_params.rx1_dr_offset);\n\n    _lora_phy.compute_rx_win_params(dr_offset, _params.sys_params.min_rx_symb,\n                                    _params.sys_params.max_sys_rx_error,\n                                    &_params.rx_window1_config);\n\n    _lora_phy.compute_rx_win_params(_params.sys_params.rx2_channel.datarate,\n                                    _params.sys_params.min_rx_symb,\n                                    _params.sys_params.max_sys_rx_error,\n                                    &_params.rx_window2_config);\n\n    if (!_is_nwk_joined) {\n        _params.rx_window1_delay = _params.sys_params.join_accept_delay1\n                + _params.rx_window1_config.window_offset;\n        _params.rx_window2_delay = _params.sys_params.join_accept_delay2\n                + _params.rx_window2_config.window_offset;\n    } else {\n        if (validate_payload_length(_params.tx_buffer_len,\n                                    _params.sys_params.channel_data_rate,\n                                    _mac_commands.get_mac_cmd_length()) == false) {\n            return LORAWAN_STATUS_LENGTH_ERROR;\n        }\n        _params.rx_window1_delay = _params.sys_params.recv_delay1\n                + _params.rx_window1_config.window_offset;\n        _params.rx_window2_delay = _params.sys_params.recv_delay2\n                + _params.rx_window2_config.window_offset;\n    }\n\n    // handle the ack to the server here so that if the sending was cancelled\n    // by the user in the backoff period, we would still ack the previous frame.\n    if (_params.is_srv_ack_requested) {\n        _params.is_srv_ack_requested = false;\n    }\n\n    return send_frame_on_channel(_params.channel);\n}\n\nvoid LoRaMac::calculate_backOff(uint8_t channel)\n{\n    lorawan_time_t elapsed_time = _lora_time.get_elapsed_time(_params.timers.mac_init_time);\n\n    _params.is_dutycycle_on = MBED_CONF_LORA_DUTY_CYCLE_ON;\n\n    _lora_phy.calculate_backoff(_is_nwk_joined, _params.is_last_tx_join_request, _params.is_dutycycle_on,\n                                channel, elapsed_time, _params.timers.tx_toa);\n\n    // Update aggregated time-off. This must be an assignment and no incremental\n    // update as we do only calculate the time-off based on the last transmission\n    _params.timers.aggregated_timeoff = (_params.timers.tx_toa * _params.sys_params.aggregated_duty_cycle\n                                         - _params.timers.tx_toa);\n}\n\nvoid LoRaMac::reset_mac_parameters(void)\n{\n    _is_nwk_joined = false;\n\n    _params.ul_frame_counter = 0;\n    _params.dl_frame_counter = 0;\n    _params.adr_ack_counter = 0;\n\n    _params.ul_nb_rep_counter = 0;\n\n    _params.max_ack_timeout_retries = 1;\n    _params.ack_timeout_retry_counter = 1;\n    _params.is_ack_retry_timeout_expired = false;\n\n    _params.sys_params.max_duty_cycle = 0;\n    _params.sys_params.aggregated_duty_cycle = 1;\n\n    _mac_commands.clear_command_buffer();\n    _mac_commands.clear_repeat_buffer();\n    _mac_commands.clear_mac_commands_in_next_tx();\n\n    _params.is_rx_window_enabled = true;\n\n    _lora_phy.reset_to_default_values(&_params, false);\n\n    _params.is_node_ack_requested = false;\n    _params.is_srv_ack_requested = false;\n\n    multicast_params_t *cur = _params.multicast_channels;\n    while (cur != NULL) {\n        cur->dl_frame_counter = 0;\n        cur = cur->next;\n    }\n    _params.channel = 0;\n    _params.last_channel_idx = _params.channel;\n}\n\nuint8_t LoRaMac::get_default_tx_datarate()\n{\n    return _lora_phy.get_default_tx_datarate();\n}\n\nvoid LoRaMac::enable_adaptive_datarate(bool adr_enabled)\n{\n    _params.sys_params.adr_on = adr_enabled;\n}\n\nlorawan_status_t LoRaMac::set_channel_data_rate(uint8_t data_rate)\n{\n    if (_params.sys_params.adr_on) {\n        tr_error(\"Cannot set data rate. Please turn off ADR first.\");\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    if (_lora_phy.verify_tx_datarate(data_rate, false) == true) {\n        _params.sys_params.channel_data_rate = data_rate;\n    } else {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nbool LoRaMac::tx_ongoing()\n{\n    return _ongoing_tx_msg.tx_ongoing;\n}\n\nvoid LoRaMac::set_tx_ongoing(bool ongoing)\n{\n    _ongoing_tx_msg.tx_ongoing = ongoing;\n}\n\nvoid LoRaMac::reset_ongoing_tx(bool reset_pending)\n{\n    _ongoing_tx_msg.tx_ongoing = false;\n    memset(_ongoing_tx_msg.f_buffer, 0, MBED_CONF_LORA_TX_MAX_SIZE);\n    _ongoing_tx_msg.f_buffer_size = 0;\n    if (reset_pending) {\n        _ongoing_tx_msg.pending_size = 0;\n    }\n}\n\nint16_t LoRaMac::prepare_ongoing_tx(const uint8_t port,\n                                    const uint8_t *const data,\n                                    uint16_t length,\n                                    uint8_t flags,\n                                    uint8_t num_retries)\n{\n    _ongoing_tx_msg.port = port;\n\n    uint8_t max_possible_size = get_max_possible_tx_size(length);\n\n    if (max_possible_size > MBED_CONF_LORA_TX_MAX_SIZE) {\n        max_possible_size = MBED_CONF_LORA_TX_MAX_SIZE;\n    }\n\n    if (max_possible_size < length) {\n        tr_info(\"Cannot transmit %d bytes. Possible TX Size is %d bytes\",\n                length, max_possible_size);\n\n        _ongoing_tx_msg.pending_size = length - max_possible_size;\n        _ongoing_tx_msg.f_buffer_size = max_possible_size;\n        memcpy(_ongoing_tx_msg.f_buffer, data, _ongoing_tx_msg.f_buffer_size);\n    } else {\n        _ongoing_tx_msg.f_buffer_size = length;\n        _ongoing_tx_msg.pending_size = 0;\n        if (length > 0) {\n            memcpy(_ongoing_tx_msg.f_buffer, data, length);\n        }\n    }\n\n    // Handles unconfirmed messages\n    if (flags & MSG_UNCONFIRMED_FLAG) {\n         _ongoing_tx_msg.type = MCPS_UNCONFIRMED;\n         _ongoing_tx_msg.fport = port;\n         _ongoing_tx_msg.nb_trials = 1;\n    }\n\n    // Handles confirmed messages\n    if (flags & MSG_CONFIRMED_FLAG) {\n        _ongoing_tx_msg.type = MCPS_CONFIRMED;\n        _ongoing_tx_msg.fport = port;\n        _ongoing_tx_msg.nb_trials = num_retries;\n    }\n\n    // Handles proprietary messages\n    if (flags & MSG_PROPRIETARY_FLAG) {\n        _ongoing_tx_msg.type = MCPS_PROPRIETARY;\n        _ongoing_tx_msg.fport = port;\n        _ongoing_tx_msg.nb_trials = 1;\n    }\n\n    tr_info(\"RTS = %u bytes, PEND = %u, Port: %u\",\n            _ongoing_tx_msg.f_buffer_size, _ongoing_tx_msg.pending_size,\n            _ongoing_tx_msg.fport);\n\n    return _ongoing_tx_msg.f_buffer_size;\n}\n\nlorawan_status_t LoRaMac::send_ongoing_tx()\n{\n    lorawan_status_t status;\n    _params.is_last_tx_join_request = false;\n    int8_t datarate = _params.sys_params.channel_data_rate;\n\n    // This prohibits the data rate going below the minimum value.\n    datarate = MAX(datarate, (int8_t)_lora_phy.get_minimum_tx_datarate());\n\n    loramac_mhdr_t machdr;\n    machdr.value = 0;\n\n    reset_mcps_confirmation();\n\n    _params.ack_timeout_retry_counter = 1;\n    _params.max_ack_timeout_retries = 1;\n\n    if (MCPS_UNCONFIRMED == _ongoing_tx_msg.type) {\n        machdr.bits.mtype = FRAME_TYPE_DATA_UNCONFIRMED_UP;\n    } else if (_ongoing_tx_msg.type == MCPS_CONFIRMED) {\n        machdr.bits.mtype = FRAME_TYPE_DATA_CONFIRMED_UP;\n        _params.max_ack_timeout_retries = _ongoing_tx_msg.nb_trials;\n    } else if (_ongoing_tx_msg.type == MCPS_PROPRIETARY) {\n        machdr.bits.mtype = FRAME_TYPE_PROPRIETARY;\n    } else {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    if (_params.sys_params.adr_on == false) {\n        if (_lora_phy.verify_tx_datarate(datarate, false) == true) {\n            _params.sys_params.channel_data_rate = datarate;\n        } else {\n            return LORAWAN_STATUS_PARAMETER_INVALID;\n        }\n    }\n\n    status = send(&machdr, _ongoing_tx_msg.fport, _ongoing_tx_msg.f_buffer,\n                  _ongoing_tx_msg.f_buffer_size);\n    if (status == LORAWAN_STATUS_OK) {\n        _mcps_confirmation.req_type = _ongoing_tx_msg.type;\n    }\n\n    return status;\n}\n\ndevice_class_t LoRaMac::get_device_class() const\n{\n    return _device_class;\n}\n\nvoid LoRaMac::set_device_class(const device_class_t &device_class,\n                               mbed::Callback<void(void)>ack_expiry_handler)\n{\n    _device_class = device_class;\n    _ack_expiry_handler_for_class_c = ack_expiry_handler;\n\n    if (CLASS_A == _device_class) {\n        tr_debug(\"Changing device class to -> CLASS_A\");\n        _lora_phy.put_radio_to_sleep();\n    } else if (CLASS_C == _device_class) {\n        _params.is_node_ack_requested = false;\n        _lora_phy.put_radio_to_sleep();\n        _lora_phy.compute_rx_win_params(_params.sys_params.rx2_channel.datarate,\n                                        _params.sys_params.min_rx_symb,\n                                        _params.sys_params.max_sys_rx_error,\n                                        &_params.rx_window2_config);\n    }\n\n    if (CLASS_C == _device_class) {\n        tr_debug(\"Changing device class to -> CLASS_C\");\n        open_rx2_window();\n    }\n\n\n}\n\nvoid LoRaMac::setup_link_check_request()\n{\n    reset_mlme_confirmation();\n\n    _mlme_confirmation.req_type = MLME_LINK_CHECK;\n    _mlme_confirmation.pending = true;\n    _mac_commands.add_link_check_req();\n}\n\nlorawan_status_t LoRaMac::prepare_join(const lorawan_connect_t *params, bool is_otaa)\n{\n    if (params) {\n        if (is_otaa) {\n            if ((params->connection_u.otaa.dev_eui == NULL)\n                    || (params->connection_u.otaa.app_eui == NULL)\n                    || (params->connection_u.otaa.app_key == NULL)\n                    || (params->connection_u.otaa.nb_trials == 0)) {\n                return LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            _params.keys.dev_eui = params->connection_u.otaa.dev_eui;\n            _params.keys.app_eui = params->connection_u.otaa.app_eui;\n            _params.keys.app_key = params->connection_u.otaa.app_key;\n            _params.max_join_request_trials = params->connection_u.otaa.nb_trials;\n\n            if (!_lora_phy.verify_nb_join_trials(params->connection_u.otaa.nb_trials)) {\n                // Value not supported, get default\n                _params.max_join_request_trials = MBED_CONF_LORA_NB_TRIALS;\n            }\n            // Reset variable JoinRequestTrials\n            _params.join_request_trial_counter = 0;\n        } else {\n            if ((params->connection_u.abp.dev_addr == 0)\n                    || (params->connection_u.abp.nwk_id == 0)\n                    || (params->connection_u.abp.nwk_skey == NULL)\n                    || (params->connection_u.abp.app_skey == NULL)) {\n                return LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n\n            _params.net_id = params->connection_u.abp.nwk_id;\n            _params.dev_addr = params->connection_u.abp.dev_addr;\n\n            memcpy(_params.keys.nwk_skey, params->connection_u.abp.nwk_skey,\n                   sizeof(_params.keys.nwk_skey));\n\n            memcpy(_params.keys.app_skey, params->connection_u.abp.app_skey,\n                   sizeof(_params.keys.app_skey));\n        }\n    } else {\n#if MBED_CONF_LORA_OVER_THE_AIR_ACTIVATION\n        const static uint8_t dev_eui[] = MBED_CONF_LORA_DEVICE_EUI;\n        const static uint8_t app_eui[] = MBED_CONF_LORA_APPLICATION_EUI;\n        const static uint8_t app_key[] = MBED_CONF_LORA_APPLICATION_KEY;\n\n        _params.keys.app_eui = const_cast<uint8_t *>(app_eui);\n        _params.keys.dev_eui = const_cast<uint8_t *>(dev_eui);\n        _params.keys.app_key = const_cast<uint8_t *>(app_key);\n        _params.max_join_request_trials = MBED_CONF_LORA_NB_TRIALS;\n\n        // Reset variable JoinRequestTrials\n        _params.join_request_trial_counter = 0;\n\n        reset_mac_parameters();\n\n        _params.sys_params.channel_data_rate =\n            _lora_phy.get_alternate_DR(_params.join_request_trial_counter + 1);\n\n#else\n        const static uint8_t nwk_skey[] = MBED_CONF_LORA_NWKSKEY;\n        const static uint8_t app_skey[] = MBED_CONF_LORA_APPSKEY;\n\n        _params.net_id = (MBED_CONF_LORA_DEVICE_ADDRESS & LORAWAN_NETWORK_ID_MASK);\n        _params.dev_addr = MBED_CONF_LORA_DEVICE_ADDRESS;\n\n        memcpy(_params.keys.nwk_skey, nwk_skey, sizeof(_params.keys.nwk_skey));\n\n        memcpy(_params.keys.app_skey, app_skey, sizeof(_params.keys.app_skey));\n#endif\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMac::join(bool is_otaa)\n{\n    if (!is_otaa) {\n        set_nwk_joined(true);\n        return LORAWAN_STATUS_OK;\n    }\n\n    reset_mlme_confirmation();\n    _mlme_confirmation.req_type = MLME_JOIN;\n\n    return send_join_request();\n}\n\nstatic void memcpy_convert_endianess(uint8_t *dst,\n                                     const uint8_t *src,\n                                     uint16_t size)\n{\n    dst = dst + (size - 1);\n    while (size--) {\n        *dst-- = *src++;\n    }\n}\n\nlorawan_status_t LoRaMac::prepare_frame(loramac_mhdr_t *machdr,\n                                        loramac_frame_ctrl_t *fctrl,\n                                        const uint8_t fport,\n                                        const void *fbuffer,\n                                        uint16_t fbuffer_size)\n{\n    uint16_t i;\n    uint8_t pkt_header_len = 0;\n    uint32_t mic = 0;\n    const void *payload = fbuffer;\n    uint8_t frame_port = fport;\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    _params.tx_buffer_len = 0;\n\n    _params.is_node_ack_requested = false;\n\n    if (fbuffer == NULL) {\n        fbuffer_size = 0;\n    }\n\n    _params.tx_buffer_len = fbuffer_size;\n\n    _params.tx_buffer[pkt_header_len++] = machdr->value;\n\n    switch (machdr->bits.mtype) {\n\n        case FRAME_TYPE_JOIN_REQ:\n\n            _params.tx_buffer_len = pkt_header_len;\n            memcpy_convert_endianess(_params.tx_buffer + _params.tx_buffer_len,\n                                     _params.keys.app_eui, 8);\n            _params.tx_buffer_len += 8;\n            memcpy_convert_endianess(_params.tx_buffer + _params.tx_buffer_len,\n                                     _params.keys.dev_eui, 8);\n            _params.tx_buffer_len += 8;\n\n            _params.dev_nonce = _lora_phy.get_radio_rng();\n\n            _params.tx_buffer[_params.tx_buffer_len++] = _params.dev_nonce & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len++] = (_params.dev_nonce >> 8) & 0xFF;\n\n            if (0 != _lora_crypto.compute_join_frame_mic(_params.tx_buffer,\n                                                         _params.tx_buffer_len & 0xFF,\n                                                         _params.keys.app_key,\n                                                         APPKEY_KEY_LENGTH,\n                                                         &mic)) {\n                return LORAWAN_STATUS_CRYPTO_FAIL;\n            }\n\n            _params.tx_buffer[_params.tx_buffer_len++] = mic & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len++] = (mic >> 8) & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len++] = (mic >> 16) & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len++] = (mic >> 24) & 0xFF;\n\n            break;\n        case FRAME_TYPE_DATA_CONFIRMED_UP:\n            _params.is_node_ack_requested = true;\n        //Intentional fallthrough\n        case FRAME_TYPE_DATA_UNCONFIRMED_UP: {\n            if (!_is_nwk_joined) {\n                return LORAWAN_STATUS_NO_NETWORK_JOINED;\n            }\n\n            if (_params.sys_params.adr_on) {\n                if (_lora_phy.get_next_ADR(true,\n                                           _params.sys_params.channel_data_rate,\n                                           _params.sys_params.channel_tx_power,\n                                           _params.adr_ack_counter)) {\n                    fctrl->bits.adr_ack_req = 1;\n                }\n            }\n\n            if (_params.is_srv_ack_requested == true) {\n                tr_debug(\"Acking to NS\");\n                fctrl->bits.ack = 1;\n            }\n\n            _params.tx_buffer[pkt_header_len++] = (_params.dev_addr) & 0xFF;\n            _params.tx_buffer[pkt_header_len++] = (_params.dev_addr >> 8) & 0xFF;\n            _params.tx_buffer[pkt_header_len++] = (_params.dev_addr >> 16) & 0xFF;\n            _params.tx_buffer[pkt_header_len++] = (_params.dev_addr >> 24) & 0xFF;\n\n            _params.tx_buffer[pkt_header_len++] = fctrl->value;\n\n            _params.tx_buffer[pkt_header_len++] = _params.ul_frame_counter & 0xFF;\n            _params.tx_buffer[pkt_header_len++] = (_params.ul_frame_counter >> 8)\n                    & 0xFF;\n\n            _mac_commands.copy_repeat_commands_to_buffer();\n\n            const uint8_t mac_commands_len = _mac_commands.get_mac_cmd_length();\n\n            if ((payload != NULL) && (_params.tx_buffer_len > 0)) {\n                if (_mac_commands.is_mac_command_in_next_tx() == true) {\n                    if (mac_commands_len <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH) {\n                        fctrl->bits.fopts_len += mac_commands_len;\n\n                        // Update FCtrl field with new value of OptionsLength\n                        _params.tx_buffer[0x05] = fctrl->value;\n\n                        const uint8_t *buffer =\n                                _mac_commands.get_mac_commands_buffer();\n                        for (i = 0; i < mac_commands_len; i++) {\n                            _params.tx_buffer[pkt_header_len++] = buffer[i];\n                        }\n                    } else {\n                        _params.tx_buffer_len = mac_commands_len;\n                        payload = _mac_commands.get_mac_commands_buffer();\n                        frame_port = 0;\n                    }\n                }\n            } else {\n                if ((mac_commands_len > 0)\n                        && (_mac_commands.is_mac_command_in_next_tx() == true)) {\n                    _params.tx_buffer_len = mac_commands_len;\n                    payload = _mac_commands.get_mac_commands_buffer();\n                    frame_port = 0;\n                }\n            }\n\n            _mac_commands.parse_mac_commands_to_repeat();\n\n            if ((payload != NULL) && (_params.tx_buffer_len > 0)) {\n                _params.tx_buffer[pkt_header_len++] = frame_port;\n\n                uint8_t *key = _params.keys.app_skey;\n                uint32_t key_length = sizeof(_params.keys.app_skey)*8;\n                if (frame_port == 0) {\n                    _mac_commands.clear_command_buffer();\n                    key = _params.keys.nwk_skey;\n                    key_length = sizeof(_params.keys.nwk_skey)*8;\n                }\n                if (0 != _lora_crypto.encrypt_payload((uint8_t*) payload, _params.tx_buffer_len,\n                                                      key, key_length,\n                                                      _params.dev_addr, UP_LINK,\n                                                      _params.ul_frame_counter,\n                                                      &_params.tx_buffer[pkt_header_len])) {\n                    status = LORAWAN_STATUS_CRYPTO_FAIL;\n                }\n            }\n\n            _params.tx_buffer_len = pkt_header_len + _params.tx_buffer_len;\n\n            if (0 != _lora_crypto.compute_mic(_params.tx_buffer, _params.tx_buffer_len,\n                                              _params.keys.nwk_skey, sizeof(_params.keys.nwk_skey)*8,\n                                              _params.dev_addr,\n                                              UP_LINK, _params.ul_frame_counter, &mic)) {\n                status = LORAWAN_STATUS_CRYPTO_FAIL;\n            }\n\n            _params.tx_buffer[_params.tx_buffer_len + 0] = mic & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len + 1] = (mic >> 8) & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len + 2] = (mic >> 16) & 0xFF;\n            _params.tx_buffer[_params.tx_buffer_len + 3] = (mic >> 24) & 0xFF;\n\n            _params.tx_buffer_len += LORAMAC_MFR_LEN;\n        }\n            break;\n        case FRAME_TYPE_PROPRIETARY:\n            if ((fbuffer != NULL) && (_params.tx_buffer_len > 0)) {\n                memcpy(_params.tx_buffer + pkt_header_len, (uint8_t *) fbuffer,\n                       _params.tx_buffer_len);\n                _params.tx_buffer_len = pkt_header_len + _params.tx_buffer_len;\n            }\n            break;\n        default:\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    tr_debug(\"Frame prepared to send at port %u\", frame_port);\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::send_frame_on_channel(uint8_t channel)\n{\n    tx_config_params_t tx_config;\n    int8_t tx_power = 0;\n\n    tx_config.channel = channel;\n    tx_config.datarate = _params.sys_params.channel_data_rate;\n    tx_config.tx_power = _params.sys_params.channel_tx_power;\n    tx_config.max_eirp = _params.sys_params.max_eirp;\n    tx_config.antenna_gain = _params.sys_params.antenna_gain;\n    tx_config.pkt_len = _params.tx_buffer_len;\n\n    _lora_phy.tx_config(&tx_config, &tx_power, &_params.timers.tx_toa);\n\n    _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n\n    _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n    _mcps_confirmation.data_rate = _params.sys_params.channel_data_rate;\n    _mcps_confirmation.tx_power = tx_power;\n    _mcps_confirmation.channel = channel;\n\n    _mcps_confirmation.tx_toa = _params.timers.tx_toa;\n    _mlme_confirmation.tx_toa = _params.timers.tx_toa;\n\n    if (!_is_nwk_joined) {\n        _params.join_request_trial_counter++;\n    }\n\n    _lora_phy.handle_send(_params.tx_buffer, _params.tx_buffer_len);\n\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaMac::reset_mcps_confirmation()\n{\n    memset((uint8_t *) &_mcps_confirmation, 0, sizeof(_mcps_confirmation));\n    _mcps_confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n}\n\nvoid LoRaMac::reset_mlme_confirmation()\n{\n    memset((uint8_t *) &_mlme_confirmation, 0, sizeof(_mlme_confirmation));\n    _mlme_confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n}\n\nvoid LoRaMac::reset_mcps_indication()\n{\n    memset((uint8_t *) &_mcps_indication, 0, sizeof(_mcps_indication));\n    _mcps_indication.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n}\n\nvoid LoRaMac::set_tx_continuous_wave(uint8_t channel, int8_t datarate, int8_t tx_power,\n                                     float max_eirp, float antenna_gain, uint16_t timeout)\n{\n    cw_mode_params_t continuous_wave;\n\n    continuous_wave.channel = channel;\n    continuous_wave.datarate = datarate;\n    continuous_wave.tx_power = tx_power;\n    continuous_wave.max_eirp = max_eirp;\n    continuous_wave.antenna_gain = antenna_gain;\n    continuous_wave.timeout = timeout;\n\n    _lora_phy.set_tx_cont_mode(&continuous_wave);\n}\n\nlorawan_status_t LoRaMac::initialize(EventQueue *queue)\n{\n    _lora_time.activate_timer_subsystem(queue);\n\n    _ev_queue = queue;\n\n    _channel_plan.activate_channelplan_subsystem(&_lora_phy);\n\n    _device_class = CLASS_A;\n\n    _params.join_request_trial_counter = 0;\n    _params.max_join_request_trials = 1;\n    _params.is_repeater_supported = false;\n\n    _params.timers.aggregated_last_tx_time = 0;\n    _params.timers.aggregated_timeoff = 0;\n\n    _lora_phy.reset_to_default_values(&_params, true);\n\n    _params.sys_params.max_sys_rx_error = 10;\n    _params.sys_params.min_rx_symb = 6;\n    _params.sys_params.retry_num = 1;\n\n    reset_mac_parameters();\n\n    srand(_lora_phy.get_radio_rng());\n\n    _params.is_nwk_public = MBED_CONF_LORA_PUBLIC_NETWORK;\n    _lora_phy.setup_public_network_mode(_params.is_nwk_public);\n    _lora_phy.put_radio_to_sleep();\n\n    _lora_time.init(_params.timers.backoff_timer,\n                    mbed::callback(this, &LoRaMac::on_backoff_timer_expiry));\n    _lora_time.init(_params.timers.rx_window1_timer,\n                    mbed::callback(this, &LoRaMac::open_rx1_window));\n    _lora_time.init(_params.timers.rx_window2_timer,\n                    mbed::callback(this, &LoRaMac::open_rx2_window));\n    _lora_time.init(_params.timers.ack_timeout_timer,\n                    mbed::callback(this, &LoRaMac::on_ack_timeout_timer_event));\n\n    _params.timers.mac_init_time = _lora_time.get_current_time();\n\n    _params.sys_params.adr_on = MBED_CONF_LORA_ADR_ON;\n\n    _params.is_nwk_public = MBED_CONF_LORA_PUBLIC_NETWORK;\n    _lora_phy.setup_public_network_mode(MBED_CONF_LORA_PUBLIC_NETWORK);\n\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaMac::disconnect()\n{\n    _lora_time.stop(_params.timers.backoff_timer);\n    _lora_time.stop(_params.timers.rx_window1_timer);\n    _lora_time.stop(_params.timers.rx_window2_timer);\n    _lora_time.stop(_params.timers.ack_timeout_timer);\n\n    _lora_phy.put_radio_to_sleep();\n\n    _is_nwk_joined = false;\n    _params.is_ack_retry_timeout_expired = false;\n    _params.is_rx_window_enabled = true;\n    _params.is_node_ack_requested = false;\n    _params.is_srv_ack_requested = false;\n\n    _mac_commands.clear_command_buffer();\n    _mac_commands.clear_repeat_buffer();\n    _mac_commands.clear_mac_commands_in_next_tx();\n\n    reset_mcps_confirmation();\n    reset_mlme_confirmation();\n    reset_mcps_indication();\n}\n\nuint8_t LoRaMac::get_max_possible_tx_size(uint8_t size)\n{\n    uint8_t max_possible_payload_size = 0;\n    uint8_t current_payload_size = 0;\n    uint8_t fopt_len = _mac_commands.get_mac_cmd_length()\n            + _mac_commands.get_repeat_commands_length();\n\n    if (_params.sys_params.adr_on) {\n        _lora_phy.get_next_ADR(false, _params.sys_params.channel_data_rate,\n                               _params.sys_params.channel_tx_power,\n                               _params.adr_ack_counter);\n    }\n\n    current_payload_size = _lora_phy.get_max_payload(_params.sys_params.channel_data_rate, _params.is_repeater_supported);\n\n    if (current_payload_size >= fopt_len) {\n        max_possible_payload_size = current_payload_size - fopt_len;\n    } else {\n        max_possible_payload_size = current_payload_size;\n        fopt_len = 0;\n        _mac_commands.clear_command_buffer();\n        _mac_commands.clear_repeat_buffer();\n    }\n\n    if (validate_payload_length(size, _params.sys_params.channel_data_rate,\n                                fopt_len) == false) {\n        return max_possible_payload_size;\n    }\n    return current_payload_size;\n}\n\nbool LoRaMac::nwk_joined()\n{\n    return _is_nwk_joined;\n}\n\nvoid LoRaMac::set_nwk_joined(bool joined)\n{\n    _is_nwk_joined = joined;\n}\n\nlorawan_status_t LoRaMac::add_channel_plan(const lorawan_channelplan_t &plan)\n{\n    if (tx_ongoing()) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    return _channel_plan.set_plan(plan);\n}\n\nlorawan_status_t LoRaMac::remove_channel_plan()\n{\n    if (tx_ongoing()) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    return _channel_plan.remove_plan();\n}\n\nlorawan_status_t LoRaMac::get_channel_plan(lorawan_channelplan_t &plan)\n{\n    return _channel_plan.get_plan(plan, _lora_phy.get_phy_channels());\n}\n\nlorawan_status_t LoRaMac::remove_single_channel(uint8_t id)\n{\n    if (tx_ongoing()) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    return _channel_plan.remove_single_channel(id);\n}\n\nlorawan_status_t LoRaMac::multicast_channel_link(multicast_params_t *channel_param)\n{\n    if (channel_param == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n    if (tx_ongoing()) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    channel_param->dl_frame_counter = 0;\n\n    if (_params.multicast_channels == NULL) {\n        _params.multicast_channels = channel_param;\n    } else {\n        multicast_params_t *cur = _params.multicast_channels;\n        while (cur->next != NULL) {\n            cur = cur->next;\n        }\n        cur->next = channel_param;\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMac::multicast_channel_unlink(multicast_params_t *channel_param)\n{\n    if (channel_param == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    if (tx_ongoing()) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    if (_params.multicast_channels != NULL) {\n        if (_params.multicast_channels == channel_param) {\n            _params.multicast_channels = channel_param->next;\n        } else {\n            multicast_params_t *cur = _params.multicast_channels;\n\n            while (cur->next && cur->next != channel_param) {\n                cur = cur->next;\n            }\n\n            if (cur->next) {\n                cur->next = channel_param->next;\n            }\n        }\n        channel_param->next = NULL;\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaMac::bind_radio_driver(LoRaRadio &radio)\n{\n    _lora_phy.set_radio_instance(radio);\n}\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n/***************************************************************************\n * Compliance testing                                                      *\n **************************************************************************/\n\n\nlorawan_status_t LoRaMac::mlme_request(loramac_mlme_req_t *mlmeRequest)\n{\n    if (LORAMAC_IDLE != _params.mac_state) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    reset_mlme_confirmation();\n\n    _mlme_confirmation.req_type = mlmeRequest->type;\n    _params.flags.bits.mlme_req = 1;\n\n    lorawan_status_t status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n\n    if (MLME_TXCW == mlmeRequest->type) {\n        set_tx_continuous_wave(_params.channel, _params.sys_params.channel_data_rate, _params.sys_params.channel_tx_power,\n                _params.sys_params.max_eirp, _params.sys_params.antenna_gain, mlmeRequest->cw_tx_mode.timeout);\n        _lora_time.start(_params.timers.mac_state_check_timer,\n                MAC_STATE_CHECK_TIMEOUT);\n\n        _params.mac_state |= LORAMAC_TX_RUNNING;\n        status = LORAWAN_STATUS_OK;\n    } else if (MLME_TXCW_1 == mlmeRequest->type) {\n        set_tx_continuous_wave(0, 0, mlmeRequest->cw_tx_mode.power, 0, 0, mlmeRequest->cw_tx_mode.timeout);\n        _lora_time.start(_params.timers.mac_state_check_timer,\n                MAC_STATE_CHECK_TIMEOUT);\n\n        _params.mac_state |= LORAMAC_TX_RUNNING;\n        status = LORAWAN_STATUS_OK;\n    }\n\n    if (status != LORAWAN_STATUS_OK) {\n        _params.is_node_ack_requested = false;\n        _params.flags.bits.mlme_req = 0;\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::test_request( loramac_compliance_test_req_t *mcpsRequest )\n{\n    if (_params.mac_state != LORAMAC_IDLE) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    loramac_mhdr_t machdr;\n    int8_t datarate = mcpsRequest->data_rate;\n    // TODO: The comment is different than the code???\n    // Apply the minimum possible datarate.\n    // Some regions have limitations for the minimum datarate.\n    datarate = MAX(datarate, (int8_t)_lora_phy.get_minimum_tx_datarate());\n\n    machdr.value = 0;\n\n    reset_mcps_confirmation();\n\n    _params.ack_timeout_retry_counter = 1;\n    _params.max_ack_timeout_retries = 1;\n\n    switch (mcpsRequest->type) {\n        case MCPS_UNCONFIRMED: {\n            machdr.bits.mtype = FRAME_TYPE_DATA_UNCONFIRMED_UP;\n            break;\n        }\n        case MCPS_CONFIRMED: {\n            machdr.bits.mtype = FRAME_TYPE_DATA_CONFIRMED_UP;\n            _params.max_ack_timeout_retries = mcpsRequest->nb_trials;\n            break;\n        }\n        case MCPS_PROPRIETARY: {\n            machdr.bits.mtype = FRAME_TYPE_PROPRIETARY;\n            break;\n        }\n        default:\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n//    Filter fPorts\n//    TODO: Does not work with PROPRIETARY messages\n//    if( IsFPortAllowed( mcpsRequest->fport ) == false ) {\n//        return LORAWAN_STATUS_PARAMETER_INVALID;\n//    }\n\n    if (_params.sys_params.adr_on == false) {\n        if (_lora_phy.verify_tx_datarate(datarate, false) == true) {\n            _params.sys_params.channel_data_rate = datarate;\n        } else {\n            return LORAWAN_STATUS_PARAMETER_INVALID;\n        }\n    }\n\n    lorawan_status_t status = send(&machdr, mcpsRequest->fport, mcpsRequest->f_buffer,\n            mcpsRequest->f_buffer_size);\n    if (status == LORAWAN_STATUS_OK) {\n        _mcps_confirmation.req_type = mcpsRequest->type;\n        _params.flags.bits.mcps_req = 1;\n    } else {\n        _params.is_node_ack_requested = false;\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::LoRaMacSetTxTimer( uint32_t TxDutyCycleTime )\n{\n    _lora_time.start(tx_next_packet_timer, TxDutyCycleTime);\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMac::LoRaMacStopTxTimer( )\n{\n    _lora_time.stop(tx_next_packet_timer);\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaMac::LoRaMacTestRxWindowsOn( bool enable )\n{\n    _params.is_rx_window_enabled = enable;\n}\n\nvoid LoRaMac::LoRaMacTestSetMic( uint16_t txPacketCounter )\n{\n    _params.ul_frame_counter = txPacketCounter;\n    _params.is_ul_frame_counter_fixed = true;\n}\n\nvoid LoRaMac::LoRaMacTestSetDutyCycleOn( bool enable )\n{\n    if(_lora_phy.verify_duty_cycle(enable) == true)\n    {\n        _params.is_dutycycle_on = enable;\n    }\n}\n\nvoid LoRaMac::LoRaMacTestSetChannel( uint8_t channel )\n{\n    _params.channel = channel;\n}\n#endif\n","/**\n * @file lorawan_data_structures.h\n *\n * @brief Contains common data structures used by Mbed-OS\n *        LoRaWAN mplementation.\n *\n *  \\code\n *   ______                              _\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *   (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n * Description: LoRa PHY layer\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n */\n\n#ifndef LORAWAN_SYSTEM_LORAWAN_DATA_STRUCTURES_H_\n#define LORAWAN_SYSTEM_LORAWAN_DATA_STRUCTURES_H_\n\n#include <inttypes.h>\n#include \"lorawan_types.h\"\n\n#ifdef TARGET_SIMULATOR\n#include \"device.h\"\n#endif\n\n/*!\n * \\brief Timer time variable definition\n */\n#ifndef lorawan_time_t\ntypedef uint32_t lorawan_time_t;\n#endif\n\n// Radio wake-up time from sleep - unit ms.\n#define RADIO_WAKEUP_TIME                           1\n\n/*!\n * Sets the length of the LoRaMAC footer field.\n * Mainly indicates the MIC field length.\n */\n#define LORAMAC_MFR_LEN                             4\n\n/*!\n * The FRMPayload overhead to be used when setting the `Radio.SetMaxPayloadLength`\n * in the `RxWindowSetup` function.\n * The maximum PHYPayload = MaxPayloadOfDatarate/MaxPayloadOfDatarateRepeater + LORA_MAC_FRMPAYLOAD_OVERHEAD\n */\n#define LORA_MAC_FRMPAYLOAD_OVERHEAD                13 // MHDR(1) + FHDR(7) + Port(1) + MIC(4)\n\n/**\n * LoRaMac maximum number of channels\n */\n#define LORA_MAX_NB_CHANNELS                        16\n\n/**\n * Maximum PHY layer payload size for reception.\n */\n#define LORAMAC_PHY_MAXPAYLOAD                      255\n\n/**\n *\n * Default user application maximum data size for transmission\n */\n// reject if user tries to set more than MTU\n#if MBED_CONF_LORA_TX_MAX_SIZE > 255\n    #warning \"Cannot set TX Max size more than MTU=255\"\n    #define MBED_CONF_LORA_TX_MAX_SIZE              255\n#endif\n\n/*!\n * LoRaMAC band parameters definition.\n */\ntypedef struct {\n    /*!\n     * The duty cycle.\n     */\n    uint16_t duty_cycle;\n    /*!\n     * The maximum TX power.\n     */\n    int8_t max_tx_pwr;\n    /*!\n     * The timestamp of the last Join Request TX frame.\n     */\n    lorawan_time_t last_join_tx_time;\n    /*!\n     * The timestamp of the last TX frame.\n     */\n    lorawan_time_t last_tx_time;\n    /*!\n     * The device off time.\n     */\n    lorawan_time_t off_time;\n    /*!\n     * Lower band boundry\n     */\n    uint32_t lower_band_freq;\n    /*!\n     * Higher band boundry\n     */\n    uint32_t higher_band_freq;\n} band_t;\n\n/*!\n * LoRaMAC receive window 2 channel parameters.\n */\ntypedef struct {\n    /*!\n     * The frequency in Hz.\n     */\n    uint32_t frequency;\n    /*!\n     * The data rate.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * The allowed ranges are region-specific. Please refer to \\ref DR_0 to \\ref DR_15 for details.\n     */\n    uint8_t  datarate;\n} rx2_channel_params;\n\n/*!\n * LoRaMAC receive window enumeration\n */\ntypedef enum {\n    /*!\n     * LoRaMAC receive window 1\n     */\n    RX_SLOT_WIN_1,\n    /*!\n     * LoRaMAC receive window 2\n     */\n    RX_SLOT_WIN_2,\n    /*!\n     * LoRaMAC receive window 2 for class c - continuous listening\n     */\n    RX_SLOT_WIN_CLASS_C,\n    /*!\n     * LoRaMAC class b ping slot window\n     */\n    RX_SLOT_WIN_PING_SLOT\n} rx_slot_t;\n\n/*!\n * The global MAC layer parameters.\n */\ntypedef struct {\n    /*!\n     * The TX power in channels.\n     */\n    int8_t channel_tx_power;\n    /*!\n     * The data rate in channels.\n     */\n    int8_t channel_data_rate;\n    /*!\n     * The system overall timing error in milliseconds.\n     * [-SystemMaxRxError : +SystemMaxRxError]\n     * Default: +/-10 ms\n     */\n    uint32_t max_sys_rx_error;\n    /*!\n     * The minimum number of symbols required to detect an RX frame.\n     * Default: 6 symbols\n     */\n    uint8_t min_rx_symb;\n    /*!\n     * LoRaMac maximum time a reception window stays open.\n     */\n    uint32_t max_rx_win_time;\n    /*!\n     * Receive delay 1.\n     */\n    uint32_t recv_delay1;\n    /*!\n     * Receive delay 2.\n     */\n    uint32_t recv_delay2;\n    /*!\n     * Join accept delay 1.\n     */\n    uint32_t join_accept_delay1;\n    /*!\n     * Join accept delay 1.\n     */\n    uint32_t join_accept_delay2;\n    /*!\n     * The number of uplink messages repetitions (confirmed messages only).\n     */\n    uint8_t retry_num;\n    /*!\n     * The datarate offset between uplink and downlink on first window.\n     */\n    uint8_t rx1_dr_offset;\n    /*!\n     * LoRaMAC 2nd reception window settings.\n     */\n    rx2_channel_params rx2_channel;\n    /*!\n     * The uplink dwell time configuration. 0: No limit, 1: 400ms\n     */\n    uint8_t uplink_dwell_time;\n    /*!\n     * The downlink dwell time configuration. 0: No limit, 1: 400ms\n     */\n    uint8_t downlink_dwell_time;\n    /*!\n     * The maximum possible EIRP.\n     */\n    float max_eirp;\n    /*!\n     * The antenna gain of the node.\n     */\n    float antenna_gain;\n\n    /*!\n     * Maximum duty cycle\n     * \\remark Possibility to shutdown the device.\n     */\n    uint8_t max_duty_cycle;\n    /*!\n     * Aggregated duty cycle management\n     */\n    uint16_t aggregated_duty_cycle;\n\n    /*!\n     * LoRaMac ADR control status\n     */\n    bool adr_on;\n} lora_mac_system_params_t;\n\n/*!\n * LoRaMAC multicast channel parameter.\n */\ntypedef struct multicast_params_s {\n    /*!\n     * Address.\n     */\n    uint32_t address;\n    /*!\n     * Network session key.\n     */\n    uint8_t nwk_skey[16];\n    /*!\n     * Application session key.\n     */\n    uint8_t app_skey[16];\n    /*!\n     * Downlink counter.\n     */\n    uint32_t dl_frame_counter;\n    /*!\n     * A reference pointer to the next multicast channel parameters in the list.\n     */\n    struct multicast_params_s *next;\n} multicast_params_t;\n\n/*!\n * LoRaMAC frame types.\n *\n * LoRaWAN Specification V1.0.2, chapter 4.2.1, table 1.\n */\ntypedef enum {\n    /*!\n     * LoRaMAC join request frame.\n     */\n    FRAME_TYPE_JOIN_REQ              = 0x00,\n    /*!\n     * LoRaMAC join accept frame.\n     */\n    FRAME_TYPE_JOIN_ACCEPT           = 0x01,\n    /*!\n     * LoRaMAC unconfirmed uplink frame.\n     */\n    FRAME_TYPE_DATA_UNCONFIRMED_UP   = 0x02,\n    /*!\n     * LoRaMAC unconfirmed downlink frame.\n     */\n    FRAME_TYPE_DATA_UNCONFIRMED_DOWN = 0x03,\n    /*!\n     * LoRaMAC confirmed uplink frame.\n     */\n    FRAME_TYPE_DATA_CONFIRMED_UP     = 0x04,\n    /*!\n     * LoRaMAC confirmed downlink frame.\n     */\n    FRAME_TYPE_DATA_CONFIRMED_DOWN   = 0x05,\n    /*!\n     * LoRaMAC RFU frame.\n     */\n    FRAME_TYPE_RFU                   = 0x06,\n    /*!\n     * LoRaMAC proprietary frame.\n     */\n    FRAME_TYPE_PROPRIETARY           = 0x07,\n} mac_frame_type_t;\n\n/*!\n * LoRaMAC mote MAC commands.\n *\n * LoRaWAN Specification V1.0.2, chapter 5, table 4.\n */\ntypedef enum {\n    /*!\n     * LinkCheckReq\n     */\n    MOTE_MAC_LINK_CHECK_REQ          = 0x02,\n    /*!\n     * LinkADRAns\n     */\n    MOTE_MAC_LINK_ADR_ANS            = 0x03,\n    /*!\n     * DutyCycleAns\n     */\n    MOTE_MAC_DUTY_CYCLE_ANS          = 0x04,\n    /*!\n     * RXParamSetupAns\n     */\n    MOTE_MAC_RX_PARAM_SETUP_ANS      = 0x05,\n    /*!\n     * DevStatusAns\n     */\n    MOTE_MAC_DEV_STATUS_ANS          = 0x06,\n    /*!\n     * NewChannelAns\n     */\n    MOTE_MAC_NEW_CHANNEL_ANS         = 0x07,\n    /*!\n     * RXTimingSetupAns\n     */\n    MOTE_MAC_RX_TIMING_SETUP_ANS     = 0x08,\n    /*!\n     * TXParamSetupAns\n     */\n    MOTE_MAC_TX_PARAM_SETUP_ANS      = 0x09,\n    /*!\n     * DlChannelAns\n     */\n    MOTE_MAC_DL_CHANNEL_ANS          = 0x0A\n} mote_mac_cmds_t;\n\n/*!\n * LoRaMAC server MAC commands.\n *\n * LoRaWAN Specification V1.0.2 chapter 5, table 4.\n */\ntypedef enum {\n    /*!\n     * LinkCheckAns\n     */\n    SRV_MAC_LINK_CHECK_ANS           = 0x02,\n    /*!\n     * LinkADRReq\n     */\n    SRV_MAC_LINK_ADR_REQ             = 0x03,\n    /*!\n     * DutyCycleReq\n     */\n    SRV_MAC_DUTY_CYCLE_REQ           = 0x04,\n    /*!\n     * RXParamSetupReq\n     */\n    SRV_MAC_RX_PARAM_SETUP_REQ       = 0x05,\n    /*!\n     * DevStatusReq\n     */\n    SRV_MAC_DEV_STATUS_REQ           = 0x06,\n    /*!\n     * NewChannelReq\n     */\n    SRV_MAC_NEW_CHANNEL_REQ          = 0x07,\n    /*!\n     * RXTimingSetupReq\n     */\n    SRV_MAC_RX_TIMING_SETUP_REQ      = 0x08,\n    /*!\n     * NewChannelReq\n     */\n    SRV_MAC_TX_PARAM_SETUP_REQ       = 0x09,\n    /*!\n     * DlChannelReq\n     */\n    SRV_MAC_DL_CHANNEL_REQ           = 0x0A,\n} server_mac_cmds_t;\n\n/*!\n * LoRaMAC battery level indicator.\n */\ntypedef enum {\n    /*!\n     * An external power source.\n     */\n    BAT_LEVEL_EXT_SRC                = 0x00,\n    /*!\n     * Battery level empty.\n     */\n    BAT_LEVEL_EMPTY                  = 0x01,\n    /*!\n     * Battery level full.\n     */\n    BAT_LEVEL_FULL                   = 0xFE,\n    /*!\n     * Battery level - no measurement available.\n     */\n    BAT_LEVEL_NO_MEASURE             = 0xFF,\n} device_battery_level_t;\n\n/*!\n * LoRaMAC header field definition (MHDR field).\n *\n * LoRaWAN Specification V1.0.2, chapter 4.2.\n */\ntypedef union {\n    /*!\n     * Byte-access to the bits.\n     */\n    uint8_t value;\n    /*!\n     * The structure containing single access to header bits.\n     */\n    struct hdr_bits_s {\n        /*!\n         * Major version.\n         */\n        uint8_t major : 2;\n        /*!\n         * RFU\n         */\n        uint8_t RFU : 3;\n        /*!\n         * Message type\n         */\n        uint8_t mtype : 3;\n    } bits;\n} loramac_mhdr_t;\n\n/*!\n * LoRaMAC frame control field definition (FCtrl).\n *\n * LoRaWAN Specification V1.0.2, chapter 4.3.1.\n */\ntypedef union {\n    /*!\n     * Byte-access to the bits.\n     */\n    uint8_t value;\n    /*!\n     * The structure containing single access to bits.\n     */\n    struct ctrl_bits_s {\n        /*!\n         * Frame options length.\n         */\n        uint8_t fopts_len : 4;\n        /*!\n         * Frame pending bit.\n         */\n        uint8_t fpending : 1;\n        /*!\n         * Message acknowledge bit.\n         */\n        uint8_t ack : 1;\n        /*!\n         * ADR acknowledgment request bit.\n         */\n        uint8_t adr_ack_req : 1;\n        /*!\n         * ADR control in the frame header.\n         */\n        uint8_t adr : 1;\n    } bits;\n} loramac_frame_ctrl_t;\n\n/*!\n * The enumeration containing the status of the operation of a MAC service.\n */\ntypedef enum {\n    /*!\n     * Service performed successfully.\n     */\n    LORAMAC_EVENT_INFO_STATUS_OK = 0,\n    /*!\n     * An error occurred during the execution of the service.\n     */\n    LORAMAC_EVENT_INFO_STATUS_ERROR,\n    /*!\n     * A TX timeout occurred.\n     */\n    LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT,\n    /*!\n     * An RX timeout occurred on receive window 1.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT,\n    /*!\n     * An RX timeout occurred on receive window 2.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT,\n    /*!\n     * An RX error occurred on receive window 1.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX1_ERROR,\n    /*!\n     * An RX error occurred on receive window 2.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX2_ERROR,\n    /*!\n     * An error occurred in the join procedure.\n     */\n    LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL,\n    /*!\n     * A frame with an invalid downlink counter was received. The\n     * downlink counter of the frame was equal to the local copy\n     * of the downlink counter of the node.\n     */\n    LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED,\n    /*!\n     * The MAC could not retransmit a frame since the MAC decreased the datarate. The\n     * payload size is not applicable for the datarate.\n     */\n    LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR,\n    /*!\n     * The node has lost MAX_FCNT_GAP or more frames.\n     */\n    LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOST,\n    /*!\n     * An address error occurred.\n     */\n    LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL,\n    /*!\n     * Message integrity check failure.\n     */\n    LORAMAC_EVENT_INFO_STATUS_MIC_FAIL,\n    /*!\n     * Crypto methods failure\n     */\n    LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL,\n} loramac_event_info_status_t;\n\n/*!\n *\n * \\brief   LoRaMAC data services\n *\n * \\details The following table list the primitives supported by a\n *          specific MAC data service:\n *\n * Name                  | Request | Indication | Response | Confirm\n * --------------------- | :-----: | :--------: | :------: | :-----:\n * \\ref MCPS_UNCONFIRMED | YES     | YES        | NO       | YES\n * \\ref MCPS_CONFIRMED   | YES     | YES        | NO       | YES\n * \\ref MCPS_MULTICAST   | NO      | YES        | NO       | NO\n * \\ref MCPS_PROPRIETARY | YES     | YES        | NO       | YES\n *\n */\ntypedef enum {\n    /*!\n     * Unconfirmed LoRaMAC frame.\n     */\n    MCPS_UNCONFIRMED,\n    /*!\n     * Confirmed LoRaMAC frame.\n     */\n    MCPS_CONFIRMED,\n    /*!\n     * Multicast LoRaMAC frame.\n     */\n    MCPS_MULTICAST,\n    /*!\n     * Proprietary frame.\n     */\n    MCPS_PROPRIETARY,\n} mcps_type_t;\n\n/*!\n * LoRaMAC MCPS-Confirm.\n */\ntypedef struct {\n    /*!\n     * Holds the previously performed MCPS-Request type. i.e., the type of\n     * the MCPS request for which this confirmation is being generated\n     */\n    mcps_type_t req_type;\n    /*!\n     * The status of the operation.\n     */\n    loramac_event_info_status_t status;\n    /*!\n     * The uplink datarate.\n     */\n    uint8_t data_rate;\n    /*!\n     * The transmission power.\n     */\n    int8_t tx_power;\n    /*!\n     * Set if an acknowledgement was received.\n     */\n    bool ack_received;\n    /*!\n     * Provides the number of retransmissions.\n     */\n    uint8_t nb_retries;\n    /*!\n     * The transmission time on air of the frame.\n     */\n    lorawan_time_t tx_toa;\n    /*!\n     * The uplink counter value related to the frame.\n     */\n    uint32_t ul_frame_counter;\n    /*!\n     * The uplink channel related to the frame.\n     */\n    uint32_t channel;\n} loramac_mcps_confirm_t;\n\n/*!\n * LoRaMAC MCPS-Indication primitive.\n */\ntypedef struct {\n    /*!\n     * True if an MCPS indication was pending\n     */\n    bool pending;\n    /*!\n     * MCPS-Indication type.\n     */\n    mcps_type_t type;\n    /*!\n     * The status of the operation.\n     */\n    loramac_event_info_status_t status;\n    /*!\n     * Multicast.\n     */\n    uint8_t multicast;\n    /*!\n     * The application port.\n     */\n    uint8_t port;\n    /*!\n     * The downlink datarate.\n     */\n    uint8_t rx_datarate;\n    /*!\n     * Frame pending status.\n     */\n    uint8_t fpending_status;\n    /*!\n     * A pointer to the received data stream.\n     */\n    const uint8_t *buffer;\n    /*!\n     * The size of the received data stream.\n     */\n    uint16_t buffer_size;\n    /*!\n     * Indicates, if data is available.\n     */\n    bool is_data_recvd;\n    /*!\n     * The RSSI of the received packet.\n     */\n    int16_t rssi;\n    /*!\n     * The SNR of the received packet.\n     */\n    uint8_t snr;\n    /*!\n     * The receive window.\n     *\n     * [0: Rx window 1, 1: Rx window 2]\n     */\n    rx_slot_t rx_slot;\n    /*!\n     * Set if an acknowledgement was received.\n     */\n    bool is_ack_recvd;\n    /*!\n     * The downlink counter value for the received frame.\n     */\n    uint32_t dl_frame_counter;\n} loramac_mcps_indication_t;\n\n/*!\n * \\brief LoRaMAC management services.\n *\n * \\details The following table list the primitives supported by a\n *          specific MAC management service:\n *\n * Name                         | Request | Indication | Response | Confirm\n * ---------------------------- | :-----: | :--------: | :------: | :-----:\n * \\ref MLME_JOIN               | YES     | NO         | NO       | YES\n * \\ref MLME_LINK_CHECK         | YES     | NO         | NO       | YES\n * \\ref MLME_TXCW               | YES     | NO         | NO       | YES\n * \\ref MLME_SCHEDULE_UPLINK    | NO      | YES        | NO       | NO\n *\n */\ntypedef enum {\n    /*!\n     * Initiates the Over-the-Air activation.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.\n     */\n    MLME_JOIN,\n    /*!\n     * LinkCheckReq - Connectivity validation.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 5, table 4.\n     */\n    MLME_LINK_CHECK,\n    /*!\n     * Sets TX continuous wave mode.\n     *\n     * LoRaWAN end-device certification.\n     */\n    MLME_TXCW,\n    /*!\n     * Sets TX continuous wave mode (new LoRa-Alliance CC definition).\n     *\n     * LoRaWAN end-device certification.\n     */\n    MLME_TXCW_1,\n    /*!\n     * Indicates that the application shall perform an uplink as\n     * soon as possible.\n     */\n    MLME_SCHEDULE_UPLINK\n} mlme_type_t;\n\n/*!\n * LoRaMAC MLME-Request for the join service.\n */\ntypedef struct {\n    /*!\n     * A globally unique end-device identifier.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.1.\n     */\n    uint8_t *dev_eui;\n    /*!\n     * An application identifier.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.2\n     */\n    uint8_t *app_eui;\n    /*!\n     * AES-128 application key.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.2.\n     */\n    uint8_t *app_key;\n    /*!\n     * The number of trials for the join request.\n     */\n    uint8_t nb_trials;\n} mlme_join_req_t;\n\n/*!\n * LoRaMAC MLME-Request for TX continuous wave mode.\n */\ntypedef struct {\n    /*!\n     * The time while the radio is kept in continuous wave mode, in seconds.\n     */\n    uint16_t timeout;\n    /*!\n     * The RF frequency to set (only used with the new way).\n     */\n    uint32_t frequency;\n    /*!\n     * The RF output power to set (only used with the new way).\n     */\n    uint8_t power;\n} mlme_cw_tx_mode_t;\n\n\n/*!\n * LoRaMAC MLME-Confirm primitive.\n */\ntypedef struct {\n    /*!\n     * Indicates if a request is pending or not\n     */\n    bool pending;\n    /*!\n     * The previously performed MLME-Request. i.e., the request type\n     * for which the confirmation is being generated\n     */\n    mlme_type_t req_type;\n    /*!\n     * The status of the operation.\n     */\n    loramac_event_info_status_t status;\n    /*!\n     * The transmission time on air of the frame.\n     */\n    lorawan_time_t tx_toa;\n    /*!\n     * The demodulation margin. Contains the link margin [dB] of the last LinkCheckReq\n     * successfully received.\n     */\n    uint8_t demod_margin;\n    /*!\n     * The number of gateways which received the last LinkCheckReq.\n     */\n    uint8_t nb_gateways;\n    /*!\n     * The number of retransmissions.\n     */\n    uint8_t nb_retries;\n} loramac_mlme_confirm_t;\n\n/*!\n * LoRaMAC MLME-Indication primitive\n */\ntypedef struct {\n    /*!\n     * MLME-Indication type\n     */\n    mlme_type_t indication_type;\n    bool pending;\n} loramac_mlme_indication_t;\n\n/**\n * End-device states.\n */\ntypedef enum device_states {\n    DEVICE_STATE_NOT_INITIALIZED,\n    DEVICE_STATE_JOINING,\n    DEVICE_STATE_IDLE,\n    DEVICE_STATE_CONNECTING,\n    DEVICE_STATE_AWAITING_JOIN_ACCEPT,\n    DEVICE_STATE_RECEIVING,\n    DEVICE_STATE_CONNECTED,\n    DEVICE_STATE_SCHEDULING,\n    DEVICE_STATE_SENDING,\n    DEVICE_STATE_AWAITING_ACK,\n    DEVICE_STATE_STATUS_CHECK,\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    DEVICE_STATE_COMPLIANCE_TEST,\n#endif\n    DEVICE_STATE_SHUTDOWN\n} device_states_t;\n\n/**\n * Stack level TX message structure\n */\ntypedef struct {\n\n    /**\n     * TX Ongoing flag\n     */\n    bool tx_ongoing;\n\n    /**\n     * Application Port Number\n     */\n    uint8_t port;\n\n    /**\n     * Message type\n     */\n    mcps_type_t type;\n\n    /*!\n     * Frame port field. Must be set if the payload is not empty. Use the\n     * application-specific frame port values: [1...223].\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.2.\n     */\n    uint8_t fport;\n\n    /*!\n     * Uplink datarate, if ADR is off.\n     */\n    int8_t data_rate;\n    /*!\n     * The number of trials to transmit the frame, if the LoRaMAC layer did not\n     * receive an acknowledgment. The MAC performs a datarate adaptation\n     * according to the LoRaWAN Specification V1.0.2, chapter 18.4, as in\n     * the following table:\n     *\n     * Transmission nb | Data Rate\n     * ----------------|-----------\n     * 1 (first)       | DR\n     * 2               | DR\n     * 3               | max(DR-1,0)\n     * 4               | max(DR-1,0)\n     * 5               | max(DR-2,0)\n     * 6               | max(DR-2,0)\n     * 7               | max(DR-3,0)\n     * 8               | max(DR-3,0)\n     *\n     * Note that if nb_trials is set to 1 or 2, the MAC will not decrease\n     * the datarate, if the LoRaMAC layer did not receive an acknowledgment.\n     */\n    uint8_t nb_trials;\n\n    /** Payload data\n     *\n     * Base pointer to the buffer\n     */\n    uint8_t f_buffer[MBED_CONF_LORA_TX_MAX_SIZE];\n\n    /** Payload size.\n     *\n     * The size of the frame payload.\n     */\n    uint16_t f_buffer_size;\n\n    /**\n     * Pending data size\n     */\n    uint16_t pending_size;\n\n} loramac_tx_message_t;\n\n/** lora_mac_rx_message_type_t\n *\n * An enum representing a structure for RX messages.\n */\ntypedef enum  {\n    LORAMAC_RX_MLME_CONFIRM = 0,    /**< lora_mac_mlme_confirm_t */\n    LORAMAC_RX_MCPS_CONFIRM,        /**< lora_mac_mcps_confirm_t */\n    LORAMAC_RX_MCPS_INDICATION      /**< lora_mac_mcps_indication_t */\n} rx_msg_type;\n\n/** lora_mac_rx_message_by_type_t union\n *\n * A union representing a structure for RX messages.\n */\ntypedef union {\n    loramac_mlme_confirm_t mlme_confirm;\n    loramac_mcps_confirm_t mcps_confirm;\n    loramac_mcps_indication_t mcps_indication;\n} rx_message_u;\n\n/** loramac_rx_message_t\n *\n * A structure representing a structure for an RX message.\n */\ntypedef struct {\n    bool receive_ready;\n    rx_msg_type type;\n    rx_message_u msg;\n    uint16_t pending_size;\n    uint16_t prev_read_size;\n} loramac_rx_message_t;\n\n/** LoRaWAN session\n *\n * A structure for keeping session details.\n */\ntypedef struct lorawan_session {\n    /**\n     * True if the session is active\n     */\n    bool active;\n\n    /*!\n     * Select the connection type, either LORAWAN_CONNECTION_OTAA\n     * or LORAWAN_CONNECTION_ABP.\n     */\n    uint8_t connect_type;\n\n    /**\n     * LoRaWAN uplink counter\n     */\n    uint32_t uplink_counter;\n    /**\n     * LoRaWAN downlink counter\n     */\n    uint32_t downlink_counter;\n} lorawan_session_t;\n\n/*!\n * The parameter structure for the function for regional rx configuration.\n */\ntypedef struct {\n    /*!\n     * The RX channel.\n     */\n    uint8_t channel;\n    /*!\n     * The RX datarate index.\n     */\n    uint8_t datarate;\n    /*!\n     * The RX bandwidth.\n     */\n    uint8_t bandwidth;\n    /*!\n     * The RX datarate offset.\n     */\n    int8_t dr_offset;\n    /*!\n     * The RX frequency.\n     */\n    uint32_t frequency;\n    /*!\n     * The RX window timeout\n     */\n    uint32_t window_timeout;\n    /*!\n     * The RX window offset\n     */\n    int32_t window_offset;\n    /*!\n     * The downlink dwell time.\n     */\n    uint8_t dl_dwell_time;\n    /*!\n     * Set to true, if a repeater is supported.\n     */\n    bool is_repeater_supported;\n    /*!\n     * Set to true, if RX should be continuous.\n     */\n    bool is_rx_continuous;\n    /*!\n     * Sets the RX window.\n     */\n    rx_slot_t rx_slot;\n} rx_config_params_t;\n\n/*!\n * \\brief Timer object description\n */\ntypedef struct {\n    mbed::Callback<void()> callback;\n    int timer_id;\n} timer_event_t;\n\ntypedef struct {\n    /*!\n     * Device IEEE EUI\n     */\n    uint8_t *dev_eui;\n\n    /*!\n     * Application IEEE EUI\n     */\n    uint8_t *app_eui;\n\n    /*!\n     * AES encryption/decryption cipher application key\n     */\n    uint8_t *app_key;\n\n    /*!\n     * AES encryption/decryption cipher network session key\n     * NOTE! LoRaMac determines the length of the key based on sizeof this variable\n     */\n    uint8_t nwk_skey[16];\n\n    /*!\n     * AES encryption/decryption cipher application session key\n     * NOTE! LoRaMac determines the length of the key based on sizeof this variable\n     */\n    uint8_t app_skey[16];\n\n} loramac_keys;\n\ntypedef struct {\n    /*!\n     * Aggregated duty cycle management\n     */\n    lorawan_time_t aggregated_last_tx_time;\n    lorawan_time_t aggregated_timeoff;\n\n    /*!\n     * Stores the time at LoRaMac initialization.\n     *\n     * \\remark Used for the BACKOFF_DC computation.\n     */\n    lorawan_time_t mac_init_time;\n\n    /*!\n     * Last transmission time on air\n     */\n    lorawan_time_t tx_toa;\n\n    /*!\n     * LoRaMac duty cycle backoff timer\n     */\n    timer_event_t backoff_timer;\n\n    /*!\n     * LoRaMac reception windows timers\n     */\n    timer_event_t rx_window1_timer;\n    timer_event_t rx_window2_timer;\n\n    /*!\n     * Acknowledge timeout timer. Used for packet retransmissions.\n     */\n    timer_event_t ack_timeout_timer;\n\n} lorawan_timers;\n\ntypedef struct {\n\n    /*!\n     * Holds the type of current Receive window slot\n     */\n    rx_slot_t rx_slot;\n\n    /*!\n     * Indicates if the node is connected to a private or public network\n     */\n    bool is_nwk_public;\n\n    /*!\n     * Indicates if the node supports repeaters\n     */\n    bool is_repeater_supported;\n\n    /*!\n     * IsPacketCounterFixed enables the MIC field tests by fixing the\n     * ul_frame_counter value\n     */\n    bool is_ul_frame_counter_fixed;\n\n    /*!\n     * Used for test purposes. Disables the opening of the reception windows.\n     */\n    bool is_rx_window_enabled;\n\n    /*!\n     * Indicates if the MAC layer has already joined a network.\n     */\n    bool is_nwk_joined;\n\n    /*!\n     * If the node has sent a FRAME_TYPE_DATA_CONFIRMED_UP this variable indicates\n     * if the nodes needs to manage the server acknowledgement.\n     */\n    bool is_node_ack_requested;\n\n    /*!\n     * If the server has sent a FRAME_TYPE_DATA_CONFIRMED_DOWN this variable indicates\n     * if the ACK bit must be set for the next transmission\n     */\n    bool is_srv_ack_requested;\n\n    /*!\n     * Enables/Disables duty cycle management (Test only)\n     */\n    bool is_dutycycle_on;\n\n    /*!\n     * Set to true, if the last uplink was a join request\n     */\n    bool is_last_tx_join_request;\n\n    /*!\n     * Indicates if the AckTimeout timer has expired or not\n     */\n    bool is_ack_retry_timeout_expired;\n\n    /*!\n     * Current channel index\n     */\n    uint8_t channel;\n\n    /*!\n     * Current channel index\n     */\n    uint8_t last_channel_idx;\n\n    /*!\n     * Uplink messages repetitions counter\n     */\n    uint8_t ul_nb_rep_counter;\n\n    /*!\n     * TX buffer used for encrypted outgoing frames\n     */\n    uint8_t tx_buffer[LORAMAC_PHY_MAXPAYLOAD];\n\n    /*!\n     * Length of TX buffer\n     */\n    uint16_t tx_buffer_len;\n\n    /*!\n     * Used for storing decrypted RX data.\n     */\n    uint8_t rx_buffer[LORAMAC_PHY_MAXPAYLOAD];\n\n    /*!\n     * Length of the RX buffer\n     */\n    uint8_t rx_buffer_len;\n\n    /*!\n     * Number of trials to get a frame acknowledged\n     */\n    uint8_t max_ack_timeout_retries;\n\n    /*!\n     * Number of trials to get a frame acknowledged\n     */\n    uint8_t ack_timeout_retry_counter;\n\n    /*!\n     * Maximum number of trials for the Join Request\n     */\n    uint8_t max_join_request_trials;\n\n    /*!\n     * Number of trials for the Join Request\n     */\n    uint8_t join_request_trial_counter;\n\n    /*!\n     * Mac keys\n     */\n    loramac_keys keys;\n\n    /*!\n     * Device nonce is a random value extracted by issuing a sequence of RSSI\n     * measurements\n     */\n    uint16_t dev_nonce;\n\n    /*!\n     * Network ID ( 3 bytes )\n     */\n    uint32_t net_id;\n\n    /*!\n     * Mote Address\n     */\n    uint32_t dev_addr;\n\n    /*!\n     * LoRaMAC frame counter. Each time a packet is sent the counter is incremented.\n     * Only the 16 LSB bits are sent\n     */\n    uint32_t ul_frame_counter;\n\n    /*!\n     * LoRaMAC frame counter. Each time a packet is received the counter is incremented.\n     * Only the 16 LSB bits are received\n     */\n    uint32_t dl_frame_counter;\n\n    /*!\n     * Counts the number of missed ADR acknowledgements\n     */\n    uint32_t adr_ack_counter;\n\n    /*!\n     * LoRaMac reception windows delay\n     * \\remark normal frame: RxWindowXDelay = ReceiveDelayX - RADIO_WAKEUP_TIME\n     *         join frame  : RxWindowXDelay = JoinAcceptDelayX - RADIO_WAKEUP_TIME\n     */\n    uint32_t rx_window1_delay;\n    uint32_t rx_window2_delay;\n\n    /*!\n     * Timer objects and stored values\n     */\n    lorawan_timers timers;\n\n    /*!\n     * LoRaMac parameters\n     */\n    lora_mac_system_params_t sys_params;\n\n    /*!\n     * Receive Window configurations for PHY layer\n     */\n    rx_config_params_t rx_window1_config;\n    rx_config_params_t rx_window2_config;\n\n    /*!\n     * Multicast channels linked list\n     */\n    multicast_params_t *multicast_channels;\n\n} loramac_protocol_params;\n\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n\ntypedef struct {\n    /*!\n     * MLME-Request type.\n     */\n    mlme_type_t type;\n\n    mlme_cw_tx_mode_t cw_tx_mode;\n} loramac_mlme_req_t;\n\ntypedef struct {\n    /*!\n     * Compliance test request\n     */\n    mcps_type_t type;\n\n    /*!\n     * Frame port field. Must be set if the payload is not empty. Use the\n     * application-specific frame port values: [1...223].\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.2.\n     */\n    uint8_t fport;\n\n    /*!\n     * Uplink datarate, if ADR is off.\n     */\n    int8_t data_rate;\n    /*!\n     * The number of trials to transmit the frame, if the LoRaMAC layer did not\n     * receive an acknowledgment. The MAC performs a datarate adaptation\n     * according to the LoRaWAN Specification V1.0.2, chapter 18.4, as in\n     * the following table:\n     *\n     * Transmission nb | Data Rate\n     * ----------------|-----------\n     * 1 (first)       | DR\n     * 2               | DR\n     * 3               | max(DR-1,0)\n     * 4               | max(DR-1,0)\n     * 5               | max(DR-2,0)\n     * 6               | max(DR-2,0)\n     * 7               | max(DR-3,0)\n     * 8               | max(DR-3,0)\n     *\n     * Note that if nb_trials is set to 1 or 2, the MAC will not decrease\n     * the datarate, if the LoRaMAC layer did not receive an acknowledgment.\n     */\n    uint8_t nb_trials;\n\n    /** Payload data\n      *\n      * A pointer to the buffer of the frame payload.\n      */\n    uint8_t f_buffer[LORAMAC_PHY_MAXPAYLOAD];\n\n    /** Payload size\n     *\n     * The size of the frame payload.\n     */\n    uint16_t f_buffer_size;\n\n} loramac_compliance_test_req_t;\n\n/**  LoRaWAN compliance tests support data\n *\n */\ntypedef struct compliance_test {\n    /** Is test running\n     *\n     */\n    bool running;\n    /** State of test\n     *\n     */\n    uint8_t state;\n    /** Is TX confirmed\n     *\n     */\n    bool is_tx_confirmed;\n    /** Port used by the application\n     *\n     */\n    uint8_t app_port;\n    /** Maximum size of data used by application\n     *\n     */\n    uint8_t app_data_size;\n    /** Data provided by application\n     *\n     */\n    uint8_t app_data_buffer[MBED_CONF_LORA_TX_MAX_SIZE];\n    /** Downlink counter\n     *\n     */\n    uint16_t downlink_counter;\n    /** Is link check required\n     *\n     */\n    bool link_check;\n    /** Demodulation margin\n     *\n     */\n    uint8_t demod_margin;\n    /** Number of gateways\n     *\n     */\n    uint8_t nb_gateways;\n} compliance_test_t;\n#endif\n\n#endif /* LORAWAN_SYSTEM_LORAWAN_DATA_STRUCTURES_H_ */\n","/**\n * \\file      LoRaMacCommand.h\n *\n * \\brief     LoRa MAC layer implementation\n *\n * \\copyright Revised BSD License, see LICENSE.TXT file include in the project\n *\n * \\code\n *                ______                              _\n *               / _____)             _              | |\n *              ( (____  _____ ____ _| |_ _____  ____| |__\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *               _____) ) ____| | | || |_| ____( (___| | | |\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *              (C)2013 Semtech\n *\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n *              embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n * \\author    Miguel Luis ( Semtech )\n *\n * \\author    Gregory Cristian ( Semtech )\n *\n * \\author    Daniel Jaeckle ( STACKFORCE )\n *\n * \\defgroup  LORAMAC LoRa MAC layer implementation\n *            This module specifies the API implementation of the LoRaMAC layer.\n *            This is a placeholder for a detailed description of the LoRaMac\n *            layer and the supported features.\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n */\n#ifndef __LORAMACCOMMAND_H__\n#define __LORAMACCOMMAND_H__\n\n#include <stdint.h>\n#include \"system/lorawan_data_structures.h\"\n#include \"lorastack/phy/LoRaPHY.h\"\n\n/*!\n * Maximum MAC commands buffer size\n */\n#define LORA_MAC_COMMAND_MAX_LENGTH                 128\n\nclass LoRaMac;\n\nclass LoRaMacCommand {\n\npublic:\n    LoRaMacCommand();\n\n    /**\n     * @brief Clear MAC command buffer.\n     */\n    void clear_command_buffer(void);\n\n    /**\n     * @brief Get the length of MAC commands\n     *\n     * @return status    Length of used MAC buffer (bytes)\n     */\n    uint8_t get_mac_cmd_length() const;\n\n    /**\n     * @brief Get MAC command buffer\n     *\n     * @return    Pointer to MAC command buffer\n     */\n    uint8_t *get_mac_commands_buffer();\n\n    /**\n     * @brief Parses the MAC commands which must be resent.\n     */\n    void parse_mac_commands_to_repeat();\n\n    /**\n     * @brief Clear  MAC command repeat buffer.\n     */\n    void clear_repeat_buffer();\n\n    /**\n     * @brief Copy MAC commands from repeat buffer to actual MAC command buffer.\n     */\n    void copy_repeat_commands_to_buffer();\n\n    /**\n     * @brief Get the length of MAC commands in repeat buffer\n     *\n     * @return status  Length of used MAC Repeat buffer (bytes)\n     */\n    uint8_t get_repeat_commands_length() const;\n\n    /**\n     * @brief Clear MAC commands in next TX.\n     */\n    void clear_mac_commands_in_next_tx();\n\n    /**\n     * @brief Check if MAC command buffer has commands to be sent in next TX\n     *\n     * @return status  True: buffer has MAC commands to be sent, false: no commands in buffer\n     */\n    bool is_mac_command_in_next_tx() const;\n\n    /**\n     * @brief Clear sticky MAC commands.\n     */\n    void clear_sticky_mac_cmd();\n\n    /**\n     * @brief Check if MAC command buffer contains sticky commands\n     *\n     * @return status  True: buffer has sticky MAC commands in it, false: no sticky commands in buffer\n     */\n    bool has_sticky_mac_cmd() const;\n\n    /**\n     * @brief Decodes MAC commands in the fOpts field and in the payload\n     *\n     * @return status  Function status. LORAWAN_STATUS_OK if command successful.\n     */\n    lorawan_status_t process_mac_commands(const uint8_t *payload, uint8_t mac_index,\n                                          uint8_t commands_size, uint8_t snr,\n                                          loramac_mlme_confirm_t& mlme_conf,\n                                          lora_mac_system_params_t& mac_params,\n                                          LoRaPHY& lora_phy);\n\n    /**\n     * @brief Verifies if sticky MAC commands are pending.\n     *\n     * @return [true: sticky MAC commands pending, false: No MAC commands pending]\n     */\n    bool is_sticky_mac_command_pending();\n\n    /**\n     * @brief Adds a new LinkCheckReq MAC command to be sent.\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_link_check_req();\n\n    /**\n     * @brief Set battery level query callback method\n     *        If callback is not set, BAT_LEVEL_NO_MEASURE is returned.\n     */\n    void set_batterylevel_callback(mbed::Callback<uint8_t(void)> battery_level);\n\nprivate:\n    /**\n     * @brief Get the remaining size of the MAC command buffer\n     *\n     * @return      Remaining free space in buffer (bytes).\n     */\n    int32_t cmd_buffer_remaining() const;\n\n    /**\n     * @brief Adds a new LinkAdrAns MAC command to be sent.\n     *\n     * @param [in] status Status bits\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_link_adr_ans(uint8_t status);\n\n    /**\n     * @brief Adds a new DutyCycleAns MAC command to be sent.\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_duty_cycle_ans();\n\n    /**\n     * @brief Adds a new RXParamSetupAns MAC command to be sent.\n     *\n     * @param [in] status Status bits\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_rx_param_setup_ans(uint8_t status);\n\n    /**\n     * @brief Adds a new DevStatusAns MAC command to be sent.\n     *\n     * @param [in] battery  Battery level\n     * @param [in] margin   Demodulation signal-to-noise ratio (dB)\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_dev_status_ans(uint8_t battery, uint8_t margin);\n\n    /**\n     * @brief Adds a new NewChannelAns MAC command to be sent.\n     *\n     * @param [in] status Status bits\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_new_channel_ans(uint8_t status);\n\n    /**\n     * @brief Adds a new RXTimingSetupAns MAC command to be sent.\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_rx_timing_setup_ans();\n\n    /**\n     * @brief Adds a new TXParamSetupAns MAC command to be sent.\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_tx_param_setup_ans();\n\n    /**\n     * @brief Adds a new DlChannelAns MAC command to be sent.\n     *\n     * @param [in] status Status bits\n     *\n     * @return status  Function status: LORAWAN_STATUS_OK: OK,\n     *                                  LORAWAN_STATUS_LENGTH_ERROR: Buffer full\n     */\n    lorawan_status_t add_dl_channel_ans(uint8_t status);\n\nprivate:\n    /**\n     * Indicates if the MAC layer wants to send MAC commands\n     */\n    bool mac_cmd_in_next_tx;\n\n    /**\n      * Indicates if there are any pending sticky MAC commands\n      */\n    bool sticky_mac_cmd;\n\n    /**\n     * Contains the current Mac command buffer index in 'mac_cmd_buffer'\n     */\n    uint8_t mac_cmd_buf_idx;\n\n    /**\n     * Contains the current Mac command buffer index for MAC commands to repeat in\n     * 'mac_cmd_buffer_to_repeat'\n     */\n    uint8_t mac_cmd_buf_idx_to_repeat;\n\n    /**\n     * Buffer containing the MAC layer commands\n     */\n    uint8_t mac_cmd_buffer[LORA_MAC_COMMAND_MAX_LENGTH];\n\n    /**\n     * Buffer containing the MAC layer commands which must be repeated\n     */\n    uint8_t mac_cmd_buffer_to_repeat[LORA_MAC_COMMAND_MAX_LENGTH];\n\n    mbed::Callback<uint8_t(void)> _battery_level_cb;\n};\n\n#endif //__LORAMACCOMMAND_H__\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef EVENT_QUEUE_H\n#define EVENT_QUEUE_H\n\n#include \"equeue/equeue.h\"\n#include \"platform/Callback.h\"\n#include \"platform/NonCopyable.h\"\n#include <cstddef>\n#include <new>\n\nnamespace events {\n/** \\addtogroup events */\n\n/** EVENTS_EVENT_SIZE\n *  Minimum size of an event\n *  This size fits a Callback<void()> at minimum\n */\n#define EVENTS_EVENT_SIZE \\\n    (EQUEUE_EVENT_SIZE - 2*sizeof(void*) + sizeof(mbed::Callback<void()>))\n\n/** EVENTS_QUEUE_SIZE\n *  Default size of buffer for events\n */\n#define EVENTS_QUEUE_SIZE (32*EVENTS_EVENT_SIZE)\n\n// Predeclared classes\ntemplate <typename F>\nclass Event;\n\n\n/** EventQueue\n *\n *  Flexible event queue for dispatching events\n * @ingroup events\n */\nclass EventQueue : private mbed::NonCopyable<EventQueue> {\npublic:\n    /** Create an EventQueue\n     *\n     *  Create an event queue. The event queue either allocates a buffer of\n     *  the specified size with malloc or uses the user provided buffer.\n     *\n     *  @param size     Size of buffer to use for events in bytes\n     *                  (default to EVENTS_QUEUE_SIZE)\n     *  @param buffer   Pointer to buffer to use for events\n     *                  (default to NULL)\n     */\n    EventQueue(unsigned size=EVENTS_QUEUE_SIZE, unsigned char *buffer=NULL);\n\n    /** Destroy an EventQueue\n     */\n    ~EventQueue();\n\n    /** Dispatch events\n     *\n     *  Executes events until the specified milliseconds have passed.\n     *  If ms is negative, the dispatch function will dispatch events\n     *  indefinitely or until break_dispatch is called on this queue.\n     *\n     *  When called with a finite timeout, the dispatch function is guaranteed\n     *  to terminate. When called with a timeout of 0, the dispatch function\n     *  does not wait and is irq safe.\n     *\n     *  @param ms       Time to wait for events in milliseconds, a negative\n     *                  value will dispatch events indefinitely\n     *                  (default to -1)\n     */\n    void dispatch(int ms=-1);\n\n    /** Dispatch events without a timeout\n     *\n     *  This is equivalent to EventQueue::dispatch with no arguments, but \n     *  avoids overload ambiguities when passed as a callback.\n     *\n     *  @see EventQueue::dispatch\n     */\n    void dispatch_forever() { dispatch(); }\n\n    /** Break out of a running event loop\n     *\n     *  Forces the specified event queue's dispatch loop to terminate. Pending\n     *  events may finish executing, but no new events will be executed.\n     */\n    void break_dispatch();\n\n    /** Millisecond counter\n     *\n     *  Returns the underlying tick of the event queue represented as the \n     *  number of milliseconds that have passed since an arbitrary point in\n     *  time. Intentionally overflows to 0 after 2^32-1.\n     *\n     *  @return         The underlying tick of the event queue in milliseconds\n     */\n    unsigned tick();\n\n    /** Cancel an in-flight event\n     *\n     *  Attempts to cancel an event referenced by the unique id returned from\n     *  one of the call functions. It is safe to call cancel after an event\n     *  has already been dispatched.\n     *\n     *  id must be valid i.e. event must have not finished executing.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     *\n     *  @param id       Unique id of the event\n     */\n    void cancel(int id);\n\n    /** Query how much time is left for delayed event\n     *\n     *  If the event is delayed, this function can be used to query how much time\n     *  is left until the event is due to be dispatched.\n     *\n     *  id must be valid i.e. event must have not finished executing.\n     *\n     *  This function is irq safe.\n     *\n     *  @param id       Unique id of the event\n     *\n     *  @return         Remaining time in milliseconds or\n     *                   0 if event is already due to be dispatched or\n     *                     is currently executing.\n     *                  Undefined if id is invalid.\n     *\n     */\n    int time_left(int id);\n\n    /** Background an event queue onto a single-shot timer-interrupt\n     *\n     *  When updated, the event queue will call the provided update function\n     *  with a timeout indicating when the queue should be dispatched. A\n     *  negative timeout will be passed to the update function when the\n     *  timer-interrupt is no longer needed.\n     *\n     *  Passing a null function disables the existing update function.\n     *\n     *  The background function allows an event queue to take advantage of\n     *  hardware timers or other event loops, allowing an event queue to be\n     *  ran in the background without consuming the foreground thread.\n     *\n     *  @param update   Function called to indicate when the queue should be\n     *                  dispatched\n     */\n    void background(mbed::Callback<void(int)> update);\n\n    /** Chain an event queue onto another event queue\n     *\n     *  After chaining a queue to a target, calling dispatch on the target\n     *  queue will also dispatch events from this queue. The queues use\n     *  their own buffers and events must be handled independently.\n     *\n     *  A null queue as the target will unchain the existing queue.\n     *\n     *  The chain function allows multiple event queues to be composed,\n     *  sharing the context of a dispatch loop while still being managed\n     *  independently\n     *\n     *  @param target   Queue that will dispatch this queue's events as a\n     *                  part of its dispatch loop\n     */\n    void chain(EventQueue *target);\n\n    /** Calls an event on the queue\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     *                  Returned id will remain valid until event has finished\n     *                  executing.\n     */\n    template <typename F>\n    int call(F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call(F f, A0 a0) {\n        return call(context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call(F f, A0 a0, A1 a1) {\n        return call(context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call(F f, A0 a0, A1 a1, A2 a2) {\n        return call(context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue\n     *  @see                     EventQueue::call\n     *  @param f                 Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(T *obj, R (T::*method)()) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const T *obj, R (T::*method)() const) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(volatile T *obj, R (T::*method)() volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const volatile T *obj, R (T::*method)() const volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(T *obj, R (T::*method)(A0), A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_in function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Time to delay in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_in(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0                   Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call_in(int ms, F f, A0 a0) {\n        return call_in(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1                Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call_in(int ms, F f, A0 a0, A1 a1) {\n        return call_in(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2             Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3          Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, T *obj, R (T::*method)()) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const T *obj, R (T::*method)() const) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *\n     *  @note The first call_every event occurs after the specified delay.\n     *  To create a periodic event that fires immediately, @see Event.\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_every function is irq safe and can act as a mechanism for\n     *  moving events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Period of the event in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_every(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_period(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0>\n    int call_every(int ms, F f, A0 a0) {\n        return call_every(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1>\n    int call_every(int ms, F f, A0 a0, A1 a1) {\n        return call_every(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3      Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, T *obj, R (T::*method)()) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const T *obj, R (T::*method)() const) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Creates an event bound to the event queue\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param func        Function to execute when the event is dispatched\n     *  @return            Event that will dispatch on the specific queue\n     */\n    template <typename R>\n    Event<void()> event(R (*func)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(T *obj, R (T::*method)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const T *obj, R (T::*method)() const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(volatile T *obj, R (T::*method)() volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const volatile T *obj, R (T::*method)() const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R>\n    Event<void()> event(mbed::Callback<R()> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(R (*func)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(T *obj, R (T::*method)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const T *obj, R (T::*method)(B0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(mbed::Callback<R(B0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(R (*func)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(R (*func)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(A0) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(A0) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(A0) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(A0)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(R (*func)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, A0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, A0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(A0, A1) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(A0, A1) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(A0, A1) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(A0, A1)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(A0, A1, A2) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(A0, A1, A2)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(A0, A1, A2, A3) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(A0, A1, A2, A3)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\nprotected:\n    template <typename F>\n    friend class Event;\n    struct equeue _equeue;\n    mbed::Callback<void(int)> _update;\n\n    // Function attributes\n    template <typename F>\n    static void function_call(void *p) {\n        (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Context structures\n    template <typename F>\n    struct context00 {\n        F f;\n\n        context00(F f)\n            : f(f) {}\n\n        void operator()() {\n            f();\n        }\n    };\n\n    template <typename F, typename C0>\n    struct context10 {\n        F f; C0 c0;\n\n        context10(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()() {\n            f(c0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1>\n    struct context20 {\n        F f; C0 c0; C1 c1;\n\n        context20(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()() {\n            f(c0, c1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2>\n    struct context30 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context30(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()() {\n            f(c0, c1, c2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    struct context40 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context40(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    struct context50 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context50(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3, c4);\n        }\n    };\n\n    template <typename F, typename A0>\n    struct context01 {\n        F f;\n\n        context01(F f)\n            : f(f) {}\n\n        void operator()(A0 a0) {\n            f(a0);\n        }\n    };\n\n    template <typename F, typename C0, typename A0>\n    struct context11 {\n        F f; C0 c0;\n\n        context11(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0) {\n            f(c0, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0>\n    struct context21 {\n        F f; C0 c0; C1 c1;\n\n        context21(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0>\n    struct context31 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context31(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0>\n    struct context41 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context41(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    struct context51 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context51(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, c4, a0);\n        }\n    };\n\n    template <typename F, typename A0, typename A1>\n    struct context02 {\n        F f;\n\n        context02(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1>\n    struct context12 {\n        F f; C0 c0;\n\n        context12(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1>\n    struct context22 {\n        F f; C0 c0; C1 c1;\n\n        context22(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1>\n    struct context32 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context32(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    struct context42 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context42(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    struct context52 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context52(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, c4, a0, a1);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2>\n    struct context03 {\n        F f;\n\n        context03(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2>\n    struct context13 {\n        F f; C0 c0;\n\n        context13(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2>\n    struct context23 {\n        F f; C0 c0; C1 c1;\n\n        context23(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    struct context33 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context33(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    struct context43 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context43(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    struct context53 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context53(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    struct context04 {\n        F f;\n\n        context04(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3>\n    struct context14 {\n        F f; C0 c0;\n\n        context14(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    struct context24 {\n        F f; C0 c0; C1 c1;\n\n        context24(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    struct context34 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context34(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    struct context44 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context44(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    struct context54 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context54(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context05 {\n        F f;\n\n        context05(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context15 {\n        F f; C0 c0;\n\n        context15(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context25 {\n        F f; C0 c0; C1 c1;\n\n        context25(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context35 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context35(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context45 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context45(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context55 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context55(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n}\n\n#endif\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_TICKER_H\n#define MBED_TICKER_H\n\n#include \"drivers/TimerEvent.h\"\n#include \"platform/Callback.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/mbed_power_mgmt.h\"\n#include \"hal/lp_ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A Ticker is used to call a function at a recurring interval\n *\n *  You can use as many separate Ticker objects as you require.\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle the blinking led after 5 seconds\n *\n * #include \"mbed.h\"\n *\n * Ticker timer;\n * DigitalOut led1(LED1);\n * DigitalOut led2(LED2);\n *\n * int flip = 0;\n *\n * void attime() {\n *     flip = !flip;\n * }\n *\n * int main() {\n *     timer.attach(&attime, 5);\n *     while(1) {\n *         if(flip == 0) {\n *             led1 = !led1;\n *         } else {\n *             led2 = !led2;\n *         }\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass Ticker : public TimerEvent, private NonCopyable<Ticker> {\n\npublic:\n    Ticker() : TimerEvent(), _function(0), _lock_deepsleep(true) {\n    }\n\n    // When low power ticker is in use, then do not disable deep-sleep.\n    Ticker(const ticker_data_t *data) : TimerEvent(data), _function(0), _lock_deepsleep(true)  {\n#if DEVICE_LPTICKER\n        _lock_deepsleep = (data != get_lp_ticker_data());\n#endif\n    }\n\n    /** Attach a function to be called by the Ticker, specifying the interval in seconds\n     *\n     *  @param func pointer to the function to be called\n     *  @param t the time between calls in seconds\n     */\n    void attach(Callback<void()> func, float t) {\n        attach_us(func, t * 1000000.0f);\n    }\n\n    /** Attach a member function to be called by the Ticker, specifying the interval in seconds\n     *\n     *  @param obj pointer to the object to call the member function on\n     *  @param method pointer to the member function to be called\n     *  @param t the time between calls in seconds\n     *  @deprecated\n     *      The attach function does not support cv-qualifiers. Replaced by\n     *      attach(callback(obj, method), t).\n     */\n    template<typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach function does not support cv-qualifiers. Replaced by \"\n        \"attach(callback(obj, method), t).\")\n    void attach(T *obj, M method, float t) {\n        attach(callback(obj, method), t);\n    }\n\n    /** Attach a function to be called by the Ticker, specifying the interval in micro-seconds\n     *\n     *  @param func pointer to the function to be called\n     *  @param t the time between calls in micro-seconds\n     *\n     *  @note setting @a t to a value shorter that it takes to process the ticker callback\n     *  will cause the system to hang. Ticker callback will be called constantly with no time\n     *  for threads scheduling.\n     *\n     */\n    void attach_us(Callback<void()> func, us_timestamp_t t) {\n        core_util_critical_section_enter();\n        // lock only for the initial callback setup and this is not low power ticker\n#if DEVICE_SLEEP\n        if(!_function && _lock_deepsleep) {\n            sleep_manager_lock_deep_sleep();\n        }\n#endif\n        _function = func;\n        setup(t);\n        core_util_critical_section_exit();\n    }\n\n    /** Attach a member function to be called by the Ticker, specifying the interval in micro-seconds\n     *\n     *  @param obj pointer to the object to call the member function on\n     *  @param method pointer to the member function to be called\n     *  @param t the time between calls in micro-seconds\n     *  @deprecated\n     *      The attach_us function does not support cv-qualifiers. Replaced by\n     *      attach_us(callback(obj, method), t).\n     */\n    template<typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach_us function does not support cv-qualifiers. Replaced by \"\n        \"attach_us(callback(obj, method), t).\")\n    void attach_us(T *obj, M method, us_timestamp_t t) {\n        attach_us(Callback<void()>(obj, method), t);\n    }\n\n    virtual ~Ticker() {\n        detach();\n    }\n\n    /** Detach the function\n     */\n    void detach();\n\nprotected:\n    void setup(us_timestamp_t t);\n    virtual void handler();\n\nprotected:\n    us_timestamp_t         _delay;  /**< Time delay (in microseconds) for re-setting the multi-shot callback. */\n    Callback<void()>    _function;  /**< Callback. */\n    bool          _lock_deepsleep;  /**< Flag which indicates if deep-sleep should be disabled. */\n};\n\n} // namespace mbed\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdio.h>\n#include <math.h> //rint\n#include <string.h>\n#include \"mbed.h\"\n#include \"SX1276_LoRaRadio.h\"\n#include \"sx1276Regs-Fsk.h\"\n#include \"sx1276Regs-LoRa.h\"\n\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LRAD\"\n\n/*!\n * Sync word for Private LoRa networks\n */\n#define LORA_MAC_PRIVATE_SYNCWORD                   0x12\n\n/*!\n * Sync word for Public LoRa networks\n */\n#define LORA_MAC_PUBLIC_SYNCWORD                    0x34\n\n/*!\n * SX1276 definitions\n */\n#define XTAL_FREQ                                   32000000\n#define FREQ_STEP                                   61.03515625\n\n/*!\n * Constant values need to compute the RSSI value\n */\n#define RSSI_OFFSET_LF                              -164.0\n#define RSSI_OFFSET_HF                              -157.0\n#define RF_MID_BAND_THRESH                          525000000\n\n\n/*!\n * FSK bandwidth definition\n */\ntypedef struct\n{\n    uint32_t bandwidth;\n    uint8_t  register_value;\n} fsk_bw_t;\n\n/*!\n * Radio registers definition\n */\ntypedef struct\n{\n    uint8_t     modem;\n    uint8_t     addr;\n    uint8_t     value;\n} radio_registers_t;\n\n#define RADIO_INIT_REGISTERS_VALUE                \\\n{                                                 \\\n    { MODEM_FSK , REG_LNA                , 0x23 },\\\n    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\\\n    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\\\n    { MODEM_FSK , REG_AFCFEI             , 0x01 },\\\n    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\\\n    { MODEM_FSK , REG_OSC                , 0x07 },\\\n    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\\\n    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\\\n    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\\\n    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\\\n    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\\\n    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\\\n    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\\\n    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\\\n    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\\\n    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\\\n}\n\nstatic const fsk_bw_t fsk_bandwidths[] =\n{\n    { 2600  , 0x17 },\n    { 3100  , 0x0F },\n    { 3900  , 0x07 },\n    { 5200  , 0x16 },\n    { 6300  , 0x0E },\n    { 7800  , 0x06 },\n    { 10400 , 0x15 },\n    { 12500 , 0x0D },\n    { 15600 , 0x05 },\n    { 20800 , 0x14 },\n    { 25000 , 0x0C },\n    { 31300 , 0x04 },\n    { 41700 , 0x13 },\n    { 50000 , 0x0B },\n    { 62500 , 0x03 },\n    { 83333 , 0x12 },\n    { 100000, 0x0A },\n    { 125000, 0x02 },\n    { 166700, 0x11 },\n    { 200000, 0x09 },\n    { 250000, 0x01 },\n    { 300000, 0x00 }, // Invalid bandwidth\n};\n\n/**\n * SPI read/write masks\n */\n#define SPI_WRITE_CMD   0x80\n#define SPI_READ_CMD    0x7F\n\n/**\n * Signals\n */\n#define SIG_DIO0    0x01\n#define SIG_DIO1    0x02\n#define SIG_DIO2    0x04\n#define SIG_DIO3    0x08\n#define SIG_DIO4    0x10\n#define SIG_DIO5    0x20\n#define SIG_TIMOUT  0x40\n\n/**\n * Radio hardware registers initialization\n */\nstatic const radio_registers_t radio_reg_init[] = RADIO_INIT_REGISTERS_VALUE;\n\nenum RadioVariant {\n    SX1276UNDEFINED = 0,\n    SX1276MB1LAS,\n    SX1276MB1MAS\n};\n\n#ifdef MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#define SPI_FREQUENCY    MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#else\n#define SPI_FREQUENCY    8000000\n#endif\n\n/**\n * Constructor\n */\nSX1276_LoRaRadio::SX1276_LoRaRadio(PinName spi_mosi,\n                                   PinName spi_miso,\n                                   PinName spi_sclk,\n                                   PinName nss,\n                                   PinName reset,\n                                   PinName dio0,\n                                   PinName dio1,\n                                   PinName dio2,\n                                   PinName dio3,\n                                   PinName dio4,\n                                   PinName dio5,\n                                   PinName rf_switch_ctl1,\n                                   PinName rf_switch_ctl2,\n                                   PinName txctl,\n                                   PinName rxctl,\n                                   PinName antswitch,\n                                   PinName pwr_amp_ctl,\n                                   PinName tcxo)\n    :  _chip_select(nss, 1),\n        _reset_ctl(reset),\n        _dio0_ctl(dio0), _dio1_ctl(dio1), _dio2_ctl(dio2), _dio3_ctl(dio3), _dio4_ctl(dio4), _dio5_ctl(dio5),\n        _rf_switch_ctl1(rf_switch_ctl1, 0), _rf_switch_ctl2(rf_switch_ctl2, 0),\n        _txctl(txctl, 0), _rxctl(rxctl, 0),\n        _ant_switch(antswitch, PIN_INPUT, PullUp, 0),\n        _pwr_amp_ctl(pwr_amp_ctl),\n        _tcxo(tcxo)\n\n#ifdef MBED_CONF_RTOS_PRESENT\n        , irq_thread(osPriorityRealtime, 1024)\n#endif\n{\n    _rf_ctrls.ant_switch = antswitch;\n    _rf_ctrls.pwr_amp_ctl = pwr_amp_ctl;\n    _rf_ctrls.rf_switch_ctl1 = rf_switch_ctl1;\n    _rf_ctrls.rf_switch_ctl2 = rf_switch_ctl2;\n    _rf_ctrls.rxctl = rxctl;\n    _rf_ctrls.txctl = txctl;\n    _rf_ctrls.tcxo = tcxo;\n\n    _dio4_pin = dio4;\n    _dio5_pin = dio5;\n\n    _radio_events = NULL;\n\n    if (tcxo != NC) {\n        _tcxo = 1;\n    }\n\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.start(mbed::callback(this, &SX1276_LoRaRadio::rf_irq_task));\n#endif\n\n    EM_ASM_({\n        window.MbedJSHal.lora.init($0);\n    }, this);\n}\n\n/**\n * Destructor\n */\nSX1276_LoRaRadio::~SX1276_LoRaRadio()\n{\n\n}\n\n/*****************************************************************************\n * Public APIs                                                               *\n ****************************************************************************/\n/**\n * Acquire lock\n */\nvoid SX1276_LoRaRadio::lock(void)\n{\n    mutex.lock();\n}\n\n/**\n * Release lock\n */\nvoid SX1276_LoRaRadio::unlock(void)\n{\n    mutex.unlock();\n}\n\n/**\n * Initializes radio module\n */\nvoid SX1276_LoRaRadio::init_radio(radio_events_t *events)\n{\n    _radio_events = events;\n\n    // Reset the radio transceiver\n    radio_reset();\n\n    // set modem type - defaults to FSK here\n    set_modem(MODEM_FSK);\n\n    // set state to be idle\n    _rf_settings.state = RF_IDLE;\n}\n\n/**\n * Can be used by application/stack or the driver itself\n */\nvoid SX1276_LoRaRadio::radio_reset()\n{\n    tr_debug(\"radio_reset\");\n}\n\n/**\n * TODO: The purpose of this API is unclear.\n *       Need to start an internal discussion.\n */\nbool SX1276_LoRaRadio::check_rf_frequency(uint32_t frequency)\n{\n    // Implement check. Currently all frequencies are supported ? What band ?\n    return true;\n}\n\n/**\n * Returns current status of the radio state machine\n */\nuint8_t SX1276_LoRaRadio::get_status(void)\n{\n    return _rf_settings.state;\n}\n\n/**\n * Sets up carrier frequency\n */\nvoid SX1276_LoRaRadio::set_channel(uint32_t freq)\n{\n    // tr_debug(\"set_channel (freq=%u)\", freq);\n    _rf_settings.channel = freq;\n    freq = (uint32_t) ((double) freq / (double) FREQ_STEP);\n}\n\n/**\n * Generates 32 bit random number based upon RSSI monitoring\n * Used for various calculation by the stack for example dev nonce\n *\n * When this API is used modem is set in LoRa mode and all interrupts are\n * masked. If the user had been using FSK mode, it should be noted that a\n * change of mode is required again because the registers have changed.\n * In addition to that RX and TX configuration APIs should be called again in\n * order to have correct desires setup.\n */\nuint32_t SX1276_LoRaRadio::random( void )\n{\n    uint32_t rnd = EM_ASM_INT({\n        return Math.random() * 0x8000000 | 0;\n    });\n\n    sleep();\n\n    return rnd;\n}\n\n/**\n * Sets up receiver related configurations\n *\n * Must be called before setting the radio in rx mode\n */\nvoid SX1276_LoRaRadio::set_rx_config(radio_modems_t modem, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint32_t bandwidth_afc,\n                                     uint16_t preamble_len,\n                                     uint16_t symb_timeout, bool fix_len,\n                                     uint8_t payload_len, bool crc_on,\n                                     bool freq_hop_on, uint8_t hop_period,\n                                     bool iq_inverted, bool rx_continuous)\n{\n    set_modem(modem);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.bandwidth_afc = bandwidth_afc;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.payload_len = payload_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.rx_continuous = rx_continuous;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.rx_single_timeout = symb_timeout\n                    * ((1.0 / (double) datarate) * 8.0) * 1e3;\n\n            datarate = (uint16_t) ((double) XTAL_FREQ / (double) datarate);\n\n            // tr_debug(\"set_rx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n                // TODO Return a proper error from here\n            }\n\n            // stupid hack. TODO think something better\n            bandwidth+=7;\n\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.payload_len = payload_len;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.rx_continuous = rx_continuous;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            // tr_debug(\"set_rx_config LORA\");\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Sets up transmitter related configuration\n *\n * Must be called before putting the radio module in Tx mode or trying\n * to send\n */\nvoid SX1276_LoRaRadio::set_tx_config(radio_modems_t modem, int8_t power,\n                                     uint32_t fdev, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint16_t preamble_len, bool fix_len,\n                                     bool crc_on, bool freq_hop_on,\n                                     uint8_t hop_period, bool iq_inverted,\n                                     uint32_t timeout)\n{\n    set_modem(modem);\n    set_rf_tx_power(power);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.power = power;\n            _rf_settings.fsk.f_dev = fdev;\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.tx_timeout = timeout;\n\n            fdev = (uint16_t) ((double) fdev / (double) FREQ_STEP);\n\n            // tr_debug(\"set_tx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n            _rf_settings.lora.power = power;\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n            }\n            bandwidth += 7;\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.tx_timeout = timeout;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            // tr_debug(\"set_rx_config LORA\");\n\n            break;\n    }\n}\n\n/**\n * Calculates time on Air i.e., dwell time for a single packet\n *\n * Crucial for the stack in order to calculate dwell time so as to control\n * duty cycling.\n */\nuint32_t SX1276_LoRaRadio::time_on_air(radio_modems_t modem, uint8_t pkt_len)\n{\n    uint32_t airTime = 0;\n\n    // tr_debug(\"time_on_air\");\n\n    switch (modem) {\n        case MODEM_FSK:\n            airTime = 1;\n\n            break;\n        case MODEM_LORA:\n            double bw = 0.0;\n            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n            switch (_rf_settings.lora.bandwidth) {\n                //case 0: // 7.8 kHz\n                //    bw = 78e2;\n                //    break;\n                //case 1: // 10.4 kHz\n                //    bw = 104e2;\n                //    break;\n                //case 2: // 15.6 kHz\n                //    bw = 156e2;\n                //    break;\n                //case 3: // 20.8 kHz\n                //    bw = 208e2;\n                //    break;\n                //case 4: // 31.2 kHz\n                //    bw = 312e2;\n                //    break;\n                //case 5: // 41.4 kHz\n                //    bw = 414e2;\n                //    break;\n                //case 6: // 62.5 kHz\n                //    bw = 625e2;\n                //    break;\n                case 7: // 125 kHz\n                    bw = 125e3;\n                    break;\n                case 8: // 250 kHz\n                    bw = 250e3;\n                    break;\n                case 9: // 500 kHz\n                    bw = 500e3;\n                    break;\n            }\n\n            // Symbol rate : time for one symbol (secs)\n            double rs = bw / (1 << _rf_settings.lora.datarate);\n            double ts = 1 / rs;\n            // time of preamble\n            double tPreamble = (_rf_settings.lora.preamble_len + 4.25) * ts;\n            // Symbol length of payload and time\n            double tmp = ceil((8 * pkt_len - 4 * _rf_settings.lora.datarate + 28\n                            + 16 * _rf_settings.lora.crc_on\n                            - (_rf_settings.lora.fix_len ? 20 : 0))\n                            / (double) (4\n                                    * (_rf_settings.lora.datarate\n                                            - ((_rf_settings.lora.low_datarate_optimize > 0)\n                                                    ? 2 : 0))))\n                            * (_rf_settings.lora.coderate + 4);\n            double nPayload = 8 + ((tmp > 0) ? tmp : 0);\n            double tPayload = nPayload * ts;\n            // Time on air\n            double tOnAir = tPreamble + tPayload;\n            // return ms secs\n            airTime = floor(tOnAir * 1e3 + 0.999);\n\n            break;\n    }\n\n    tr_debug(\"time_on_air will be %u\", airTime);\n\n    return airTime;\n}\n\n/**\n * Prepares and sends the radio packet out in the air\n */\nvoid SX1276_LoRaRadio::send(uint8_t *buffer, uint8_t size)\n{\n    uint32_t tx_timeout = 0;\n\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendFsk($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.fsk.power, _rf_settings.fsk.bandwidth, _rf_settings.fsk.datarate, buffer, size);\n        break;\n\n        case MODEM_LORA:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendLoRa($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.lora.power, _rf_settings.lora.bandwidth, _rf_settings.lora.datarate, buffer, size);\n        break;\n    }\n\n    // tr_debug(\"send (modem=%d)\", _rf_settings.modem);\n    // for (size_t ix = 0; ix < size; ix++) {\n    //     printf(\"%02x \", buffer[ix]);\n    // }\n    // printf(\"\\n\");\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = size;\n\n    //         if (_rf_settings.fsk.fix_len == false) {\n    //             write_fifo((uint8_t*) &size, 1);\n    //         } else {\n    //             write_to_register(REG_PAYLOADLENGTH, size);\n    //         }\n\n    //         if ((size > 0) && (size <= 64)) {\n    //             _rf_settings.fsk_packet_handler.chunk_size = size;\n    //         } else {\n    //             memcpy(_data_buffer, buffer, size);\n    //             _rf_settings.fsk_packet_handler.chunk_size = 32;\n    //         }\n\n    //         // Write payload buffer\n    //         write_fifo(buffer, _rf_settings.fsk_packet_handler.chunk_size);\n    //         _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                 _rf_settings.fsk_packet_handler.chunk_size;\n    //         tx_timeout = _rf_settings.fsk.tx_timeout;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register(REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_ON));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         _rf_settings.lora_packet_handler.size = size;\n\n    //         // Initializes the payload size\n    //         write_to_register(REG_LR_PAYLOADLENGTH, size);\n\n    //         // Full buffer used for Tx\n    //         write_to_register(REG_LR_FIFOTXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         // FIFO operations can not take place in Sleep mode\n    //         if ((read_register( REG_OPMODE) & ~RF_OPMODE_MASK) == RF_OPMODE_SLEEP) {\n    //             standby();\n    //             wait_ms(1);\n    //         }\n    //         // write_to_register payload buffer\n    //         write_fifo(buffer, size);\n    //         tx_timeout = _rf_settings.lora.tx_timeout;\n\n    //         break;\n    // }\n\n    transmit(tx_timeout);\n}\n\n/**\n * sets the radio module to sleep\n */\n\nvoid SX1276_LoRaRadio::sleep()\n{\n    tr_debug(\"sleep\");\n\n    // stop timers\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    // put module in sleep mode\n    set_operation_mode(RF_OPMODE_SLEEP);\n}\n\n/**\n * Put radio in Standby mode\n */\nvoid SX1276_LoRaRadio::standby( void )\n{\n    // tr_debug(\"standby\");\n\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    set_operation_mode(RF_OPMODE_STANDBY);\n    _rf_settings.state = RF_IDLE;\n}\n\nvoid SX1276_LoRaRadio::rx_frame(uint8_t* data, uint32_t size, uint32_t frequency, uint8_t bandwidth, uint8_t datarate) {\n    tr_debug(\"rx_frame, size=%u, freq=%u, bw=%u, dr=%u\", size, frequency, bandwidth, datarate);\n\n    EM_ASM({\n        console.log('rx_frame', Date.now());\n    });\n\n    if (_rf_settings.lora.bandwidth != bandwidth) {\n        tr_debug(\"rx_frame bw not correct (expecting %d, was %d)\", _rf_settings.lora.bandwidth, bandwidth);\n        return;\n    }\n\n    if (_rf_settings.lora.datarate != datarate) {\n        tr_debug(\"rx_frame dr not correct (expecting %d, was %d)\", _rf_settings.lora.datarate, datarate);\n        return;\n    }\n\n    if (_rf_settings.channel != frequency) {\n        tr_debug(\"rx_frame freq not correct (expecting %d, was %d)\", _rf_settings.channel, frequency);\n        return;\n    }\n\n    memcpy(_data_buffer, data, size);\n    _rf_settings.lora_packet_handler.size = size;\n    _rf_settings.lora_packet_handler.rssi_value = -35;\n    _rf_settings.lora_packet_handler.snr_value = -5;\n    _rf_settings.lora_packet_handler.pending = true;\n    _rf_settings.lora_packet_handler.timestamp_ms = EM_ASM_INT({ return Date.now(); });\n}\n\n/**\n * Sets the radio module in receive mode\n *\n * A DIO4 interrupt let's the state machine know that a preamble is detected\n * and finally a DIO0 interrupt let's the state machine know that a packet is\n * ready to be read from the FIFO\n */\nvoid SX1276_LoRaRadio::receive(uint32_t timeout)\n{\n    tr_debug(\"receive (timeout=%u). has_pending=%d\", timeout, _rf_settings.lora_packet_handler.pending);\n\n    EM_ASM({\n        console.log('receive', Date.now());\n    });\n\n    _rf_settings.state = RF_RX_RUNNING;\n\n    // q:\n    if (_rf_settings.lora_packet_handler.pending) {\n        uint32_t delta_ms = EM_ASM_INT({ return Date.now(); }) - _rf_settings.lora_packet_handler.timestamp_ms;\n\n        tr_debug(\"receive delta %u ms.\", delta_ms);\n\n        _rf_settings.lora_packet_handler.pending = false;\n\n        if (delta_ms > 500) {\n            tr_warn(\"receive delta was over 500 ms (was %u ms), discarding packet\", delta_ms);\n            return;\n        }\n\n        // after 200 ms. we send the rx_done event\n        rx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::rx_done_irq), 200 * 1e3);\n        return;\n    }\n\n    if (timeout != 0) {\n        rx_timeout_timer.attach_us(\n                callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                timeout * 1e3);\n    }\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         if (timeout == 0 && _rf_settings.fsk.rx_continuous == false) {\n    //              // user messed up probably timeout was 0 but mode was not\n    //              // continuous, force it to be continuous\n    //              _rf_settings.fsk.rx_continuous = true;\n    //          }\n\n    //         // DIO0=PayloadReady\n    //         // DIO1=FifoLevel\n    //         // DIO2=SyncAddr\n    //         // DIO3=FifoEmpty\n    //         // DIO4=Preamble\n    //         // DIO5=ModeReady\n    //         write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                 & RF_DIOMAPPING1_DIO0_MASK\n    //                 & RF_DIOMAPPING1_DIO1_MASK\n    //                 & RF_DIOMAPPING1_DIO2_MASK)\n    //                           | RF_DIOMAPPING1_DIO0_00\n    //                           | RF_DIOMAPPING1_DIO1_00\n    //                           | RF_DIOMAPPING1_DIO2_11);\n\n    //         write_to_register(REG_DIOMAPPING2, (read_register( REG_DIOMAPPING2)\n    //                 & RF_DIOMAPPING2_DIO4_MASK\n    //                 & RF_DIOMAPPING2_MAP_MASK)\n    //                           | RF_DIOMAPPING2_DIO4_11\n    //                           | RF_DIOMAPPING2_MAP_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.fifo_thresh =\n    //                 read_register(REG_FIFOTHRESH) & 0x3F;\n\n    //         write_to_register(REG_RXCONFIG, RF_RXCONFIG_AFCAUTO_ON\n    //                           | RF_RXCONFIG_AGCAUTO_ON\n    //                           | RF_RXCONFIG_RXTRIGER_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = 0;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (timeout == 0 && _rf_settings.lora.rx_continuous == false) {\n    //             // user messed up probably timeout was 0 but mode was not\n    //             // continuous, force it to be continuous\n    //             _rf_settings.lora.rx_continuous = true;\n    //         }\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal\n    //         if (_rf_settings.lora.bandwidth < 9) {\n    //             write_to_register(REG_LR_DETECTOPTIMIZE,\n    //                               read_register(REG_LR_DETECTOPTIMIZE) & 0x7F);\n    //             write_to_register(REG_LR_TEST30, 0x00);\n    //             switch (_rf_settings.lora.bandwidth) {\n    //                 case 0: // 7.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x48);\n    //                     set_channel(_rf_settings.channel + 7.81e3);\n    //                     break;\n    //                 case 1: // 10.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 10.42e3);\n    //                     break;\n    //                 case 2: // 15.6 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 15.62e3);\n    //                     break;\n    //                 case 3: // 20.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 20.83e3);\n    //                     break;\n    //                 case 4: // 31.2 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 31.25e3);\n    //                     break;\n    //                 case 5: // 41.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 41.67e3);\n    //                     break;\n    //                 case 6: // 62.5 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 7: // 125 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 8: // 250 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //             }\n    //         } else {\n    //             write_to_register( REG_LR_DETECTOPTIMIZE,\n    //                               read_register( REG_LR_DETECTOPTIMIZE) | 0x80);\n    //         }\n\n    //         if (_rf_settings.lora.freq_hop_on == true) {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                               | RFLR_IRQFLAGS_TXDONE\n    //                               | RFLR_IRQFLAGS_CADDONE\n    //                               | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone, DIO2=FhssChangeChannel\n    //             write_to_register(REG_DIOMAPPING1, (read_register(REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK\n    //                             & RFLR_DIOMAPPING1_DIO2_MASK)\n    //                             | RFLR_DIOMAPPING1_DIO0_00\n    //                             | RFLR_DIOMAPPING1_DIO2_00);\n    //         } else {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                                | RFLR_IRQFLAGS_TXDONE\n    //                                | RFLR_IRQFLAGS_CADDONE\n    //                                | RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL\n    //                                | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone\n    //             write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK)\n    //                               | RFLR_DIOMAPPING1_DIO0_00);\n    //         }\n    //         write_to_register(REG_LR_FIFORXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         break;\n    // }\n\n    // _rf_settings.state = RF_RX_RUNNING;\n\n    // if (timeout != 0) {\n    //     rx_timeout_timer.attach_us(\n    //             callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //             timeout * 1e3);\n    // }\n\n    // if (_rf_settings.modem == MODEM_FSK) {\n    //     set_operation_mode(RF_OPMODE_RECEIVER);\n\n    //     if (_rf_settings.fsk.rx_continuous == false) {\n    //         rx_timeout_sync_word.attach_us(\n    //                 callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //                 _rf_settings.fsk.rx_single_timeout * 1e3);\n    //     }\n\n    //     return;\n    // }\n\n    // If mode is LoRa set mode\n    if (_rf_settings.lora.rx_continuous == true) {\n        set_operation_mode(RFLR_OPMODE_RECEIVER);\n    } else {\n        set_operation_mode(RFLR_OPMODE_RECEIVER_SINGLE);\n    }\n}\n\n\n/**\n * Perform carrier sensing\n *\n * Checks for a certain time if the RSSI is above a given threshold.\n * This threshold determines if there is already a transmission going on\n * in the channel or not.\n *\n */\nbool SX1276_LoRaRadio::perform_carrier_sense(radio_modems_t modem,\n                                   uint32_t freq,\n                                   int16_t rssi_threshold,\n                                   uint32_t max_carrier_sense_time)\n{\n    // tr_debug(\"perform_carrier_sense\");\n\n    bool status = true;\n    int16_t rssi = 0;\n\n    set_modem(modem);\n    set_channel(freq);\n    set_operation_mode(RF_OPMODE_RECEIVER);\n\n    // hold on a bit, radio turn-around time\n    wait_ms(1);\n\n    Timer elapsed_time;\n    elapsed_time.start();\n\n    // Perform carrier sense for maxCarrierSenseTime\n    while (elapsed_time.read_ms() < (int)max_carrier_sense_time) {\n        rssi = get_rssi(modem);\n\n        if (rssi > rssi_threshold) {\n            status = false;\n            break;\n        }\n    }\n\n    sleep();\n    return status;\n}\n\n/**\n * TODO: Making sure if this API is valid only for LoRa modulation ?\n *\n * Indicates if the node is part of a private or public network\n */\nvoid SX1276_LoRaRadio::set_public_network(bool enable)\n{\n    set_modem(MODEM_LORA);\n\n    _rf_settings.lora.public_network = enable;\n\n    // tr_debug(\"set_public_network %d\", enable);\n\n}\n\n/**\n * Puts a limit on the size of payload the module can handle\n * By default it is MAX, i.e., 256 bytes\n */\nvoid SX1276_LoRaRadio::set_max_payload_length(radio_modems_t modem, uint8_t max)\n{\n    set_modem(modem);\n\n    // tr_debug(\"set_max_payload_length (modem=%d, max=%u)\", modem, max);\n}\n\n/**\n * Channel Activity detection (can be done only in LoRa mode)\n *\n * If any activity on the channel is detected, an interrupt is asserted on\n * DIO3. A callback will be generated to the stack/application upon the\n * assertion of DIO3.\n */\nvoid SX1276_LoRaRadio::start_cad()\n{\n    // tr_debug(\"start_cad\");\n}\n\n/**\n * Set transmission in continuous wave mode\n */\nvoid SX1276_LoRaRadio::set_tx_continuous_wave(uint32_t freq, int8_t power,\n                                              uint16_t time)\n{\n    // tr_debug(\"set_tx_continious_wave (freq=%u, power=%u, time=%u)\", freq, power, time);\n\n    uint8_t reg_val;\n\n    set_channel(freq);\n    set_tx_config(MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, time);\n    // reg_val = read_register(REG_PACKETCONFIG2);\n\n    // write_to_register( REG_PACKETCONFIG2, (reg_val & RF_PACKETCONFIG2_DATAMODE_MASK ) );\n    // // Disable radio interrupts\n    // write_to_register( REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11 );\n    // write_to_register( REG_DIOMAPPING2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10 );\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::timeout_irq_isr), time*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n}\n\n/*****************************************************************************\n * Private APIs                                                              *\n ****************************************************************************/\n#ifdef MBED_CONF_RTOS_PRESENT\n/**\n * Thread task handling IRQs\n */\nvoid SX1276_LoRaRadio::rf_irq_task(void)\n{\n    for (;;) {\n        osEvent event = irq_thread.signal_wait(0, osWaitForever);\n        if (event.status != osEventSignal) {\n            continue;\n        }\n\n        lock();\n        if (event.value.signals & SIG_DIO0) {\n            handle_dio0_irq();\n        }\n        if (event.value.signals & SIG_DIO1) {\n            handle_dio1_irq();\n        }\n        if (event.value.signals & SIG_DIO2) {\n            handle_dio2_irq();\n        }\n        if (event.value.signals & SIG_DIO3) {\n            handle_dio3_irq();\n        }\n        if (event.value.signals & SIG_DIO4) {\n            handle_dio4_irq();\n        }\n        if (event.value.signals & SIG_DIO5) {\n            handle_dio5_irq();\n        }\n        if (event.value.signals & SIG_TIMOUT) {\n            handle_timeout_irq();\n        }\n        unlock();\n    }\n}\n#endif\n\n/**\n * Writes to FIIO provided by the chip\n */\nvoid SX1276_LoRaRadio::write_fifo(uint8_t *buffer, uint8_t size)\n{\n    // tr_debug(\"write_fifo (size=%u)\", size);\n}\n\n/**\n * Reads from the FIFO provided by the chip\n */\nvoid SX1276_LoRaRadio::read_fifo(uint8_t *buffer, uint8_t size)\n{\n    // tr_debug(\"read_fifo (size=%u)\", size);\n}\n\n/**\n * Sets up operation mode\n */\nvoid SX1276_LoRaRadio::set_operation_mode(uint8_t mode)\n{\n    // tr_debug(\"set_operation_mode (mode=%u)\", mode);\n\n    if (mode == RF_OPMODE_SLEEP) {\n        set_low_power_mode();\n    } else {\n        set_low_power_mode();\n        set_antenna_switch(mode);\n    }\n}\n\n/**\n * Sets the modem type to use\n *\n * At initialization FSK is chosen. Later stack or application\n * can choose to change.\n */\nvoid SX1276_LoRaRadio::set_modem(uint8_t modem )\n{\n    _rf_settings.modem = modem;\n\n    // tr_debug(\"set_modem %d\", _rf_settings.modem);\n}\n\n/**\n * Set the radio module variant\n */\nvoid SX1276_LoRaRadio::set_sx1276_variant_type()\n{\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch.input();\n        wait_ms(1);\n        if (_ant_switch == 1) {\n            radio_variant = SX1276MB1LAS;\n        } else {\n            radio_variant = SX1276MB1MAS;\n        }\n        _ant_switch.output();\n        wait_ms(1);\n    } else {\n        radio_variant = SX1276UNDEFINED;\n    }\n}\n\n/**\n * Sets the radio registers to defaults\n */\nvoid SX1276_LoRaRadio::setup_registers()\n{\n    // tr_debug(\"setup_registers\");\n}\n\n/**\n * Performs the Rx chain calibration for LF and HF bands\n *\n * Must be called just after the reset so all registers are at their\n * default values.\n */\nvoid SX1276_LoRaRadio::rx_chain_calibration(void)\n{\n    // tr_debug(\"rx_chain_calibration\");\n}\n\n/**\n * Gets FSK bandwidth values\n *\n * Gives either normal bandwidths or bandwidths for\n * AFC (auto frequency correction)\n */\nuint8_t SX1276_LoRaRadio::get_fsk_bw_reg_val(uint32_t bandwidth)\n{\n    uint8_t i;\n\n    for (i = 0; i < (sizeof(fsk_bandwidths) / sizeof(fsk_bw_t)) - 1; i++) {\n        if ((bandwidth >= fsk_bandwidths[i].bandwidth)\n                && (bandwidth < fsk_bandwidths[i + 1].bandwidth)) {\n            return fsk_bandwidths[i].register_value;\n        }\n    }\n    // ERROR: Value not found\n    // This should never happen\n    while (1);\n}\n\nuint8_t SX1276_LoRaRadio::get_pa_conf_reg(uint32_t channel)\n{\n    if (radio_variant == SX1276UNDEFINED) {\n        return RF_PACONFIG_PASELECT_PABOOST;\n    } else if (channel > RF_MID_BAND_THRESH) {\n        if (radio_variant == SX1276MB1LAS) {\n            return RF_PACONFIG_PASELECT_PABOOST;\n        } else {\n            return RF_PACONFIG_PASELECT_RFO;\n        }\n    } else {\n        return RF_PACONFIG_PASELECT_RFO;\n    }\n}\n\n/**\n * Sets the transmit power for the module\n */\nvoid SX1276_LoRaRadio::set_rf_tx_power(int8_t power)\n{\n    // tr_debug(\"set_rf_tx_power (power=%u)\", power);\n}\n\n/**\n * Actual TX - Transmit routine\n *\n * A DIO0 interrupt let the state machine know that a a packet is\n * successfully sent, otherwise a TxTimeout is invoked.\n * TxTimeout should never happen in normal circumstances as the radio should\n * be able to send a packet out in the air no matter what.\n */\nvoid SX1276_LoRaRadio::transmit(uint32_t timeout)\n{\n    tr_debug(\"transmit (timeout=%u)\", timeout);\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this,\n    //                            &SX1276_LoRaRadio::timeout_irq_isr), timeout*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n\n    // after 100ms. we fire the tx_done event\n    tx_done_timer.attach_us(callback(this, &SX1276_LoRaRadio::tx_done_irq), 100 * 1e3);\n}\n\nvoid SX1276_LoRaRadio::tx_done_irq() {\n    tx_done_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    tr_info(\"tx_done_irq\");\n\n    if ((_radio_events != NULL)\n        && (_radio_events->tx_done)) {\n\n        _radio_events->tx_done();\n    }\n}\n\nvoid SX1276_LoRaRadio::rx_done_irq() {\n    tr_debug(\"rx_done_irq\");\n\n    rx_timeout_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->rx_done)) {\n\n        _radio_events->rx_done(_data_buffer,\n                _rf_settings.lora_packet_handler.size,\n                _rf_settings.lora_packet_handler.rssi_value,\n                _rf_settings.lora_packet_handler.snr_value);\n    }\n}\n\n/**\n * Get RSSI from the module\n */\nint16_t SX1276_LoRaRadio::get_rssi(radio_modems_t modem)\n{\n    // tr_debug(\"get_rssi\");\n\n    return -1;\n}\n\n/**\n * Sets the module in low power mode by disconnecting\n * TX and RX submodules, turning off power amplifier etc.\n */\nvoid SX1276_LoRaRadio::set_low_power_mode()\n{\n\n    // tr_debug(\"set_low_power_mode\");\n\n    if (_rf_ctrls.rf_switch_ctl1 != NC) {\n        _rf_switch_ctl1 = 0;\n    }\n\n    if (_rf_ctrls.rf_switch_ctl2 != NC) {\n        _rf_switch_ctl2 = 0;\n    }\n\n    if (_rf_ctrls.pwr_amp_ctl != NC) {\n        _pwr_amp_ctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _txctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _rxctl = 0;\n    }\n\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch = 0;\n    }\n}\n\n/**\n * Attaches ISRs to interrupt pins\n */\nvoid SX1276_LoRaRadio::setup_interrupts()\n{\n    _dio0_ctl.rise(callback(this, &SX1276_LoRaRadio::dio0_irq_isr));\n    _dio1_ctl.rise(callback(this, &SX1276_LoRaRadio::dio1_irq_isr));\n    _dio2_ctl.rise(callback(this, &SX1276_LoRaRadio::dio2_irq_isr));\n    _dio3_ctl.rise(callback(this, &SX1276_LoRaRadio::dio3_irq_isr));\n    if (_dio4_pin != NC) {\n        _dio4_ctl.rise(callback(this, &SX1276_LoRaRadio::dio4_irq_isr));\n    }\n    if (_dio5_pin != NC) {\n        _dio5_ctl.rise(callback(this, &SX1276_LoRaRadio::dio5_irq_isr));\n    }\n}\n\n/**\n * Sets up radio latch position according to the\n * radio mode\n */\nvoid SX1276_LoRaRadio::set_antenna_switch(uint8_t mode)\n{\n    // tr_debug(\"set_antenna_switch (mode=%u)\", mode);\n\n    // // here we got to do ifdef for changing controls\n    // // as some pins might be NC\n    // switch (mode) {\n    //     case RFLR_OPMODE_TRANSMITTER:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // module is in transmit mode and RF latch switches\n    //             // are connected. Check if power amplifier boost is\n    //             // setup or not\n    //             if ((read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST)\n    //                                    == RF_PACONFIG_PASELECT_PABOOST) {\n    //                 _rf_switch_ctl1 = 1;\n    //                 _rf_switch_ctl2 = 0;\n    //             } else {\n    //                 // power amplifier not selected\n    //                 _rf_switch_ctl1 = 0;\n    //                 _rf_switch_ctl2 = 1;\n    //             }\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             // module is in transmit mode and tx/rx submodule control\n    //             // pins are connected\n    //             if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //                 if (read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST) {\n    //                     _pwr_amp_ctl = 1;\n    //                     _txctl = 0;\n    //                 } else {\n    //                     _pwr_amp_ctl = 0;\n    //                     _txctl = 1;\n    //                 }\n    //             } else {\n    //                 _txctl = 1;\n    //             }\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC){\n    //             _ant_switch = 1;\n    //         }\n    //         break;\n    //     case RFLR_OPMODE_RECEIVER:\n    //     case RFLR_OPMODE_RECEIVER_SINGLE:\n    //     case RFLR_OPMODE_CAD:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 1;\n    //             _rf_switch_ctl2 = 1;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 1;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    //     default:\n    //         // Enforce default case  when any connected control pin is kept low.\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 0;\n    //             _rf_switch_ctl2 = 0;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    // }\n}\n\n/*****************************************************************************\n * Interrupt service routines (ISRs) - set signals to the irq_thread         *\n ****************************************************************************/\nvoid SX1276_LoRaRadio::dio0_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n   irq_thread.signal_set(SIG_DIO0);\n#else\n   handle_dio0_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio1_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO1);\n#else\n    handle_dio1_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio2_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO2);\n#else\n    handle_dio2_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio3_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO3);\n#else\n    handle_dio3_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio4_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO4);\n#else\n    handle_dio4_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio5_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO5);\n#else\n    handle_dio5_irq();\n#endif\n}\n\n// This is not a hardware interrupt\n// we invoke it ourselves based upon\n// our timers\nvoid SX1276_LoRaRadio::timeout_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_TIMOUT);\n#else\n    handle_timeout_irq();\n#endif\n}\n\n/******************************************************************************\n * Interrupt Handlers                                                         *\n *****************************************************************************/\n\nvoid SX1276_LoRaRadio::handle_dio0_irq()\n{\n    // volatile uint8_t irqFlags = 0;\n\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 if (_rf_settings.fsk.crc_on == true) {\n    //                     irqFlags = read_register(REG_IRQFLAGS2);\n    //                     if ((irqFlags & RF_IRQFLAGS2_CRCOK)\n    //                             != RF_IRQFLAGS2_CRCOK) {\n    //                         // Clear Irqs\n    //                         write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n    //                                           RF_IRQFLAGS1_PREAMBLEDETECT |\n    //                                           RF_IRQFLAGS1_SYNCADDRESSMATCH);\n    //                         write_to_register(REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n\n    //                         if (_rf_settings.fsk.rx_continuous == false) {\n    //                             rx_timeout_sync_word.detach();\n    //                             _rf_settings.state = RF_IDLE;\n    //                         } else {\n    //                             // Continuous mode restart Rx chain\n    //                             write_to_register(REG_RXCONFIG,\n    //                                               read_register(REG_RXCONFIG) |\n    //                                               RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                         }\n\n    //                         rx_timeout_timer.detach();\n\n    //                         if ((_radio_events != NULL)\n    //                                 && (_radio_events->rx_error)) {\n    //                             _radio_events->rx_error();\n    //                         }\n    //                         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                         _rf_settings.fsk_packet_handler.size = 0;\n    //                         // break from here, a CRC error happened, RX_ERROR\n    //                         // was notified. No need to go any further\n    //                         break;\n    //                     }\n    //                 }\n\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size = read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 } else {\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 if (_rf_settings.fsk.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                     rx_timeout_sync_word.detach();\n    //                 } else {\n    //                     // Continuous mode restart Rx chain\n    //                     write_to_register(REG_RXCONFIG, read_register(REG_RXCONFIG)\n    //                                     | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                 }\n\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(\n    //                             _data_buffer,\n    //                             _rf_settings.fsk_packet_handler.size,\n    //                             _rf_settings.fsk_packet_handler.rssi_value, 0);\n    //                 }\n    //                 _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                 _rf_settings.fsk_packet_handler.size = 0;\n    //                 break;\n\n    //             case MODEM_LORA: {\n    //                 int8_t snr = 0;\n\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE);\n\n    //                 irqFlags = read_register(REG_LR_IRQFLAGS);\n    //                 if ((irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK)\n    //                         == RFLR_IRQFLAGS_PAYLOADCRCERROR) {\n    //                     // Clear Irq\n    //                     write_to_register( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR);\n\n    //                     if (_rf_settings.lora.rx_continuous == false) {\n    //                         _rf_settings.state = RF_IDLE;\n    //                     }\n    //                     rx_timeout_timer.detach();\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->rx_error)) {\n    //                         _radio_events->rx_error();\n    //                     }\n    //                     break;\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.snr_value = read_register(\n    //                         REG_LR_PKTSNRVALUE);\n    //                 if (_rf_settings.lora_packet_handler.snr_value & 0x80) // The SNR sign bit is 1\n    //                         {\n    //                     // Invert and divide by 4\n    //                     snr = ((~_rf_settings.lora_packet_handler.snr_value + 1)\n    //                             & 0xFF) >> 2;\n    //                     snr = -snr;\n    //                 } else {\n    //                     // Divide by 4\n    //                     snr =\n    //                             (_rf_settings.lora_packet_handler.snr_value\n    //                                     & 0xFF) >> 2;\n    //                 }\n\n    //                 int16_t rssi = read_register( REG_LR_PKTRSSIVALUE);\n    //                 if (snr < 0) {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4) + snr;\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4) + snr;\n    //                     }\n    //                 } else {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4);\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4);\n    //                     }\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.size = read_register(REG_LR_RXNBBYTES);\n    //                 read_fifo(_data_buffer, _rf_settings.lora_packet_handler.size);\n\n    //                 if (_rf_settings.lora.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                 }\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(_data_buffer,\n    //                             _rf_settings.lora_packet_handler.size,\n    //                             _rf_settings.lora_packet_handler.rssi_value,\n    //                             _rf_settings.lora_packet_handler.snr_value);\n    //                 }\n    //             }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     case RF_TX_RUNNING:\n    //         tx_timeout_timer.detach();\n    //         // TxDone interrupt\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_LORA:\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE);\n    //                 // Intentional fall through\n    //             case MODEM_FSK:\n    //             default:\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->tx_done)) {\n    //                     _radio_events->tx_done();\n    //                 }\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio1_irq()\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size =\n    //                                 read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                 }\n\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.fifo_thresh) {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh;\n    //                 } else {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 // Sync time out\n    //                 rx_timeout_timer.detach();\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXTIMEOUT);\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->rx_timeout)) {\n    //                     _radio_events->rx_timeout();\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.chunk_size) {\n    //                     write_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.chunk_size);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.chunk_size;\n    //                 } else {\n    //                     // Write the last chunk of data\n    //                     write_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio2_irq(void)\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // DIO4 must have been asserted to set preamble_detected to true\n    //                 if ((_rf_settings.fsk_packet_handler.preamble_detected == 1)\n    //                         && (_rf_settings.fsk_packet_handler.sync_word_detected == 0)) {\n    //                     if (_rf_settings.fsk.rx_continuous == false) {\n    //                         rx_timeout_sync_word.detach();\n    //                     }\n\n    //                     _rf_settings.fsk_packet_handler.sync_word_detected = 1;\n\n    //                     _rf_settings.fsk_packet_handler.rssi_value =\n    //                             -(read_register(REG_RSSIVALUE) >> 1);\n\n    //                     _rf_settings.fsk_packet_handler.afc_value =\n    //                             (int32_t) (double) (((uint16_t) read_register(\n    //                                     REG_AFCMSB) << 8)\n    //                                     | (uint16_t) read_register( REG_AFCLSB))\n    //                                     * (double) FREQ_STEP;\n    //                     _rf_settings.fsk_packet_handler.rx_gain =\n    //                             (read_register( REG_LNA) >> 5) & 0x07;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n\n    //                 break;\n\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 break;\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio3_irq(void)\n{\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         break;\n    //     case MODEM_LORA:\n    //         if ((read_register(REG_LR_IRQFLAGS) & RFLR_IRQFLAGS_CADDETECTED)\n    //                 == RFLR_IRQFLAGS_CADDETECTED) {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS,\n    //                     RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(true);\n    //             }\n    //         } else {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(false);\n    //             }\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio4_irq(void)\n{\n    // is asserted when a preamble is detected (FSK modem only)\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK: {\n    //         if (_rf_settings.fsk_packet_handler.preamble_detected == 0) {\n    //             _rf_settings.fsk_packet_handler.preamble_detected = 1;\n    //         }\n    //     }\n    //         break;\n    //     case MODEM_LORA:\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio5_irq()\n{\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            break;\n        case MODEM_LORA:\n            break;\n        default:\n            break;\n    }\n}\n\n\nvoid SX1276_LoRaRadio::handle_timeout_irq()\n{\n    tr_debug(\"handle_timeout_irq\");\n\n    switch (_rf_settings.state) {\n        case RF_RX_RUNNING:\n            if (_rf_settings.modem == MODEM_FSK) {\n                _rf_settings.fsk_packet_handler.preamble_detected = 0;\n                _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n                _rf_settings.fsk_packet_handler.nb_bytes = 0;\n                _rf_settings.fsk_packet_handler.size = 0;\n\n                // Clear Irqs\n                // write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n                // RF_IRQFLAGS1_PREAMBLEDETECT |\n                // RF_IRQFLAGS1_SYNCADDRESSMATCH);\n                // write_to_register( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n                if (_rf_settings.fsk.rx_continuous == true) {\n                    // Continuous mode restart Rx chain\n                    // write_to_register( REG_RXCONFIG,\n                    //                   read_register(REG_RXCONFIG) |\n                    //                   RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n                } else {\n                    _rf_settings.state = RF_IDLE;\n                    rx_timeout_sync_word.attach_us(\n                            callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                            _rf_settings.fsk.rx_single_timeout * 1e3);\n                }\n            }\n\n            if ((_radio_events != NULL)\n                    && (_radio_events->rx_timeout)) {\n                _radio_events->rx_timeout();\n            }\n\n            break;\n\n        case RF_TX_RUNNING:\n            // Tx timeout shouldn't happen.\n            // But it has been observed that when it happens it is a result of a\n            // corrupted SPI transfer\n            // The workaround is to put the radio in a known state.\n            // Thus, we re-initialize it.\n\n            // // Reset the radio\n            // radio_reset();\n\n            // // Initialize radio default values\n            // set_operation_mode(RF_OPMODE_SLEEP);\n\n            // // setup_registers();\n\n            // set_modem(MODEM_FSK);\n\n            // // Restore previous network type setting.\n            // set_public_network(_rf_settings.lora.public_network);\n\n            _rf_settings.state = RF_IDLE;\n            if ((_radio_events != NULL)\n                    && (_radio_events->tx_timeout)) {\n                _radio_events->tx_timeout();\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void handle_lora_downlink(uint32_t radioPtr, uint32_t dataPtr, uint32_t size, uint32_t freq, uint8_t bandwidth, uint8_t datarate) {\n    ((SX1276_LoRaRadio*)radioPtr)->rx_frame((uint8_t*)dataPtr, size, freq, bandwidth, datarate);\n}\n\n// EOF\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_TIMEOUT_H\n#define MBED_TIMEOUT_H\n\n#include \"drivers/Ticker.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/mbed_power_mgmt.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A Timeout is used to call a function at a point in the future\n *\n * You can use as many seperate Timeout objects as you require.\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Blink until timeout.\n *\n * #include \"mbed.h\"\n *\n * Timeout timeout;\n * DigitalOut led(LED1);\n *\n * int on = 1;\n *\n * void attimeout() {\n *     on = 0;\n * }\n *\n * int main() {\n *     timeout.attach(&attimeout, 5);\n *     while(on) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass Timeout : public Ticker, private NonCopyable<Timeout> {\n\nprotected:\n    virtual void handler();\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/InterruptIn.h\"\n\n#if DEVICE_INTERRUPTIN\n\nnamespace mbed {\n\n// Note: This single-parameter constructor exists to maintain binary\n//       compatibility.\n//       If not for that, we could simplify by having only the 2-param\n//       constructor, with a default value for the PinMode.\nInterruptIn::InterruptIn(PinName pin) : gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in(&gpio, pin);\n}\n\nInterruptIn::InterruptIn(PinName pin, PinMode mode) :\n                                        gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in_ex(&gpio, pin, mode);\n}\n\nvoid InterruptIn::irq_init(PinName pin) {\n   gpio_irq_init(&gpio_irq, pin, (&InterruptIn::_irq_handler), (uint32_t)this);\n}\n\nInterruptIn::~InterruptIn() {\n    // No lock needed in the destructor\n    gpio_irq_free(&gpio_irq);\n}\n\nint InterruptIn::read() {\n    // Read only\n    return gpio_read(&gpio);\n}\n\nvoid InterruptIn::mode(PinMode pull) {\n    core_util_critical_section_enter();\n    gpio_mode(&gpio, pull);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::rise(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _rise = func;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 1);\n    } else {\n        _rise = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::fall(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _fall = func;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 1);\n    } else {\n        _fall = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::_irq_handler(uint32_t id, gpio_irq_event event) {\n    InterruptIn *handler = (InterruptIn*)id;\n    switch (event) {\n        case IRQ_RISE: \n            if (handler->_rise) {\n                handler->_rise();\n            }\n            break;\n        case IRQ_FALL: \n            if (handler->_fall) {\n                handler->_fall(); \n            }\n            break;\n        case IRQ_NONE: break;\n    }\n}\n\nvoid InterruptIn::enable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_enable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::disable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_disable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nInterruptIn::operator int() {\n    // Underlying call is atomic\n    return read();\n}\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/Timeout.h\"\n\nnamespace mbed {\n\nvoid Timeout::handler() {\n    Callback<void()> local = _function;\n    detach();\n    local.call();\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/Timer.h\"\n#include \"hal/ticker_api.h\"\n#include \"hal/us_ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/lp_ticker_api.h\"\n\nnamespace mbed {\n\nTimer::Timer() : _running(), _start(), _time(), _ticker_data(get_us_ticker_data()), _lock_deepsleep(true) {\n    reset();\n}\n\nTimer::Timer(const ticker_data_t *data) : _running(), _start(), _time(), _ticker_data(data), _lock_deepsleep(true) {\n    reset();\n#if DEVICE_LPTICKER\n    _lock_deepsleep = (data != get_lp_ticker_data());\n#endif\n}\n\nTimer::~Timer() {\n    core_util_critical_section_enter();\n    if (_running) {\n        if(_lock_deepsleep) {\n            sleep_manager_unlock_deep_sleep();\n        }\n    }\n    _running = 0;\n    core_util_critical_section_exit();\n}\n\nvoid Timer::start() {\n    core_util_critical_section_enter();\n    if (!_running) {\n        if(_lock_deepsleep) {\n            sleep_manager_lock_deep_sleep();\n        }\n        _start = ticker_read_us(_ticker_data);\n        _running = 1;\n    }\n    core_util_critical_section_exit();\n}\n\nvoid Timer::stop() {\n    core_util_critical_section_enter();\n    _time += slicetime();\n    if (_running) {\n        if(_lock_deepsleep) {\n            sleep_manager_unlock_deep_sleep();\n        }\n    }\n    _running = 0;\n    core_util_critical_section_exit();\n}\n\nint Timer::read_us() {\n    return read_high_resolution_us();\n}\n\nfloat Timer::read() {\n    return (float)read_us() / 1000000.0f;\n}\n\nint Timer::read_ms() {\n    return read_high_resolution_us() / 1000;\n}\n\nus_timestamp_t Timer::read_high_resolution_us() {\n    core_util_critical_section_enter();\n    us_timestamp_t time = _time + slicetime();\n    core_util_critical_section_exit();\n    return time;\n}\n\nus_timestamp_t Timer::slicetime() {\n    us_timestamp_t ret = 0;\n    core_util_critical_section_enter();\n    if (_running) {\n        ret = ticker_read_us(_ticker_data) - _start;\n    }\n    core_util_critical_section_exit();\n    return ret;\n}\n\nvoid Timer::reset() {\n    core_util_critical_section_enter();\n    _start = ticker_read_us(_ticker_data);\n    _time = 0;\n    core_util_critical_section_exit();\n}\n\nTimer::operator float() {\n    return read();\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/TimerEvent.h\"\n#include \"cmsis.h\"\n\n#include <stddef.h>\n#include \"hal/ticker_api.h\"\n#include \"hal/us_ticker_api.h\"\n\nnamespace mbed {\n\nTimerEvent::TimerEvent() : event(), _ticker_data(get_us_ticker_data()) {\n    ticker_set_handler(_ticker_data, (&TimerEvent::irq));\n}\n\nTimerEvent::TimerEvent(const ticker_data_t *data) : event(), _ticker_data(data) {\n    ticker_set_handler(_ticker_data, (&TimerEvent::irq));\n}\n\nvoid TimerEvent::irq(uint32_t id) {\n    TimerEvent *timer_event = (TimerEvent*)id;\n    timer_event->handler();\n}\n\nTimerEvent::~TimerEvent() {\n    remove();\n}\n\n// insert in to linked list\nvoid TimerEvent::insert(timestamp_t timestamp) {\n    ticker_insert_event(_ticker_data, &event, timestamp, (uint32_t)this);\n}\n\nvoid TimerEvent::insert_absolute(us_timestamp_t timestamp) {\n    ticker_insert_event_us(_ticker_data, &event, timestamp, (uint32_t)this);\n}\n\nvoid TimerEvent::remove() {\n    ticker_remove_event(_ticker_data, &event);\n}\n\n} // namespace mbed\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"events/EventQueue.h\"\n\n#include \"events/mbed_events.h\"\n#include \"mbed.h\"\n\n\nEventQueue::EventQueue(unsigned event_size, unsigned char *event_pointer) {\n    if (!event_pointer) {\n        equeue_create(&_equeue, event_size);\n    } else {\n        equeue_create_inplace(&_equeue, event_size, event_pointer);\n    }\n}\n\nEventQueue::~EventQueue() {\n    equeue_destroy(&_equeue);\n}\n\nvoid EventQueue::dispatch(int ms) {\n    return equeue_dispatch(&_equeue, ms);\n}\n\nvoid EventQueue::break_dispatch() {\n    return equeue_break(&_equeue);\n}\n\nunsigned EventQueue::tick() {\n    return equeue_tick();\n}\n\nvoid EventQueue::cancel(int id) {\n    return equeue_cancel(&_equeue, id);\n}\n\nint EventQueue::time_left(int id) {\n    return equeue_timeleft(&_equeue, id);\n}\n\nvoid EventQueue::background(Callback<void(int)> update) {\n    _update = update;\n\n    if (_update) {\n        equeue_background(&_equeue, &Callback<void(int)>::thunk, &_update);\n    } else {\n        equeue_background(&_equeue, 0, 0);\n    }\n}\n\nvoid EventQueue::chain(EventQueue *target) {\n    if (target) {\n        equeue_chain(&_equeue, &target->_equeue);\n    } else {\n        equeue_chain(&_equeue, 0);\n    }\n}\n","/*\n * Flexible event queue for dispatching events\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue.h\"\n#include \"mbed_wait_api.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n\n// calculate the relative-difference between absolute times while\n// correctly handling overflow conditions\nstatic inline int equeue_tickdiff(unsigned a, unsigned b) {\n    return (int)(unsigned)(a - b);\n}\n\n// calculate the relative-difference between absolute times, but\n// also clamp to zero, resulting in only non-zero values.\nstatic inline int equeue_clampdiff(unsigned a, unsigned b) {\n    int diff = equeue_tickdiff(a, b);\n    return ~(diff >> (8*sizeof(int)-1)) & diff;\n}\n\n// Increment the unique id in an event, hiding the event from cancel\nstatic inline void equeue_incid(equeue_t *q, struct equeue_event *e) {\n    e->id += 1;\n    if ((e->id << q->npw2) == 0) {\n        e->id = 1;\n    }\n}\n\n\n// equeue lifetime management\nint equeue_create(equeue_t *q, size_t size) {\n    // dynamically allocate the specified buffer\n    void *buffer = malloc(size);\n    if (!buffer) {\n        return -1;\n    }\n\n    int err = equeue_create_inplace(q, size, buffer);\n    q->allocated = buffer;\n    return err;\n}\n\nint equeue_create_inplace(equeue_t *q, size_t size, void *buffer) {\n    // setup queue around provided buffer\n    q->buffer = buffer;\n    q->allocated = 0;\n\n    q->npw2 = 0;\n    for (unsigned s = size; s; s >>= 1) {\n        q->npw2++;\n    }\n\n    q->chunks = 0;\n    q->slab.size = size;\n    q->slab.data = buffer;\n\n    q->queue = 0;\n    q->tick = equeue_tick();\n    q->generation = 0;\n    q->break_requested = false;\n\n    q->background.active = false;\n    q->background.update = 0;\n    q->background.timer = 0;\n\n    q->dispatch_called = false;\n\n    // initialize platform resources\n    int err;\n    err = equeue_sema_create(&q->eventsema);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->queuelock);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->memlock);\n    if (err < 0) {\n        return err;\n    }\n\n    return 0;\n}\n\nvoid equeue_destroy(equeue_t *q) {\n    // call destructors on pending events\n    for (struct equeue_event *es = q->queue; es; es = es->next) {\n        for (struct equeue_event *e = q->queue; e; e = e->sibling) {\n            if (e->dtor) {\n                e->dtor(e + 1);\n            }\n        }\n    }\n\n    // notify background timer\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    // clean up platform resources + memory\n    equeue_mutex_destroy(&q->memlock);\n    equeue_mutex_destroy(&q->queuelock);\n    equeue_sema_destroy(&q->eventsema);\n    free(q->allocated);\n}\n\n\n// equeue chunk allocation functions\nstatic struct equeue_event *equeue_mem_alloc(equeue_t *q, size_t size) {\n#ifdef TARGET_SIMULATOR\n    // ok... so for some reason this is necessary\n    // no idea why, maybe something with blocks not actually allocated until we yield back\n    // however... only after dispatch was called the first time, not before, otherwise it hangs.\n    if (q->dispatch_called) {\n        wait_ms(10);\n    }\n#endif\n    // add event overhead\n    size += sizeof(struct equeue_event);\n    size = (size + sizeof(void*)-1) & ~(sizeof(void*)-1);\n\n    equeue_mutex_lock(&q->memlock);\n\n    // check if a good chunk is available\n    for (struct equeue_event **p = &q->chunks; *p; p = &(*p)->next) {\n        if ((*p)->size >= size) {\n            struct equeue_event *e = *p;\n            if (e->sibling) {\n                *p = e->sibling;\n                (*p)->next = e->next;\n            } else {\n                *p = e->next;\n            }\n\n            equeue_mutex_unlock(&q->memlock);\n            return e;\n        }\n    }\n\n    // otherwise allocate a new chunk out of the slab\n    if (q->slab.size >= size) {\n        struct equeue_event *e = (struct equeue_event *)q->slab.data;\n        q->slab.data += size;\n        q->slab.size -= size;\n        e->size = size;\n        e->id = 1;\n\n        equeue_mutex_unlock(&q->memlock);\n        return e;\n    }\n\n    equeue_mutex_unlock(&q->memlock);\n    return 0;\n}\n\nstatic void equeue_mem_dealloc(equeue_t *q, struct equeue_event *e) {\n    equeue_mutex_lock(&q->memlock);\n\n    // stick chunk into list of chunks\n    struct equeue_event **p = &q->chunks;\n    while (*p && (*p)->size < e->size) {\n        p = &(*p)->next;\n    }\n\n    if (*p && (*p)->size == e->size) {\n        e->sibling = *p;\n        e->next = (*p)->next;\n    } else {\n        e->sibling = 0;\n        e->next = *p;\n    }\n    *p = e;\n\n    equeue_mutex_unlock(&q->memlock);\n}\n\nvoid *equeue_alloc(equeue_t *q, size_t size) {\n    struct equeue_event *e = equeue_mem_alloc(q, size);\n    if (!e) {\n        return 0;\n    }\n\n    e->target = 0;\n    e->period = -1;\n    e->dtor = 0;\n\n    return e + 1;\n}\n\nvoid equeue_dealloc(equeue_t *q, void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n\n    if (e->dtor) {\n        e->dtor(e+1);\n    }\n\n    equeue_mem_dealloc(q, e);\n}\n\n\n// equeue scheduling functions\nstatic int equeue_enqueue(equeue_t *q, struct equeue_event *e, unsigned tick) {\n    // setup event and hash local id with buffer offset for unique id\n    int id = (e->id << q->npw2) | ((unsigned char *)e - q->buffer);\n    e->target = tick + equeue_clampdiff(e->target, tick);\n    e->generation = q->generation;\n\n    equeue_mutex_lock(&q->queuelock);\n\n    // find the event slot\n    struct equeue_event **p = &q->queue;\n    while (*p && equeue_tickdiff((*p)->target, e->target) < 0) {\n        p = &(*p)->next;\n    }\n\n    // insert at head in slot\n    if (*p && (*p)->target == e->target) {\n        e->next = (*p)->next;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = *p;\n        e->sibling->ref = &e->sibling;\n    } else {\n        e->next = *p;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = 0;\n    }\n\n    *p = e;\n    e->ref = p;\n\n    // notify background timer\n    if ((q->background.update && q->background.active) &&\n        (q->queue == e && !e->sibling)) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(e->target, tick));\n    }\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    return id;\n}\n\nstatic struct equeue_event *equeue_unqueue(equeue_t *q, int id) {\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id != id >> q->npw2) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // clear the event and check if already in-flight\n    e->cb = 0;\n    e->period = -1;\n\n    int diff = equeue_tickdiff(e->target, q->tick);\n    if (diff < 0 || (diff == 0 && e->generation != q->generation)) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // disentangle from queue\n    if (e->sibling) {\n        e->sibling->next = e->next;\n        if (e->sibling->next) {\n            e->sibling->next->ref = &e->sibling->next;\n        }\n\n        *e->ref = e->sibling;\n        e->sibling->ref = e->ref;\n    } else {\n        *e->ref = e->next;\n        if (e->next) {\n            e->next->ref = e->ref;\n        }\n    }\n\n    equeue_incid(q, e);\n    equeue_mutex_unlock(&q->queuelock);\n\n    return e;\n}\n\nstatic struct equeue_event *equeue_dequeue(equeue_t *q, unsigned target) {\n    equeue_mutex_lock(&q->queuelock);\n\n    // find all expired events and mark a new generation\n    q->generation += 1;\n    if (equeue_tickdiff(q->tick, target) <= 0) {\n        q->tick = target;\n    }\n\n    struct equeue_event *head = q->queue;\n    struct equeue_event **p = &head;\n    while (*p && equeue_tickdiff((*p)->target, target) <= 0) {\n        p = &(*p)->next;\n    }\n\n    q->queue = *p;\n    if (q->queue) {\n        q->queue->ref = &q->queue;\n    }\n\n    *p = 0;\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    // reverse and flatten each slot to match insertion order\n    struct equeue_event **tail = &head;\n    struct equeue_event *ess = head;\n    while (ess) {\n        struct equeue_event *es = ess;\n        ess = es->next;\n\n        struct equeue_event *prev = 0;\n        for (struct equeue_event *e = es; e; e = e->sibling) {\n            e->next = prev;\n            prev = e;\n        }\n\n        *tail = prev;\n        tail = &es->next;\n    }\n\n    return head;\n}\n\nint equeue_post(equeue_t *q, void (*cb)(void*), void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    unsigned tick = equeue_tick();\n    e->cb = cb;\n    e->target = tick + e->target;\n\n    int id = equeue_enqueue(q, e, tick);\n    equeue_sema_signal(&q->eventsema);\n    return id;\n}\n\nvoid equeue_cancel(equeue_t *q, int id) {\n    if (!id) {\n        return;\n    }\n\n    struct equeue_event *e = equeue_unqueue(q, id);\n    if (e) {\n        equeue_dealloc(q, e + 1);\n    }\n}\n\nint equeue_timeleft(equeue_t *q, int id) {\n    int ret = -1;\n\n    if (!id) {\n        return -1;\n    }\n\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id == id >> q->npw2) {\n        ret = equeue_clampdiff(e->target, equeue_tick());\n    }\n    equeue_mutex_unlock(&q->queuelock);\n    return ret;\n}\n\nvoid equeue_break(equeue_t *q) {\n    equeue_mutex_lock(&q->queuelock);\n    q->break_requested = true;\n    equeue_mutex_unlock(&q->queuelock);\n    equeue_sema_signal(&q->eventsema);\n}\n\nvoid equeue_dispatch(equeue_t *q, int ms) {\n#ifdef TARGET_SIMULATOR\n    if (!q->dispatch_called) {\n        q->dispatch_called = true;\n    }\n#endif\n\n    unsigned tick = equeue_tick();\n    unsigned timeout = tick + ms;\n    q->background.active = false;\n\n    while (1) {\n        // collect all the available events and next deadline\n        struct equeue_event *es = equeue_dequeue(q, tick);\n\n        // dispatch events\n        while (es) {\n            struct equeue_event *e = es;\n            es = e->next;\n\n            // actually dispatch the callbacks\n            void (*cb)(void *) = e->cb;\n            if (cb) {\n                cb(e + 1);\n            }\n\n            // reenqueue periodic events or deallocate\n            if (e->period >= 0) {\n                e->target += e->period;\n                equeue_enqueue(q, e, equeue_tick());\n            } else {\n                equeue_incid(q, e);\n                equeue_dealloc(q, e+1);\n            }\n        }\n\n        int deadline = -1;\n        tick = equeue_tick();\n\n        // check if we should stop dispatching soon\n        if (ms >= 0) {\n            deadline = equeue_tickdiff(timeout, tick);\n            if (deadline <= 0) {\n                // update background timer if necessary\n                if (q->background.update) {\n                    equeue_mutex_lock(&q->queuelock);\n                    if (q->background.update && q->queue) {\n                        q->background.update(q->background.timer,\n                                equeue_clampdiff(q->queue->target, tick));\n                    }\n                    q->background.active = true;\n                    equeue_mutex_unlock(&q->queuelock);\n                }\n                q->break_requested = false;\n                return;\n            }\n        }\n\n        // find closest deadline\n        equeue_mutex_lock(&q->queuelock);\n        if (q->queue) {\n            int diff = equeue_clampdiff(q->queue->target, tick);\n            if ((unsigned)diff < (unsigned)deadline) {\n                deadline = diff;\n            }\n        }\n        equeue_mutex_unlock(&q->queuelock);\n\n        // wait for events\n        equeue_sema_wait(&q->eventsema, deadline);\n\n        // check if we were notified to break out of dispatch\n        if (q->break_requested) {\n            equeue_mutex_lock(&q->queuelock);\n            if (q->break_requested) {\n                q->break_requested = false;\n                equeue_mutex_unlock(&q->queuelock);\n                return;\n            }\n            equeue_mutex_unlock(&q->queuelock);\n        }\n\n        // update tick for next iteration\n        tick = equeue_tick();\n\n#ifdef TARGET_SIMULATOR\n        // yield back to browser in between to process events\n        wait_ms(20);\n#endif\n    }\n}\n\n\n// event functions\nvoid equeue_event_delay(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->target = ms;\n}\n\nvoid equeue_event_period(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->period = ms;\n}\n\nvoid equeue_event_dtor(void *p, void (*dtor)(void *)) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->dtor = dtor;\n}\n\n\n// simple callbacks\nstruct ecallback {\n    void (*cb)(void*);\n    void *data;\n};\n\nstatic void ecallback_dispatch(void *p) {\n    struct ecallback *e = (struct ecallback*)p;\n    e->cb(e->data);\n}\n\nint equeue_call(equeue_t *q, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_in(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_every(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    equeue_event_period(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\n\n// backgrounding\nvoid equeue_background(equeue_t *q,\n        void (*update)(void *timer, int ms), void *timer) {\n    equeue_mutex_lock(&q->queuelock);\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    q->background.update = update;\n    q->background.timer = timer;\n\n    if (q->background.update && q->queue) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(q->queue->target, equeue_tick()));\n    }\n    q->background.active = true;\n    equeue_mutex_unlock(&q->queuelock);\n}\n\nstruct equeue_chain_context {\n    equeue_t *q;\n    equeue_t *target;\n    int id;\n};\n\nstatic void equeue_chain_dispatch(void *p) {\n    equeue_dispatch((equeue_t *)p, 0);\n}\n\nstatic void equeue_chain_update(void *p, int ms) {\n    struct equeue_chain_context *c = (struct equeue_chain_context *)p;\n    equeue_cancel(c->target, c->id);\n\n    if (ms >= 0) {\n        c->id = equeue_call_in(c->target, ms, equeue_chain_dispatch, c->q);\n    } else {\n        equeue_dealloc(c->target, c);\n    }\n}\n\nvoid equeue_chain(equeue_t *q, equeue_t *target) {\n    if (!target) {\n        equeue_background(q, 0, 0);\n        return;\n    }\n\n    struct equeue_chain_context *c = equeue_alloc(q,\n            sizeof(struct equeue_chain_context));\n\n    c->q = q;\n    c->target = target;\n    c->id = 0;\n\n    equeue_background(q, equeue_chain_update, c);\n}\n","/*\n * Implementation for Posix compliant platforms\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue_platform.h\"\n\n#if defined(EQUEUE_PLATFORM_POSIX)\n\n#include <time.h>\n#include <sys/time.h>\n#include <errno.h>\n\n\n// Tick operations\nunsigned equeue_tick(void) {\n    struct timeval tv;\n    gettimeofday(&tv, 0);\n    return (unsigned)(tv.tv_sec*1000 + tv.tv_usec/1000);\n}\n\n\n// Mutex operations\nint equeue_mutex_create(equeue_mutex_t *m) {\n    return pthread_mutex_init(m, 0);\n}\n\nvoid equeue_mutex_destroy(equeue_mutex_t *m) {\n    pthread_mutex_destroy(m);\n}\n\nvoid equeue_mutex_lock(equeue_mutex_t *m) {\n    pthread_mutex_lock(m);\n}\n\nvoid equeue_mutex_unlock(equeue_mutex_t *m) {\n    pthread_mutex_unlock(m);\n}\n\n\n// Semaphore operations\nint equeue_sema_create(equeue_sema_t *s) {\n    int err = pthread_mutex_init(&s->mutex, 0);\n    if (err) {\n        return err;\n    }\n\n    err = pthread_cond_init(&s->cond, 0);\n    if (err) {\n        return err;\n    }\n\n    s->signal = false;\n    return 0;\n}\n\nvoid equeue_sema_destroy(equeue_sema_t *s) {\n    pthread_cond_destroy(&s->cond);\n    pthread_mutex_destroy(&s->mutex);\n}\n\nvoid equeue_sema_signal(equeue_sema_t *s) {\n    pthread_mutex_lock(&s->mutex);\n    s->signal = true;\n    pthread_cond_signal(&s->cond);\n    pthread_mutex_unlock(&s->mutex);\n}\n\nbool equeue_sema_wait(equeue_sema_t *s, int ms) {\n    pthread_mutex_lock(&s->mutex);\n    if (!s->signal) {\n        if (ms < 0) {\n            pthread_cond_wait(&s->cond, &s->mutex);\n        } else {\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n\n            struct timespec ts = {\n                .tv_sec = ms/1000 + tv.tv_sec,\n                .tv_nsec = ms*1000000 + tv.tv_usec*1000,\n            };\n\n            pthread_cond_timedwait(&s->cond, &s->mutex, &ts);\n        }\n    }\n\n    bool signal = s->signal;\n    s->signal = false;\n    pthread_mutex_unlock(&s->mutex);\n\n    return signal;\n}\n\n#endif\n","/*\n * Copyright (c) 2014-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#ifdef MBED_CONF_MBED_TRACE_ENABLE\n#undef MBED_CONF_MBED_TRACE_ENABLE\n#endif\n#define MBED_CONF_MBED_TRACE_ENABLE 1\n#ifndef MBED_CONF_MBED_TRACE_FEA_IPV6\n#define MBED_CONF_MBED_TRACE_FEA_IPV6 1\n#endif\n\n#include \"mbed-trace/mbed_trace.h\"\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\n#include \"mbed-client-libservice/ip6string.h\"\n#include \"mbed-client-libservice/common_functions.h\"\n#endif\n\n#if defined(YOTTA_CFG_MBED_TRACE_MEM)\n#define MBED_TRACE_MEM_INCLUDE      YOTTA_CFG_MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_ALLOC        YOTTA_CFG_MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_FREE         YOTTA_CFG_MBED_TRACE_MEM_FREE\n#else /* YOTTA_CFG_MEMLIB */\n// Default options\n#ifndef MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_INCLUDE   <stdlib.h>\n#endif\n#include MBED_TRACE_MEM_INCLUDE\n#ifndef MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_ALLOC malloc\n#endif\n#ifndef MBED_TRACE_MEM_FREE\n#define MBED_TRACE_MEM_FREE  free\n#endif\n#endif /* YOTTA_CFG_MEMLIB */\n\n#define VT100_COLOR_ERROR \"\\x1b[31m\"\n#define VT100_COLOR_WARN  \"\\x1b[33m\"\n#define VT100_COLOR_INFO  \"\\x1b[39m\"\n#define VT100_COLOR_DEBUG \"\\x1b[90m\"\n\n/** default max trace line size in bytes */\n#ifdef MBED_TRACE_LINE_LENGTH\n#define DEFAULT_TRACE_LINE_LENGTH         MBED_TRACE_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#warning YOTTA_CFG_MBED_TRACE_LINE_LENGTH is deprecated and will be removed in the future! Use MBED_TRACE_LINE_LENGTH instead.\n#define DEFAULT_TRACE_LINE_LENGTH         YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#else\n#define DEFAULT_TRACE_LINE_LENGTH         1024\n#endif\n\n/** default max temporary buffer size in bytes, used in\n    trace_ipv6, trace_ipv6_prefix and trace_array */\n#ifdef MBED_TRACE_TMP_LINE_LENGTH\n#define DEFAULT_TRACE_TMP_LINE_LEN        MBED_TRACE_TMP_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#elif defined YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MTRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#else\n#define DEFAULT_TRACE_TMP_LINE_LEN        128\n#endif\n\n/** default max filters (include/exclude) length in bytes */\n#ifdef MBED_TRACE_FILTER_LENGTH\n#define DEFAULT_TRACE_FILTER_LENGTH       MBED_TRACE_FILTER_LENGTH\n#else\n#define DEFAULT_TRACE_FILTER_LENGTH       24\n#endif\n\n/** default trace configuration bitmask */\n#ifdef MBED_TRACE_CONFIG\n#define DEFAULT_TRACE_CONFIG              MBED_TRACE_CONFIG\n#else\n#define DEFAULT_TRACE_CONFIG              TRACE_MODE_COLOR | TRACE_ACTIVE_LEVEL_ALL | TRACE_CARRIAGE_RETURN\n#endif\n\n/** default print function, just redirect str to printf */\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length);\nstatic void mbed_trace_default_print(const char *str);\nstatic void mbed_trace_reset_tmp(void);\n\ntypedef struct trace_s {\n    /** trace configuration bits */\n    uint8_t trace_config;\n    /** exclude filters list, related group name */\n    char *filters_exclude;\n    /** include filters list, related group name */\n    char *filters_include;\n    /** Filters length */\n    int filters_length;\n    /** trace line */\n    char *line;\n    /** trace line length */\n    int line_length;\n    /** temporary data */\n    char *tmp_data;\n    /** temporary data array length */\n    int tmp_data_length;\n    /** temporary data pointer */\n    char *tmp_data_ptr;\n\n    /** prefix function, which can be used to put time to the trace line */\n    char *(*prefix_f)(size_t);\n    /** suffix function, which can be used to some string to the end of trace line */\n    char *(*suffix_f)(void);\n    /** print out function. Can be redirect to flash for example. */\n    void (*printf)(const char *);\n    /** print out function for TRACE_LEVEL_CMD */\n    void (*cmd_printf)(const char *);\n    /** mutex wait function which can be called to lock against a mutex. */\n    void (*mutex_wait_f)(void);\n    /** mutex release function which must be used to release the mutex locked by mutex_wait_f. */\n    void (*mutex_release_f)(void);\n    /** number of times the mutex has been locked */\n    int mutex_lock_count;\n} trace_t;\n\nstatic trace_t m_trace = {\n    .trace_config = DEFAULT_TRACE_CONFIG,\n    .filters_exclude = 0,\n    .filters_include = 0,\n    .filters_length = DEFAULT_TRACE_FILTER_LENGTH,\n    .line = 0,\n    .line_length = DEFAULT_TRACE_LINE_LENGTH,\n    .tmp_data = 0,\n    .tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN,\n    .prefix_f = 0,\n    .suffix_f = 0,\n    .printf  = mbed_trace_default_print,\n    .cmd_printf = 0,\n    .mutex_wait_f = 0,\n    .mutex_release_f = 0,\n    .mutex_lock_count = 0\n};\n\nint mbed_trace_init(void)\n{\n    if (m_trace.line == NULL) {\n        m_trace.line = MBED_TRACE_MEM_ALLOC(m_trace.line_length);\n    }\n\n    if (m_trace.tmp_data == NULL) {\n        m_trace.tmp_data = MBED_TRACE_MEM_ALLOC(m_trace.tmp_data_length);\n    }\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n\n    if (m_trace.filters_exclude == NULL) {\n        m_trace.filters_exclude = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n    if (m_trace.filters_include == NULL) {\n        m_trace.filters_include = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n\n    if (m_trace.line == NULL ||\n            m_trace.tmp_data == NULL ||\n            m_trace.filters_exclude == NULL  ||\n            m_trace.filters_include == NULL) {\n        //memory allocation fail\n        mbed_trace_free();\n        return -1;\n    }\n    memset(m_trace.tmp_data, 0, m_trace.tmp_data_length);\n    memset(m_trace.filters_exclude, 0, m_trace.filters_length);\n    memset(m_trace.filters_include, 0, m_trace.filters_length);\n    memset(m_trace.line, 0, m_trace.line_length);\n\n    return 0;\n}\nvoid mbed_trace_free(void)\n{\n    // release memory\n    MBED_TRACE_MEM_FREE(m_trace.line);\n    MBED_TRACE_MEM_FREE(m_trace.tmp_data);\n    MBED_TRACE_MEM_FREE(m_trace.filters_exclude);\n    MBED_TRACE_MEM_FREE(m_trace.filters_include);\n\n    // reset to default values\n    m_trace.trace_config = DEFAULT_TRACE_CONFIG;\n    m_trace.filters_exclude = 0;\n    m_trace.filters_include = 0;\n    m_trace.filters_length = DEFAULT_TRACE_FILTER_LENGTH;\n    m_trace.line = 0;\n    m_trace.line_length = DEFAULT_TRACE_LINE_LENGTH;\n    m_trace.tmp_data = 0;\n    m_trace.tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN;\n    m_trace.prefix_f = 0;\n    m_trace.suffix_f = 0;\n    m_trace.printf  = mbed_trace_default_print;\n    m_trace.cmd_printf = 0;\n    m_trace.mutex_wait_f = 0;\n    m_trace.mutex_release_f = 0;\n    m_trace.mutex_lock_count = 0;\n}\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length)\n{\n    MBED_TRACE_MEM_FREE(*buffer);\n    *buffer  = MBED_TRACE_MEM_ALLOC(new_length);\n    *length_ptr = new_length;\n}\nvoid mbed_trace_buffer_sizes(int lineLength, int tmpLength)\n{\n    if( lineLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.line), &m_trace.line_length, lineLength );\n    }\n    if( tmpLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.tmp_data), &m_trace.tmp_data_length, tmpLength);\n        mbed_trace_reset_tmp();\n    }\n}\nvoid mbed_trace_config_set(uint8_t config)\n{\n    m_trace.trace_config = config;\n}\nuint8_t mbed_trace_config_get(void)\n{\n    return m_trace.trace_config;\n}\nvoid mbed_trace_prefix_function_set(char *(*pref_f)(size_t))\n{\n    m_trace.prefix_f = pref_f;\n}\nvoid mbed_trace_suffix_function_set(char *(*suffix_f)(void))\n{\n    m_trace.suffix_f = suffix_f;\n}\nvoid mbed_trace_print_function_set(void (*printf)(const char *))\n{\n    m_trace.printf = printf;\n}\nvoid mbed_trace_cmdprint_function_set(void (*printf)(const char *))\n{\n    m_trace.cmd_printf = printf;\n}\nvoid mbed_trace_mutex_wait_function_set(void (*mutex_wait_f)(void))\n{\n    m_trace.mutex_wait_f = mutex_wait_f;\n}\nvoid mbed_trace_mutex_release_function_set(void (*mutex_release_f)(void))\n{\n    m_trace.mutex_release_f = mutex_release_f;\n}\nvoid mbed_trace_exclude_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_exclude, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_exclude[0] = 0;\n    }\n}\nconst char *mbed_trace_exclude_filters_get(void)\n{\n    return m_trace.filters_exclude;\n}\nconst char *mbed_trace_include_filters_get(void)\n{\n    return m_trace.filters_include;\n}\nvoid mbed_trace_include_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_include, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_include[0] = 0;\n    }\n}\nstatic int8_t mbed_trace_skip(int8_t dlevel, const char *grp)\n{\n    if (dlevel >= 0 && grp != 0) {\n        // filter debug prints only when dlevel is >0 and grp is given\n\n        /// @TODO this could be much better..\n        if (m_trace.filters_exclude[0] != '\\0' &&\n                strstr(m_trace.filters_exclude, grp) != 0) {\n            //grp was in exclude list\n            return 1;\n        }\n        if (m_trace.filters_include[0] != '\\0' &&\n                strstr(m_trace.filters_include, grp) == 0) {\n            //grp was in include list\n            return 1;\n        }\n    }\n    return 0;\n}\nstatic void mbed_trace_default_print(const char *str)\n{\n    puts(str);\n}\nvoid mbed_tracef(uint8_t dlevel, const char *grp, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    mbed_vtracef(dlevel, grp, fmt, ap);\n    va_end(ap);\n}\nvoid mbed_vtracef(uint8_t dlevel, const char* grp, const char *fmt, va_list ap)\n{\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n\n    if (NULL == m_trace.line) {\n        goto end;\n    }\n\n    m_trace.line[0] = 0; //by default trace is empty\n\n    if (mbed_trace_skip(dlevel, grp) || fmt == 0 || grp == 0 || !m_trace.printf) {\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n        goto end;\n    }\n    if ((m_trace.trace_config & TRACE_MASK_LEVEL) &  dlevel) {\n        bool color = (m_trace.trace_config & TRACE_MODE_COLOR) != 0;\n        bool plain = (m_trace.trace_config & TRACE_MODE_PLAIN) != 0;\n        bool cr    = (m_trace.trace_config & TRACE_CARRIAGE_RETURN) != 0;\n\n        int retval = 0, bLeft = m_trace.line_length;\n        char *ptr = m_trace.line;\n        if (plain == true || dlevel == TRACE_LEVEL_CMD) {\n            //add trace data\n            retval = vsnprintf(ptr, bLeft, fmt, ap);\n            if (dlevel == TRACE_LEVEL_CMD && m_trace.cmd_printf) {\n                m_trace.cmd_printf(m_trace.line);\n                m_trace.cmd_printf(\"\\n\");\n            } else {\n                //print out whole data\n                m_trace.printf(m_trace.line);\n            }\n        } else {\n            if (color) {\n                if (cr) {\n                    retval = snprintf(ptr, bLeft, \"\\r\\x1b[2K\");\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n                if (bLeft > 0) {\n                    //include color in ANSI/VT100 escape code\n                    switch (dlevel) {\n                        case (TRACE_LEVEL_ERROR):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_ERROR);\n                            break;\n                        case (TRACE_LEVEL_WARN):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_WARN);\n                            break;\n                        case (TRACE_LEVEL_INFO):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_INFO);\n                            break;\n                        case (TRACE_LEVEL_DEBUG):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_DEBUG);\n                            break;\n                        default:\n                            color = 0; //avoid unneeded color-terminate code\n                            retval = 0;\n                            break;\n                    }\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0 && color) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n\n            }\n            if (bLeft > 0 && m_trace.prefix_f) {\n                //find out length of body\n                size_t sz = 0;\n                va_list ap2;\n                va_copy(ap2, ap);\n                sz = vsnprintf(NULL, 0, fmt, ap2) + retval + (retval ? 4 : 0);\n                va_end(ap2);\n                //add prefix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.prefix_f(sz));\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (bLeft > 0) {\n                //add group tag\n                switch (dlevel) {\n                    case (TRACE_LEVEL_ERROR):\n                        retval = snprintf(ptr, bLeft, \"[ERR ][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_WARN):\n                        retval = snprintf(ptr, bLeft, \"[WARN][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_INFO):\n                        retval = snprintf(ptr, bLeft, \"[INFO][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_DEBUG):\n                        retval = snprintf(ptr, bLeft, \"[DBG ][%-4s]: \", grp);\n                        break;\n                    default:\n                        retval = snprintf(ptr, bLeft, \"              \");\n                        break;\n                }\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (retval > 0 && bLeft > 0) {\n                //add trace text\n                retval = vsnprintf(ptr, bLeft, fmt, ap);\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && m_trace.suffix_f) {\n                //add suffix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.suffix_f());\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && color) {\n                //add zero color VT100 when color mode\n                retval = snprintf(ptr, bLeft, \"\\x1b[0m\");\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    // not used anymore\n                    //ptr += retval;\n                    //bLeft -= retval;\n                }\n            }\n            //print out whole data\n            m_trace.printf(m_trace.line);\n        }\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n    }\n\nend:\n    if ( m_trace.mutex_release_f ) {\n        // Store the mutex lock count to temp variable so that it won't get\n        // clobbered during last loop iteration when mutex gets released\n        int count = m_trace.mutex_lock_count;\n        m_trace.mutex_lock_count = 0;\n        // Since the helper functions (eg. mbed_trace_array) are used like this:\n        //   mbed_tracef(TRACE_LEVEL_INFO, \"grp\", \"%s\", mbed_trace_array(some_array))\n        // The helper function MUST acquire the mutex if it modifies any buffers. However\n        // it CANNOT unlock the mutex because that would allow another thread to acquire\n        // the mutex after helper function unlocks it and before mbed_tracef acquires it\n        // for itself. This means that here we have to unlock the mutex as many times\n        // as it was acquired by trace function and any possible helper functions.\n        do {\n            m_trace.mutex_release_f();\n        } while (--count > 0);\n    }\n}\nstatic void mbed_trace_reset_tmp(void)\n{\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n}\nconst char *mbed_trace_last(void)\n{\n    return m_trace.line;\n}\n/* Helping functions */\n#define tmp_data_left()  m_trace.tmp_data_length-(m_trace.tmp_data_ptr-m_trace.tmp_data)\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\nchar *mbed_trace_ipv6(const void *addr_ptr)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 41) {\n        return \"\";\n    }\n    if (addr_ptr == NULL) {\n        return \"<null>\";\n    }\n    str[0] = 0;\n    m_trace.tmp_data_ptr += ip6tos(addr_ptr, str) + 1;\n    return str;\n}\nchar *mbed_trace_ipv6_prefix(const uint8_t *prefix, uint8_t prefix_len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 45) {\n        return \"\";\n    }\n\n    if ((prefix_len != 0 && prefix == NULL) || prefix_len > 128) {\n        return \"<err>\";\n    }\n\n    m_trace.tmp_data_ptr += ip6_prefix_tos(prefix, prefix_len, str) + 1;\n    return str;\n}\n#endif //MBED_CONF_MBED_TRACE_FEA_IPV6\nchar *mbed_trace_array(const uint8_t *buf, uint16_t len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    int i, bLeft = tmp_data_left();\n    char *str, *wptr;\n    str = m_trace.tmp_data_ptr;\n    if (len == 0 || str == NULL || bLeft == 0) {\n        return \"\";\n    }\n    if (buf == NULL) {\n        return \"<null>\";\n    }\n    wptr = str;\n    wptr[0] = 0;\n    const uint8_t *ptr = buf;\n    char overflow = 0;\n    for (i = 0; i < len; i++) {\n        if (bLeft <= 3) {\n            overflow = 1;\n            break;\n        }\n        int retval = snprintf(wptr, bLeft, \"%02x:\", *ptr++);\n        if (retval <= 0 || retval > bLeft) {\n            break;\n        }\n        bLeft -= retval;\n        wptr += retval;\n    }\n    if (wptr > str) {\n        if( overflow ) {\n            // replace last character as 'star',\n            // which indicate buffer len is not enough\n            *(wptr - 1) = '*';\n        } else {\n            //null to replace last ':' character\n            *(wptr - 1) = 0;\n        }\n    }\n    m_trace.tmp_data_ptr = wptr;\n    return str;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALOUT_H\n#define MBED_DIGITALOUT_H\n\n#include \"platform/platform.h\"\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital output, used for setting the state of a pin\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle a LED\n * #include \"mbed.h\"\n *\n * DigitalOut led(LED1);\n *\n * int main() {\n *     while(1) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass DigitalOut {\n\npublic:\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     */\n    DigitalOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out(&gpio, pin);\n    }\n\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     *  @param value the initial pin value\n     */\n    DigitalOut(PinName pin, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out_ex(&gpio, pin, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin,\n     *    0 for logical 0, 1 for logical 1\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (DigitalOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALINOUT_H\n#define MBED_DIGITALINOUT_H\n\n#include \"platform/platform.h\"\n\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital input/output, used for setting or reading a bi-directional pin\n *\n * @note Synchronization level: Interrupt safe\n * @ingroup drivers\n */\nclass DigitalInOut {\n\npublic:\n    /** Create a DigitalInOut connected to the specified pin\n     *\n     *  @param pin DigitalInOut pin to connect to\n     */\n    DigitalInOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_in(&gpio, pin);\n    }\n\n    /** Create a DigitalInOut connected to the specified pin\n     *\n     *  @param pin DigitalInOut pin to connect to\n     *  @param direction the initial direction of the pin\n     *  @param mode the initial mode of the pin\n     *  @param value the initial value of the pin if is an output\n     */\n    DigitalInOut(PinName pin, PinDirection direction, PinMode mode, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_inout(&gpio, pin, direction, mode, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin if it is an output,\n     *    or read the input if set as an input\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Set as an output\n     */\n    void output() {\n        core_util_critical_section_enter();\n        gpio_dir(&gpio, PIN_OUTPUT);\n        core_util_critical_section_exit();\n    }\n\n    /** Set as an input\n     */\n    void input() {\n        core_util_critical_section_enter();\n        gpio_dir(&gpio, PIN_INPUT);\n        core_util_critical_section_exit();\n    }\n\n    /** Set the input pin mode\n     *\n     *  @param pull PullUp, PullDown, PullNone, OpenDrain\n     */\n    void mode(PinMode pull) {\n        core_util_critical_section_enter();\n        gpio_mode(&gpio, pull);\n        core_util_critical_section_exit();\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalInOut::write()\n     */\n    DigitalInOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalInOut::write()\n     */\n    DigitalInOut& operator= (DigitalInOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalInOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/**\n * @file\n *\n * @brief      Implementation of LoRaWANBase\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"LoRaWANInterface.h\"\n\nusing namespace events;\n\nLoRaWANInterface::LoRaWANInterface(LoRaRadio &radio)\n{\n    _lw_stack.bind_radio_driver(radio);\n}\n\nLoRaWANInterface::~LoRaWANInterface()\n{\n}\n\nlorawan_status_t LoRaWANInterface::initialize(EventQueue *queue)\n{\n    Lock lock(*this);\n    return _lw_stack.initialize_mac_layer(queue);\n}\n\nlorawan_status_t LoRaWANInterface::connect()\n{\n    Lock lock(*this);\n    return _lw_stack.connect();\n}\n\nlorawan_status_t LoRaWANInterface::connect(const lorawan_connect_t &connect)\n{\n    Lock lock(*this);\n    return _lw_stack.connect(connect);\n}\n\nlorawan_status_t LoRaWANInterface::disconnect()\n{\n    Lock lock(*this);\n    return _lw_stack.shutdown();\n}\n\nlorawan_status_t LoRaWANInterface::add_link_check_request()\n{\n    Lock lock(*this);\n    return _lw_stack.set_link_check_request();\n}\n\nvoid LoRaWANInterface::remove_link_check_request()\n{\n    Lock lock(*this);\n    _lw_stack.remove_link_check_request();\n}\n\nlorawan_status_t LoRaWANInterface::set_datarate(uint8_t data_rate)\n{\n    Lock lock(*this);\n    return _lw_stack.set_channel_data_rate(data_rate);\n}\n\nlorawan_status_t LoRaWANInterface::set_confirmed_msg_retries(uint8_t count)\n{\n    Lock lock(*this);\n    return _lw_stack.set_confirmed_msg_retry(count);\n}\n\nlorawan_status_t LoRaWANInterface::enable_adaptive_datarate()\n{\n    Lock lock(*this);\n    return _lw_stack.enable_adaptive_datarate(true);\n}\n\nlorawan_status_t LoRaWANInterface::disable_adaptive_datarate()\n{\n    Lock lock(*this);\n    return _lw_stack.enable_adaptive_datarate(false);\n}\n\nlorawan_status_t LoRaWANInterface::set_channel_plan(const lorawan_channelplan_t &channel_plan)\n{\n    Lock lock(*this);\n    return _lw_stack.add_channels(channel_plan);\n}\n\nlorawan_status_t LoRaWANInterface::get_channel_plan(lorawan_channelplan_t &channel_plan)\n{\n    Lock lock(*this);\n    return _lw_stack.get_enabled_channels(channel_plan);\n}\n\nlorawan_status_t LoRaWANInterface::remove_channel(uint8_t id)\n{\n    Lock lock(*this);\n    return _lw_stack.remove_a_channel(id);\n}\n\nlorawan_status_t LoRaWANInterface::remove_channel_plan()\n{\n    Lock lock(*this);\n    return _lw_stack.drop_channel_list();\n}\n\nint16_t LoRaWANInterface::send(uint8_t port, const uint8_t *data, uint16_t length, int flags)\n{\n    Lock lock(*this);\n    return _lw_stack.handle_tx(port, data, length, flags);\n}\n\nlorawan_status_t LoRaWANInterface::cancel_sending(void)\n{\n    Lock lock(*this);\n    return _lw_stack.stop_sending();\n}\n\nlorawan_status_t LoRaWANInterface::get_tx_metadata(lorawan_tx_metadata &metadata)\n{\n    Lock lock(*this);\n    return _lw_stack.acquire_tx_metadata(metadata);\n}\n\nlorawan_status_t LoRaWANInterface::get_rx_metadata(lorawan_rx_metadata &metadata)\n{\n    Lock lock(*this);\n    return _lw_stack.acquire_rx_metadata(metadata);\n}\n\nlorawan_status_t LoRaWANInterface::get_backoff_metadata(int &backoff)\n{\n    Lock lock(*this);\n    return _lw_stack.acquire_backoff_metadata(backoff);\n}\n\nint16_t LoRaWANInterface::receive(uint8_t port, uint8_t *data, uint16_t length, int flags)\n{\n    Lock lock(*this);\n    return _lw_stack.handle_rx(data, length, port, flags, true);\n}\n\nint16_t LoRaWANInterface::receive(uint8_t *data, uint16_t length, uint8_t &port, int &flags)\n{\n    Lock lock(*this);\n    return _lw_stack.handle_rx(data, length, port, flags, false);\n}\n\nlorawan_status_t LoRaWANInterface::add_app_callbacks(lorawan_app_callbacks_t *callbacks)\n{\n    Lock lock(*this);\n    return _lw_stack.set_lora_callbacks(callbacks);\n}\n\nlorawan_status_t LoRaWANInterface::set_device_class(const device_class_t device_class)\n{\n    Lock lock(*this);\n    return _lw_stack.set_device_class(device_class);\n}\n","/**\n * \\file      LoRaWANStack.h\n *\n * \\brief     LoRaWAN stack layer implementation\n *\n * \\copyright Revised BSD License, see LICENSE.TXT file include in the project\n *\n * \\code\n *                ______                              _\n *               / _____)             _              | |\n *              ( (____  _____ ____ _| |_ _____  ____| |__\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *               _____) ) ____| | | || |_| ____( (___| | | |\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *              (C)2013 Semtech\n *\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n *              embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n * \\author    Miguel Luis ( Semtech )\n *\n * \\author    Gregory Cristian ( Semtech )\n *\n * \\author    Daniel Jaeckle ( STACKFORCE )\n *\n * \\defgroup  LoRaWAN stack layer that controls MAC layer underneath\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n *\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n#ifndef LORAWANSTACK_H_\n#define LORAWANSTACK_H_\n\n#include <stdint.h>\n#include \"events/EventQueue.h\"\n#include \"platform/Callback.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/ScopedLock.h\"\n\n#include \"lorastack/mac/LoRaMac.h\"\n#include \"system/LoRaWANTimer.h\"\n#include \"system/lorawan_data_structures.h\"\n#include \"LoRaRadio.h\"\n\nclass LoRaWANStack: private mbed::NonCopyable<LoRaWANStack> {\n\npublic:\n    LoRaWANStack();\n\n    /** Binds radio driver to PHY layer.\n     *\n     * MAC layer is totally detached from the PHY layer so the stack layer\n     * needs to play the role of an arbitrator. This API gets a radio driver\n     * object from the application (via LoRaWANInterface), binds it to the PHY\n     * layer and initialises radio callback handles which the radio driver will\n     * use in order to report events.\n     *\n     * @param radio            LoRaRadio object, i.e., the radio driver\n     *\n     */\n    void bind_radio_driver(LoRaRadio &radio);\n\n    /** End device initialization.\n     * @param queue            A pointer to an EventQueue passed from the application.\n     * @return                 LORAWAN_STATUS_OK on success, a negative error code on failure.\n     */\n    lorawan_status_t initialize_mac_layer(events::EventQueue *queue);\n\n    /** Sets all callbacks for the application.\n     *\n     * @param callbacks        A pointer to the structure carrying callbacks.\n     * @return                 LORAWAN_STATUS_OK on success, a negative error code on failure.\n     */\n    lorawan_status_t set_lora_callbacks(const lorawan_app_callbacks_t *callbacks);\n\n    /** Connect OTAA or ABP using Mbed-OS config system\n     *\n     * Connect by Over The Air Activation or Activation By Personalization.\n     * You need to configure the connection properly via the Mbed OS configuration\n     * system.\n     *\n     * When connecting via OTAA, the return code for success (LORAWAN_STATUS_CONNECT_IN_PROGRESS) is negative.\n     * However, this is not a real error. It tells you that the connection is in progress and you will\n     * be notified of the completion via an event. By default, after the Join Accept message\n     * is received, base stations may provide the node with a CF-List that replaces\n     * all user-configured channels except the Join/Default channels. A CF-List can\n     * configure a maximum of five channels other than the default channels.\n     *\n     * In case of ABP, the CONNECTED event is posted before the call to `connect()` returns.\n     * To configure more channels, we recommend that you use the `set_channel_plan()` API after the connection.\n     * By default, the PHY layers configure only the mandatory Join channels. The retransmission back-off restrictions\n     * on these channels are severe and you may experience long delays or even failures in the confirmed traffic.\n     * If you add more channels, the aggregated duty cycle becomes much more relaxed as compared to the Join (default) channels only.\n     *\n     * **NOTES ON RECONNECTION:**\n     * Currently, the Mbed OS LoRaWAN implementation does not support non-volatile\n     * memory storage. Therefore, the state and frame counters cannot be restored after\n     * a power cycle. However, if you use the `disconnect()` API to shut down the LoRaWAN\n     * protocol, the state and frame counters are saved. Connecting again would try to\n     * restore the previous session. According to the LoRaWAN 1.0.2 specification, the frame counters are always reset\n     * to zero for OTAA and a new Join request lets the network server know\n     * that the counters need a reset. The same is said about the ABP but there\n     * is no way to convey this information to the network server. For a network\n     * server, an ABP device is always connected. That's why storing the frame counters\n     * is important, at least for ABP. That's why we try to restore frame counters from\n     * session information after a disconnection.\n     *\n     * @return         LORAWAN_STATUS_OK or LORAWAN_STATUS_CONNECT_IN_PROGRESS\n     *                 on success, or a negative error code on failure.\n     */\n    lorawan_status_t connect();\n\n    /** Connect OTAA or ABP with parameters\n     *\n     * All connection parameters are chosen by the user and provided in the\n     * data structure passed down.\n     *\n     * When connecting via OTAA, the return code for success (LORAWAN_STATUS_CONNECT_IN_PROGRESS) is negative.\n     * However, this is not a real error. It tells you that connection is in progress and you will\n     * be notified of completion via an event. By default, after Join Accept message\n     * is received, base stations may provide the node with a CF-List which replaces\n     * all user-configured channels except the Join/Default channels. A CF-List can\n     * configure a maximum of five channels other than the default channels.\n     *\n     * In case of ABP, the CONNECTED event is posted before the call to `connect()` returns.\n     * To configure more channels, we recommend that you use the `set_channel_plan()` API after the connection.\n     * By default, the PHY layers configure only the mandatory Join\n     * channels. The retransmission back-off restrictions on these channels\n     * are severe and you may experience long delays or even\n     * failures in the confirmed traffic. If you add more channels, the aggregated duty\n     * cycle becomes much more relaxed as compared to the Join (default) channels only.\n     *\n     * **NOTES ON RECONNECTION:**\n     * Currently, the Mbed OS LoRaWAN implementation does not support non-volatile\n     * memory storage. Therefore, the state and frame counters cannot be restored after\n     * a power cycle. However, if you use the `disconnect()` API to shut down the LoRaWAN\n     * protocol, the state and frame counters are saved. Connecting again would try to\n     * restore the previous session. According to the LoRaWAN 1.0.2 specification, the frame counters are always reset\n     * to zero for OTAA and a new Join request lets the network server know\n     * that the counters need a reset. The same is said about the ABP but there\n     * is no way to convey this information to the network server. For a network\n     * server, an ABP device is always connected. That's why storing the frame counters\n     * is important, at least for ABP. That's why we try to restore frame counters from\n     * session information after a disconnection.\n     *\n     * @param connect  Options for an end device connection to the gateway.\n     *\n     * @return        LORAWAN_STATUS_OK or LORAWAN_STATUS_CONNECT_IN_PROGRESS,\n     *                a negative error code on failure.\n     */\n    lorawan_status_t connect(const lorawan_connect_t &connect);\n\n    /** Adds channels to use.\n     *\n     * You can provide a list of channels with appropriate parameters filled\n     * in. However, this list is not absolute. In some regions, a CF\n     * list gets implemented by default, which means that the network can overwrite your channel\n     * frequency settings right after receiving a Join Accept. You may try\n     * to set up any channel or channels after that and if the channel requested\n     * is already active, the request is silently ignored. A negative error\n     * code is returned if there is any problem with parameters.\n     *\n     * You need to ensure that the base station nearby supports the channel or channels being added.\n     *\n     * If your list includes a default channel (a channel where Join Requests\n     * are received) you cannot fully configure the channel parameters.\n     * Either leave the channel settings to default or check your\n     * corresponding PHY layer implementation. For example, LoRaPHYE868.\n     *\n     * @param  channel_plan     A list of channels or a single channel.\n     *\n     * @return                  LORAWAN_STATUS_OK on success, a negative error\n     *                          code on failure.\n     */\n    lorawan_status_t add_channels(const lorawan_channelplan_t &channel_plan);\n\n    /** Removes a channel from the list.\n     *\n     * @param channel_id        Index of the channel being removed\n     *\n     * @return                  LORAWAN_STATUS_OK on success, a negative error\n     *                          code on failure.\n     */\n    lorawan_status_t remove_a_channel(uint8_t channel_id);\n\n    /** Removes a previously set channel plan.\n     *\n     * @return                  LORAWAN_STATUS_OK on success, a negative error\n     *                          code on failure.\n     */\n    lorawan_status_t drop_channel_list();\n\n    /** Gets a list of currently enabled channels .\n     *\n     * @param channel_plan      The channel plan structure to store final result.\n     *\n     * @return                  LORAWAN_STATUS_OK on success, a negative error\n     *                          code on failure.\n     */\n    lorawan_status_t get_enabled_channels(lorawan_channelplan_t &channel_plan);\n\n    /** Sets up a retry counter for confirmed messages.\n     *\n     * Valid only for confirmed messages. This API sets the number of times the\n     * stack will retry a CONFIRMED message before giving up and reporting an\n     * error.\n     *\n     * @param count             The number of retries for confirmed messages.\n     *\n     * @return                  LORAWAN_STATUS_OK or a negative error code.\n     */\n    lorawan_status_t set_confirmed_msg_retry(uint8_t count);\n\n    /** Sets up the data rate.\n     *\n     * `set_datarate()` first verifies whether the data rate given is valid or not.\n     * If it is valid, the system sets the given data rate to the channel.\n     *\n     * @param data_rate   The intended data rate, for example DR_0 or DR_1.\n     *                    Note that the macro DR_* can mean different\n     *                    things in different regions.\n     *\n     * @return            LORAWAN_STATUS_OK if everything goes well, otherwise\n     *                    a negative error code.\n     */\n    lorawan_status_t set_channel_data_rate(uint8_t data_rate);\n\n    /** Enables ADR.\n     *\n     * @param adr_enabled       0 ADR disabled, 1 ADR enabled.\n     *\n     * @return                  LORAWAN_STATUS_OK on success, a negative error\n     *                          code on failure.\n     */\n    lorawan_status_t enable_adaptive_datarate(bool adr_enabled);\n\n    /** Send message to gateway\n     *\n     * @param port              The application port number. Port numbers 0 and 224\n     *                          are reserved, whereas port numbers from 1 to 223\n     *                          (0x01 to 0xDF) are valid port numbers.\n     *                          Anything out of this range is illegal.\n     *\n     * @param data              A pointer to the data being sent. The ownership of the\n     *                          buffer is not transferred. The data is copied to the\n     *                          internal buffers.\n     *\n     * @param length            The size of data in bytes.\n     *\n     * @param flags             A flag used to determine what type of\n     *                          message is being sent, for example:\n     *\n     *                          MSG_UNCONFIRMED_FLAG = 0x01\n     *                          MSG_CONFIRMED_FLAG = 0x02\n     *                          MSG_MULTICAST_FLAG = 0x04\n     *                          MSG_PROPRIETARY_FLAG = 0x08\n     *                          MSG_MULTICAST_FLAG and MSG_PROPRIETARY_FLAG can be\n     *                          used in conjunction with MSG_UNCONFIRMED_FLAG and\n     *                          MSG_CONFIRMED_FLAG depending on the intended use.\n     *\n     *                          MSG_PROPRIETARY_FLAG|MSG_CONFIRMED_FLAG mask will set\n     *                          a confirmed message flag for a proprietary message.\n     *                          MSG_CONFIRMED_FLAG and MSG_UNCONFIRMED_FLAG are\n     *                          mutually exclusive.\n     *\n     * @param null_allowed      Internal use only. Needed for sending empty packet\n     *                          having CONFIRMED bit on.\n     *\n     * @param allow_port_0      Internal use only. Needed for flushing MAC commands.\n     *\n     * @return                  The number of bytes sent, or\n     *                          LORAWAN_STATUS_WOULD_BLOCK if another TX is\n     *                          ongoing, or a negative error code on failure.\n     */\n    int16_t handle_tx(uint8_t port, const uint8_t *data,\n                      uint16_t length, uint8_t flags,\n                      bool null_allowed = false, bool allow_port_0 = false);\n\n    /** Receives a message from the Network Server.\n     *\n     * @param data              A pointer to buffer where the received data will be\n     *                          stored.\n     *\n     * @param length            The size of data in bytes\n     *\n     * @param port              The application port number. Port numbers 0 and 224\n     *                          are reserved, whereas port numbers from 1 to 223\n     *                          (0x01 to 0xDF) are valid port numbers.\n     *                          Anything out of this range is illegal.\n     *\n     *                          In return will contain the number of port to which\n     *                          message was received.\n     *\n     * @param flags             A flag is used to determine what type of\n     *                          message is being received, for example:\n     *\n     *                          MSG_UNCONFIRMED_FLAG = 0x01,\n     *                          MSG_CONFIRMED_FLAG = 0x02\n     *                          MSG_MULTICAST_FLAG = 0x04,\n     *                          MSG_PROPRIETARY_FLAG = 0x08\n     *\n     *                          MSG_MULTICAST_FLAG and MSG_PROPRIETARY_FLAG can be\n     *                          used in conjunction with MSG_UNCONFIRMED_FLAG and\n     *                          MSG_CONFIRMED_FLAG depending on the intended use.\n     *\n     *                          MSG_PROPRIETARY_FLAG|MSG_CONFIRMED_FLAG mask will set\n     *                          a confirmed message flag for a proprietary message.\n     *\n     *                          MSG_CONFIRMED_FLAG and MSG_UNCONFIRMED_FLAG are\n     *                          not mutually exclusive, i.e., the user can subscribe to\n     *                          receive both CONFIRMED AND UNCONFIRMED messages at\n     *                          the same time.\n     *\n     *                          In return will contain the flags to determine what kind\n     *                          of message was received.\n     *\n     * @param validate_params   If set to true, the given port and flags values will be checked\n     *                          against the values received with the message. If values do not\n     *                          match, LORAWAN_STATUS_WOULD_BLOCK will be returned.\n     *\n     * @return                  It could be one of these:\n     *                             i)   0 if there is nothing else to read.\n     *                             ii)  Number of bytes written to user buffer.\n     *                             iii) LORAWAN_STATUS_WOULD_BLOCK if there is\n     *                                  nothing available to read at the moment.\n     *                             iv)  A negative error code on failure.\n     */\n    int16_t handle_rx(uint8_t *data, uint16_t length, uint8_t &port, int &flags, bool validate_params);\n\n    /** Send Link Check Request MAC command.\n     *\n     *\n     * This API schedules a Link Check Request command (LinkCheckReq) for the network\n     * server and once the response, i.e., LinkCheckAns MAC command is received\n     * from the Network Server, an event is generated.\n     *\n     * A callback function for the link check response must be set prior to using\n     * this API, otherwise a LORAWAN_STATUS_PARAMETER_INVALID error is thrown.\n     *\n     * @return          LORAWAN_STATUS_OK on successfully queuing a request, or\n     *                  a negative error code on failure.\n     *\n     */\n    lorawan_status_t set_link_check_request();\n\n    /** Removes link check request sticky MAC command.\n     *\n     * Any already queued request may still get entertained. However, no new\n     * requests will be made.\n     */\n    void remove_link_check_request();\n\n    /** Shuts down the LoRaWAN protocol.\n     *\n     * In response to the user call for disconnection, the stack shuts down itself.\n     *\n     * @return          LORAWAN_STATUS_DEVICE_OFF on successfully shutdown.\n     */\n    lorawan_status_t shutdown();\n\n    /** Change device class\n     *\n     * Change current device class.\n     *\n     * @param    device_class   The device class\n     *\n     * @return                  LORAWAN_STATUS_OK on success,\n     *                          LORAWAN_STATUS_UNSUPPORTED is requested class is not supported,\n     *                          or other negative error code if request failed.\n     */\n    lorawan_status_t set_device_class(const device_class_t &device_class);\n\n    /** Acquire TX meta-data\n     *\n     * Upon successful transmission, TX meta-data will be made available\n     *\n     * @param    metadata    A reference to the inbound structure which will be\n     *                       filled with any TX meta-data if available.\n     *\n     * @return               LORAWAN_STATUS_OK if successful,\n     *                       LORAWAN_STATUS_METADATA_NOT_AVAILABLE otherwise\n     */\n    lorawan_status_t acquire_tx_metadata(lorawan_tx_metadata &metadata);\n\n    /** Acquire RX meta-data\n     *\n     * Upon successful reception, RX meta-data will be made available\n     *\n     * @param    metadata    A reference to the inbound structure which will be\n     *                       filled with any RX meta-data if available.\n     *\n     * @return               LORAWAN_STATUS_OK if successful,\n     *                       LORAWAN_STATUS_METADATA_NOT_AVAILABLE otherwise\n     */\n    lorawan_status_t acquire_rx_metadata(lorawan_rx_metadata &metadata);\n\n    /** Acquire backoff meta-data\n     *\n     * Get hold of backoff time after which the transmission will take place.\n     *\n     * @param    backoff     A reference to the inbound integer which will be\n     *                       filled with any backoff meta-data if available.\n     *\n     * @return               LORAWAN_STATUS_OK if successful,\n     *                       LORAWAN_STATUS_METADATA_NOT_AVAILABLE otherwise\n     */\n    lorawan_status_t acquire_backoff_metadata(int &backoff);\n\n    /** Stops sending\n     *\n     * Stop sending any outstanding messages if they are not yet queued for\n     * transmission, i.e., if the backoff timer is nhot elapsed yet.\n     *\n     * @return               LORAWAN_STATUS_OK if the transmission is cancelled.\n     *                       LORAWAN_STATUS_BUSY otherwise.\n     */\n    lorawan_status_t stop_sending(void);\n\n    void lock(void)\n    {\n        _loramac.lock();\n    }\n    void unlock(void)\n    {\n        _loramac.unlock();\n    }\n\nprivate:\n    typedef mbed::ScopedLock<LoRaWANStack> Lock;\n    /**\n     * Checks if the user provided port is valid or not\n     */\n    bool is_port_valid(uint8_t port, bool allow_port_0 = false);\n\n    /**\n     * State machine for stack controller layer.\n     */\n    lorawan_status_t state_controller(device_states_t new_state);\n\n    /**\n     * Helpers for state controller\n     */\n    void process_uninitialized_state(lorawan_status_t &op_status);\n    void process_idle_state(lorawan_status_t &op_status);\n    void process_connected_state();\n    void process_connecting_state(lorawan_status_t &op_status);\n    void process_joining_state(lorawan_status_t &op_status);\n    void process_scheduling_state(lorawan_status_t &op_status);\n    void process_status_check_state();\n    void process_shutdown_state(lorawan_status_t &op_status);\n    void state_machine_run_to_completion(void);\n\n    /**\n     * Handles MLME indications\n     */\n    void mlme_indication_handler(void);\n\n    /**\n     * Handles an MLME confirmation\n     */\n    void mlme_confirm_handler(void);\n\n    /**\n     * Handles an MCPS confirmation\n     */\n    void mcps_confirm_handler(void);\n\n    /**\n     * Handles an MCPS indication\n     */\n    void mcps_indication_handler(void);\n\n    /**\n     * Sets up user application port\n     */\n    lorawan_status_t set_application_port(uint8_t port, bool allow_port_0 = false);\n\n    /**\n     * Handles connection internally\n     */\n    lorawan_status_t handle_connect(bool is_otaa);\n\n\n    /** Send event to application.\n     *\n     * @param  event            The event to be sent.\n     */\n    void send_event_to_application(const lorawan_event_t event) const;\n\n    /** Send empty uplink message to network.\n     *\n     * Sends an empty confirmed message to gateway.\n     *\n     * @param  port            The event to be sent.\n     */\n    void send_automatic_uplink_message(uint8_t port);\n\n    /**\n     * TX interrupt handlers and corresponding processors\n     */\n    void tx_interrupt_handler(void);\n    void tx_timeout_interrupt_handler(void);\n    void process_transmission(void);\n    void process_transmission_timeout(void);\n\n    /**\n     * RX interrupt handlers and corresponding processors\n     */\n    void rx_interrupt_handler(const uint8_t *payload, uint16_t size, int16_t rssi,\n                              int8_t snr);\n    void rx_timeout_interrupt_handler(void);\n    void rx_error_interrupt_handler(void);\n    void process_reception(const uint8_t *payload, uint16_t size, int16_t rssi,\n                           int8_t snr);\n    void process_reception_timeout(bool is_timeout);\n\n    int convert_to_msg_flag(const mcps_type_t type);\n\n    void make_tx_metadata_available(void);\n    void make_rx_metadata_available(void);\n\n    void handle_ack_expiry_for_class_c(void);\n\nprivate:\n    LoRaMac _loramac;\n    radio_events_t radio_events;\n    device_states_t _device_current_state;\n    lorawan_app_callbacks_t _callbacks;\n    lorawan_session_t _lw_session;\n    loramac_tx_message_t _tx_msg;\n    loramac_rx_message_t _rx_msg;\n    lorawan_tx_metadata _tx_metadata;\n    lorawan_rx_metadata _rx_metadata;\n    uint8_t _num_retry;\n    uint32_t _ctrl_flags;\n    uint8_t _app_port;\n    bool _link_check_requested;\n    bool _automatic_uplink_ongoing;\n    volatile bool _ready_for_rx;\n    uint8_t _rx_payload[LORAMAC_PHY_MAXPAYLOAD];\n    events::EventQueue *_queue;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n\n    /**\n     * Used only for compliance testing\n     */\n    void compliance_test_handler(loramac_mcps_indication_t *mcps_indication);\n\n    /**\n     * Used only for compliance testing\n     */\n    lorawan_status_t send_compliance_test_frame_to_mac();\n\n    compliance_test_t _compliance_test;\n#endif\n};\n\n#endif /* LORAWANSTACK_H_ */\n","/**\n * @file lorawan_types.h\n *\n * @brief Contains data structures required by LoRaWANBase class.\n *\n *  \\code\n *   ______                              _\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *   (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n */\n\n#ifndef MBED_LORAWAN_TYPES_H_\n#define MBED_LORAWAN_TYPES_H_\n\n#include \"platform/Callback.h\"\n\n/**\n * Option Flags for send(), receive() APIs\n *\n * Special Notes for UPLINK:\n *  i)  All of the flags are mutually exclusive.\n *  ii) MSG_MULTICAST_FLAG cannot be used.\n */\n#define MSG_UNCONFIRMED_FLAG                  0x01\n#define MSG_CONFIRMED_FLAG                    0x02\n#define MSG_MULTICAST_FLAG                    0x04\n#define MSG_PROPRIETARY_FLAG                  0x08\n\n/**\n * LoRaWAN device classes definition.\n *\n * LoRaWAN Specification V1.0.2, chapter 2.1.\n */\ntypedef enum {\n    /**\n     * LoRaWAN device class A.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 3.\n     */\n    CLASS_A,\n    /**\n     * LoRaWAN device class B.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 8.\n     */\n    CLASS_B,\n    /**\n     * LoRaWAN device class C.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 17.\n     */\n    CLASS_C,\n} device_class_t;\n\n/**\n * lorawan_status_t contains status codes in\n * response to stack operations\n */\ntypedef enum lorawan_status {\n    LORAWAN_STATUS_OK = 0,                         /**< Service started successfully */\n    LORAWAN_STATUS_BUSY = -1000,                   /**< Service not started - LoRaMAC is busy */\n    LORAWAN_STATUS_WOULD_BLOCK = -1001,            /**< LoRaMAC cannot send at the moment or have nothing to read */\n    LORAWAN_STATUS_SERVICE_UNKNOWN = -1002,        /**< Service unknown */\n    LORAWAN_STATUS_PARAMETER_INVALID = -1003,      /**< Service not started - invalid parameter */\n    LORAWAN_STATUS_FREQUENCY_INVALID = -1004,      /**< Service not started - invalid frequency */\n    LORAWAN_STATUS_DATARATE_INVALID = -1005,       /**< Service not started - invalid datarate */\n    LORAWAN_STATUS_FREQ_AND_DR_INVALID = -1006,    /**< Service not started - invalid frequency and datarate */\n    LORAWAN_STATUS_NO_NETWORK_JOINED = -1009,      /**< Service not started - the device is not in a LoRaWAN */\n    LORAWAN_STATUS_LENGTH_ERROR = -1010,           /**< Service not started - payload lenght error */\n    LORAWAN_STATUS_DEVICE_OFF = -1011,             /**< Service not started - the device is switched off */\n    LORAWAN_STATUS_NOT_INITIALIZED = -1012,        /**< Service not started - stack not initialized */\n    LORAWAN_STATUS_UNSUPPORTED = -1013,            /**< Service not supported */\n    LORAWAN_STATUS_CRYPTO_FAIL = -1014,            /**< Service not started - crypto failure */\n    LORAWAN_STATUS_PORT_INVALID = -1015,           /**< Invalid port */\n    LORAWAN_STATUS_CONNECT_IN_PROGRESS = -1016,    /**< Services started - Connection in progress */\n    LORAWAN_STATUS_NO_ACTIVE_SESSIONS = -1017,            /**< Services not started - No active session */\n    LORAWAN_STATUS_IDLE = -1018,                   /**< Services started - Idle at the moment */\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    LORAWAN_STATUS_COMPLIANCE_TEST_ON = -1019,     /**< Compliance test - is on-going */\n#endif\n    LORAWAN_STATUS_DUTYCYCLE_RESTRICTED = -1020,\n    LORAWAN_STATUS_NO_CHANNEL_FOUND = -1021,\n    LORAWAN_STATUS_NO_FREE_CHANNEL_FOUND = -1022,\n    LORAWAN_STATUS_METADATA_NOT_AVAILABLE = -1023\n} lorawan_status_t;\n\n/** The lorawan_connect_otaa structure.\n *\n * A structure representing the LoRaWAN Over The Air Activation\n * parameters.\n */\ntypedef struct {\n    /** End-device identifier\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.1\n     */\n    uint8_t *dev_eui;\n    /** Application identifier\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.2\n     */\n    uint8_t *app_eui;\n    /** AES-128 application key\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.2\n     */\n    uint8_t *app_key;\n    /** Join request trials\n     *\n     * Number of trials for the join request.\n     */\n    uint8_t nb_trials;\n} lorawan_connect_otaa_t;\n\n/** The lorawan_connect_abp structure.\n *\n * A structure representing the LoRaWAN Activation By Personalization\n * parameters.\n */\ntypedef struct {\n    /** Network identifier\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.1\n     */\n    uint32_t nwk_id;\n    /** End-device address\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.1\n     */\n    uint32_t dev_addr;\n    /** Network session key\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.3\n     */\n    uint8_t *nwk_skey;\n    /** Application session key\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.4\n     */\n    uint8_t *app_skey;\n} lorawan_connect_abp_t;\n\n/** lorawan_connect_t structure\n *\n * A structure representing the parameters for different connections.\n */\ntypedef struct lorawan_connect {\n    /**\n     * Select the connection type, either LORAWAN_CONNECTION_OTAA\n     * or LORAWAN_CONNECTION_ABP.\n     */\n    uint8_t connect_type;\n\n    union {\n        /**\n         * Join the network using OTA\n         */\n        lorawan_connect_otaa_t otaa;\n        /**\n         * Authentication by personalization\n         */\n        lorawan_connect_abp_t abp;\n    } connection_u;\n\n} lorawan_connect_t;\n\n/**\n * Events needed to announce stack operation results.\n *\n * CONNECTED            - When the connection is complete\n * DISCONNECTED         - When the protocol is shut down in response to disconnect()\n * TX_DONE              - When a packet is sent\n * TX_TIMEOUT,          - When stack was unable to send packet in TX window\n * TX_ERROR,            - A general TX error\n * CRYPTO_ERROR,        - A crypto error indicating wrong keys\n * TX_SCHEDULING_ERROR, - When stack is unable to schedule packet\n * RX_DONE,             - When there is something to receive\n * RX_TIMEOUT,          - Not yet mapped\n * RX_ERROR             - A general RX error\n * JOIN_FAILURE         - When all Joining retries are exhausted\n * UPLINK_REQUIRED      - Stack indicates application that some uplink needed\n * AUTOMATIC_UPLINK_ERROR - Stack tried automatically send uplink but some error occurred.\n *                          Application should initiate uplink as soon as possible.\n *\n */\ntypedef enum lora_events {\n    CONNECTED = 0,\n    DISCONNECTED,\n    TX_DONE,\n    TX_TIMEOUT,\n    TX_ERROR,\n    CRYPTO_ERROR,\n    TX_CRYPTO_ERROR = CRYPTO_ERROR, //keeping this for backward compatibility\n    TX_SCHEDULING_ERROR,\n    RX_DONE,\n    RX_TIMEOUT,\n    RX_ERROR,\n    JOIN_FAILURE,\n    UPLINK_REQUIRED,\n    AUTOMATIC_UPLINK_ERROR,\n} lorawan_event_t;\n\n/**\n * Stack level callback functions\n *\n * 'lorawan_app_callbacks_t' is a structure that holds pointers to the application\n * provided methods which are needed to be called in response to certain\n * requests. The structure is default constructed to set all pointers to NULL.\n * So if the user does not provide the pointer, a response will not be posted.\n * However, the 'lorawan_events' callback is mandatory to be provided as it\n * contains essential events.\n *\n * A link check request could be sent whenever the device tries to send a\n * message and if the network server responds with a link check response,\n * the stack notifies the application be calling the appropriate method set using\n * 'link_check_resp' callback. The result is thus transported to the application\n * via callback function provided.\n *\n * As can be seen from declaration, mbed::Callback<void(uint8_t, uint8_t)> *link_check_resp)\n * carries two parameters. First one is Demodulation Margin and the second one\n * is number of gateways involved in the path to network server.\n *\n * 'battery_level' callback goes in the down direction, i.e., it informs\n * the stack about the battery level by calling a function provided\n * by the upper layers.\n */\ntypedef struct {\n    /**\n     * Mandatory. Event Callback must be provided\n     */\n    mbed::Callback<void(lorawan_event_t)> events;\n\n    /**\n     * Optional\n     */\n    mbed::Callback<void(uint8_t, uint8_t)> link_check_resp;\n\n    /**\n     * Battery level return value must follow the specification\n     * for DevStatusAns MAC command:\n     *\n     *     0       The end-device is connected to an external power source\n     *     1 - 254 The battery level, 1 being at minimum and 254 being at maximum\n     *     255     The end-device was not able to measure the battery level.\n     */\n    mbed::Callback<uint8_t(void)> battery_level;\n} lorawan_app_callbacks_t;\n\n/**\n * DO NOT MODIFY, WILL BREAK THE API!\n *\n * Structure containing a given data rate range.\n */\ntypedef union {\n    /**\n     * Byte-access to the bits.\n     */\n    uint8_t value;\n    /**\n     * The structure to store the minimum and the maximum datarate.\n     */\n    struct fields_s {\n        /**\n         * The minimum data rate.\n         *\n         * LoRaWAN Regional Parameters V1.0.2rB.\n         *\n         * The allowed ranges are region-specific.\n         * Please refer to \\ref DR_0 to \\ref DR_15 for details.\n         */\n        uint8_t min : 4;\n        /**\n         * The maximum data rate.\n         *\n         * LoRaWAN Regional Parameters V1.0.2rB.\n         *\n         * The allowed ranges are region-specific.\n         * Please refer to \\ref DR_0 to \\ref DR_15 for details.\n         */\n        uint8_t max : 4;\n    } fields;\n} dr_range_t;\n\n/**\n * DO NOT MODIFY, WILL BREAK THE API!\n *\n * LoRaMAC channel definition.\n */\ntypedef struct {\n    /**\n     * The frequency in Hz.\n     */\n    uint32_t frequency;\n    /**\n     * The alternative frequency for RX window 1.\n     */\n    uint32_t rx1_frequency;\n    /**\n     * The data rate definition.\n     */\n    dr_range_t dr_range;\n    /**\n     * The band index.\n     */\n    uint8_t band;\n} channel_params_t;\n\n/**\n * DO NOT MODIFY, WILL BREAK THE API!\n *\n * Structure to hold parameters for a LoRa channel.\n */\ntypedef struct lora_channels_s {\n    uint8_t id;\n    channel_params_t ch_param;\n} loramac_channel_t;\n\n/**\n * DO NOT MODIFY, WILL BREAK THE API!\n *\n * This data structures contains LoRaWAN channel plan, i.e., a pointer to a\n * list of channels and the total number of channels included in the plan.\n */\ntypedef struct lora_channelplan {\n    uint8_t nb_channels;    // number of channels\n    loramac_channel_t *channels;\n} lorawan_channelplan_t;\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF12 - BW125\n * AU915        | SF10 - BW125\n * CN470        | SF12 - BW125\n * CN779        | SF12 - BW125\n * EU433        | SF12 - BW125\n * EU868        | SF12 - BW125\n * IN865        | SF12 - BW125\n * KR920        | SF12 - BW125\n * US915        | SF10 - BW125\n * US915_HYBRID | SF10 - BW125\n */\n#define DR_0                                        0\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF11 - BW125\n * AU915        | SF9  - BW125\n * CN470        | SF11 - BW125\n * CN779        | SF11 - BW125\n * EU433        | SF11 - BW125\n * EU868        | SF11 - BW125\n * IN865        | SF11 - BW125\n * KR920        | SF11 - BW125\n * US915        | SF9  - BW125\n * US915_HYBRID | SF9  - BW125\n */\n#define DR_1                                        1\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF10 - BW125\n * AU915        | SF8  - BW125\n * CN470        | SF10 - BW125\n * CN779        | SF10 - BW125\n * EU433        | SF10 - BW125\n * EU868        | SF10 - BW125\n * IN865        | SF10 - BW125\n * KR920        | SF10 - BW125\n * US915        | SF8  - BW125\n * US915_HYBRID | SF8  - BW125\n */\n#define DR_2                                        2\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF9  - BW125\n * AU915        | SF7  - BW125\n * CN470        | SF9  - BW125\n * CN779        | SF9  - BW125\n * EU433        | SF9  - BW125\n * EU868        | SF9  - BW125\n * IN865        | SF9  - BW125\n * KR920        | SF9  - BW125\n * US915        | SF7  - BW125\n * US915_HYBRID | SF7  - BW125\n */\n#define DR_3                                        3\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF8  - BW125\n * AU915        | SF8  - BW500\n * CN470        | SF8  - BW125\n * CN779        | SF8  - BW125\n * EU433        | SF8  - BW125\n * EU868        | SF8  - BW125\n * IN865        | SF8  - BW125\n * KR920        | SF8  - BW125\n * US915        | SF8  - BW500\n * US915_HYBRID | SF8  - BW500\n */\n#define DR_4                                        4\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF7  - BW125\n * AU915        | RFU\n * CN470        | SF7  - BW125\n * CN779        | SF7  - BW125\n * EU433        | SF7  - BW125\n * EU868        | SF7  - BW125\n * IN865        | SF7  - BW125\n * KR920        | SF7  - BW125\n * US915        | RFU\n * US915_HYBRID | RFU\n */\n#define DR_5                                        5\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | SF7  - BW250\n * AU915        | RFU\n * CN470        | SF12 - BW125\n * CN779        | SF7  - BW250\n * EU433        | SF7  - BW250\n * EU868        | SF7  - BW250\n * IN865        | SF7  - BW250\n * KR920        | RFU\n * US915        | RFU\n * US915_HYBRID | RFU\n */\n#define DR_6                                        6\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | FSK\n * AU915        | RFU\n * CN470        | SF12 - BW125\n * CN779        | FSK\n * EU433        | FSK\n * EU868        | FSK\n * IN865        | FSK\n * KR920        | RFU\n * US915        | RFU\n * US915_HYBRID | RFU\n */\n#define DR_7                                        7\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | SF12 - BW500\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | SF12 - BW500\n * US915_HYBRID | SF12 - BW500\n */\n#define DR_8                                        8\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | SF11 - BW500\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | SF11 - BW500\n * US915_HYBRID | SF11 - BW500\n */\n#define DR_9                                        9\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | SF10 - BW500\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | SF10 - BW500\n * US915_HYBRID | SF10 - BW500\n */\n#define DR_10                                       10\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | SF9  - BW500\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | SF9  - BW500\n * US915_HYBRID | SF9  - BW500\n */\n#define DR_11                                       11\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | SF8  - BW500\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | SF8  - BW500\n * US915_HYBRID | SF8  - BW500\n */\n#define DR_12                                       12\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | SF7  - BW500\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | SF7  - BW500\n * US915_HYBRID | SF7  - BW500\n */\n#define DR_13                                       13\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | RFU\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | RFU\n * US915_HYBRID | RFU\n */\n#define DR_14                                       14\n\n/*!\n * Region       | SF\n * ------------ | :-----:\n * AS923        | RFU\n * AU915        | RFU\n * CN470        | RFU\n * CN779        | RFU\n * EU433        | RFU\n * EU868        | RFU\n * IN865        | RFU\n * KR920        | RFU\n * US915        | RFU\n * US915_HYBRID | RFU\n */\n#define DR_15                                       15\n\n/**\n * Enumeration for LoRaWAN connection type.\n */\ntypedef enum lorawan_connect_type {\n    LORAWAN_CONNECTION_OTAA = 0,    /**< Over The Air Activation */\n    LORAWAN_CONNECTION_ABP          /**< Activation By Personalization */\n} lorawan_connect_type_t;\n\n\n/**\n * Meta-data collection for a transmission\n */\ntypedef struct {\n    /**\n     * The transmission time on air of the frame.\n     */\n    uint32_t tx_toa;\n    /**\n     * The uplink channel used for transmission.\n     */\n    uint32_t channel;\n    /**\n     * The transmission power.\n     */\n    int8_t tx_power;\n    /**\n     * The uplink datarate.\n     */\n    uint8_t data_rate;\n    /**\n     * Provides the number of retransmissions.\n     */\n    uint8_t nb_retries;\n    /**\n     * A boolean to mark if the meta data is stale\n     */\n    bool stale;\n} lorawan_tx_metadata;\n\n/**\n * Meta-data collection for the received packet\n */\ntypedef struct {\n    /**\n     * The RSSI for the received packet.\n     */\n    int16_t rssi;\n    /**\n     * Data rate of reception\n     */\n    uint8_t rx_datarate;\n    /**\n     * The SNR for the received packet.\n     */\n    uint8_t snr;\n    /**\n     * A boolean to mark if the meta data is stale\n     */\n    bool stale;\n} lorawan_rx_metadata;\n\n#endif /* MBED_LORAWAN_TYPES_H_ */\n","/**\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef LORARADIO_H_\n#define LORARADIO_H_\n\n#include \"platform/Callback.h\"\n#include \"PinNames.h\"\n\n/**\n * Structure to hold RF controls for LoRa Radio.\n * SX1276 have an extra control for the crystal (used in DOSCO-L072CZ)\n */\ntypedef struct {\n    PinName rf_switch_ctl1;\n    PinName rf_switch_ctl2;\n    PinName txctl;\n    PinName rxctl;\n    PinName ant_switch;\n    PinName pwr_amp_ctl;\n    PinName tcxo;\n} rf_ctrls;\n\n/** Radio driver internal state.\n * State machine states definition.\n */\ntypedef enum radio_state {\n    RF_IDLE = 0,\n    RF_RX_RUNNING,\n    RF_TX_RUNNING,\n    RF_CAD,\n} radio_state_t;\n\n/** Type of the modem.\n *  [LORA/FSK]\n */\ntypedef enum modem_type {\n    MODEM_FSK = 0,\n    MODEM_LORA\n} radio_modems_t;\n\n/** Radio FSK modem parameters.\n *\n */\ntypedef struct radio_fsk_settings {\n    int8_t   power;\n    uint32_t f_dev;\n    uint32_t bandwidth;\n    uint32_t bandwidth_afc;\n    uint32_t datarate;\n    uint16_t preamble_len;\n    bool     fix_len;\n    uint8_t  payload_len;\n    bool     crc_on;\n    bool     iq_inverted;\n    bool     rx_continuous;\n    uint32_t tx_timeout;\n    uint32_t rx_single_timeout;\n} radio_fsk_settings_t;\n\n/** Radio FSK packet handler state.\n *\n */\ntypedef struct radio_fsk_packet_handler {\n    uint8_t  preamble_detected;\n    uint8_t  sync_word_detected;\n    int8_t   rssi_value;\n    int32_t  afc_value;\n    uint8_t  rx_gain;\n    uint16_t size;\n    uint16_t nb_bytes;\n    uint8_t  fifo_thresh;\n    uint8_t  chunk_size;\n} radio_fsk_packet_handler_t;\n\n/** Radio LoRa modem parameters.\n *\n */\ntypedef struct radio_lora_settings {\n    int8_t   power;\n    uint32_t bandwidth;\n    uint32_t datarate;\n    bool     low_datarate_optimize;\n    uint8_t  coderate;\n    uint16_t preamble_len;\n    bool     fix_len;\n    uint8_t  payload_len;\n    bool     crc_on;\n    bool     freq_hop_on;\n    uint8_t  hop_period;\n    bool     iq_inverted;\n    bool     rx_continuous;\n    uint32_t tx_timeout;\n    bool     public_network;\n} radio_lora_settings_t;\n\n/** Radio LoRa packet handler state.\n *\n */\ntypedef struct radio_lora_packet_handler {\n    int8_t  snr_value;\n    int8_t  rssi_value;\n    uint8_t size;\n    bool      pending;\n    uint32_t  timestamp_ms;\n} radio_lora_packet_handler_t;\n\n/** Radio settings.\n *\n */\ntypedef struct radio_settings {\n    uint8_t                     state;\n    uint8_t                     modem;\n    uint32_t                    channel;\n    radio_fsk_settings_t        fsk;\n    radio_fsk_packet_handler_t  fsk_packet_handler;\n    radio_lora_settings_t       lora;\n    radio_lora_packet_handler_t lora_packet_handler;\n} radio_settings_t;\n\n/** Radio driver callback functions.\n *\n */\ntypedef struct radio_events {\n    /**\n     * Callback when Transmission is done\n     */\n    mbed::Callback<void()> tx_done;\n\n    /**\n     * Callback when Transmission is timed out\n     */\n    mbed::Callback<void()> tx_timeout;\n\n    /**\n     * Rx Done callback prototype.\n     *\n     *  @param payload Received buffer pointer.\n     *  @param size    Received buffer size.\n     *  @param rssi    RSSI value computed while receiving the frame [dBm].\n     *  @param snr     Raw SNR value given by the radio hardware.\n     *                     FSK : N/A (set to 0)\n     *                     LoRa: SNR value in dB\n     */\n    mbed::Callback<void(const uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr)> rx_done;\n\n    /**\n     * Callback when Reception is timed out\n     */\n    mbed::Callback<void()> rx_timeout;\n\n    /**\n     * Callback when Reception ends up in error\n     */\n    mbed::Callback<void()> rx_error;\n\n   /**\n    * FHSS Change Channel callback prototype.\n    *\n    *  @param current_channel   The index number of the current channel.\n    */\n    mbed::Callback<void(uint8_t current_channel)> fhss_change_channel;\n\n    /**\n     * CAD Done callback prototype.\n     *\n     *  @param channel_busy    True, if Channel activity detected.\n     */\n    mbed::Callback<void(bool channel_busy)> cad_done;\n} radio_events_t;\n\n/**\n *    Interface for the radios, contains the main functions that a radio needs, and five callback functions.\n */\nclass LoRaRadio\n{\n\npublic:\n\n    /**\n     * Registers radio events with the Mbed LoRaWAN stack and undergoes the initialization steps if any.\n     *\n     *  @param events The structure containing the driver callback functions.\n     */\n    virtual void init_radio(radio_events_t *events) = 0;\n\n    /**\n     * Resets the radio module.\n     */\n    virtual void radio_reset() = 0;\n\n    /**\n     *  Put the RF module in the sleep mode.\n     */\n    virtual void sleep(void) = 0;\n\n    /**\n     *  Sets the radio in the standby mode.\n     */\n    virtual void standby(void) = 0;\n\n    /**\n     *  Sets the reception parameters.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param bandwidth     Sets the bandwidth.\n     *                          FSK : >= 2600 and <= 250000 Hz\n     *                          LoRa: [0: 125 kHz, 1: 250 kHz,\n     *                                 2: 500 kHz, 3: Reserved]\n     *  @param datarate      Sets the datarate.\n     *                          FSK : 600..300000 bits/s\n     *                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,\n     *                                10: 1024, 11: 2048, 12: 4096  chips]\n     *  @param coderate      Sets the coding rate (LoRa only).\n     *                          FSK : N/A ( set to 0 )\n     *                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]\n     *  @param bandwidth_afc Sets the AFC bandwidth (FSK only).\n     *                          FSK : >= 2600 and <= 250000 Hz\n     *                          LoRa: N/A (set to 0)\n     *  @param preamble_len  Sets the preamble length (LoRa only).\n     *                          FSK : N/A (set to 0)\n     *                          LoRa: Length in symbols (the hardware adds four more symbols).\n     *  @param symb_timeout  Sets the RxSingle timeout value.\n     *                          FSK : Timeout number of bytes\n     *                          LoRa: Timeout in symbols\n     *  @param fix_len        Fixed length packets [0: variable, 1: fixed].\n     *  @param payload_len   Sets the payload length when fixed length is used.\n     *  @param crc_on        Enables/disables the CRC [0: OFF, 1: ON].\n     *  @param freq_hop_on   Enables/disables the intra-packet frequency hopping [0: OFF, 1: ON] (LoRa only).\n     *  @param hop_period    The number of symbols bewteen each hop (LoRa only).\n     *  @param iq_inverted   Inverts the IQ signals (LoRa only).\n     *                          FSK : N/A (set to 0)\n     *                          LoRa: [0: not inverted, 1: inverted]\n     *  @param rx_continuous Sets the reception in continuous mode.\n     *                          [false: single mode, true: continuous mode]\n     */\n    virtual void set_rx_config (radio_modems_t modem, uint32_t bandwidth,\n                               uint32_t datarate, uint8_t coderate,\n                               uint32_t bandwidth_afc, uint16_t preamble_len,\n                               uint16_t symb_timeout, bool fix_len,\n                               uint8_t payload_len,\n                               bool crc_on, bool freq_hop_on, uint8_t hop_period,\n                               bool iq_inverted, bool rx_continuous) = 0;\n\n    /**\n     *  Sets the transmission parameters.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param power         Sets the output power [dBm].\n     *  @param fdev          Sets the frequency deviation (FSK only).\n     *                          FSK : [Hz]\n     *                          LoRa: 0\n     *  @param bandwidth     Sets the bandwidth (LoRa only).\n     *                          FSK : 0\n     *                          LoRa: [0: 125 kHz, 1: 250 kHz,\n     *                                 2: 500 kHz, 3: Reserved]\n     *  @param datarate      Sets the datarate.\n     *                          FSK : 600..300000 bits/s\n     *                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,\n     *                                10: 1024, 11: 2048, 12: 4096  chips]\n     *  @param coderate      Sets the coding rate (LoRa only).\n     *                          FSK : N/A ( set to 0 )\n     *                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]\n     *  @param preamble_len  Sets the preamble length.\n     *  @param fix_len       Fixed length packets [0: variable, 1: fixed].\n     *  @param crc_on        Enables/disables the CRC [0: OFF, 1: ON].\n     *  @param freq_hop_on   Enables/disables the intra-packet frequency hopping [0: OFF, 1: ON] (LoRa only).\n     *  @param hop_period    The number of symbols between each hop (LoRa only).\n     *  @param iq_inverted   Inverts IQ signals (LoRa only)\n     *                          FSK : N/A (set to 0).\n     *                          LoRa: [0: not inverted, 1: inverted]\n     *  @param timeout       The transmission timeout [us].\n     */\n    virtual void set_tx_config(radio_modems_t modem, int8_t power, uint32_t fdev,\n                              uint32_t bandwidth, uint32_t datarate,\n                              uint8_t coderate, uint16_t preamble_len,\n                              bool fix_len, bool crc_on, bool freq_hop_on,\n                              uint8_t hop_period, bool iq_inverted, uint32_t timeout) = 0;\n\n    /**\n     *  Sends the buffer of size\n     *\n     *  Prepares the packet to be sent and sets the radio in transmission.\n     *\n     *  @param buffer        A pointer to the buffer.\n     *  @param size          The buffer size.\n     */\n    virtual void send(uint8_t *buffer, uint8_t size) = 0;\n\n    /**\n     *  Sets the radio in reception mode for a given time.\n     *\n     *  If the timeout is set to 0, it essentially puts the receiver in continuous mode and it should\n     *  be treated as if in continuous mode. However, an appropriate way to set the receiver in continuous mode is\n     *  to use the `set_rx_config()` API.\n     *\n     *  @param timeout       Reception timeout [ms].\n     *\n     */\n    virtual void receive(uint32_t timeout) = 0;\n\n    /**\n     *  Sets the carrier frequency\n     *\n     *  @param freq          Channel RF frequency.\n     */\n    virtual void set_channel(uint32_t freq) = 0;\n\n    /**\n     *  Generates a 32 bit random value based on the RSSI readings.\n     *\n     *  \\remark This function sets the radio in LoRa modem mode and disables all interrupts.\n     *          After calling this function, either `Radio.SetRxConfig` or\n     *         `Radio.SetTxConfig` functions must be called.\n     *\n     *  @return             A 32 bit random value.\n     */\n    virtual uint32_t random(void) = 0;\n\n    /**\n     *  Gets the radio status.\n     *\n     *  @return              The current radio status.\n     */\n    virtual uint8_t get_status(void) = 0;\n\n    /**\n     *  Sets the maximum payload length.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param max           The maximum payload length in bytes.\n     */\n    virtual void set_max_payload_length(radio_modems_t modem, uint8_t max) = 0;\n\n    /**\n     *  Sets the network to public or private.\n     *\n     *  Updates the sync byte. Applies to LoRa modem only.\n     *\n     *  @param enable        If true, it enables a public network.\n     */\n    virtual void set_public_network(bool enable) = 0;\n\n    /**\n     *  Computes the packet time on air for the given payload.\n     *\n     *  \\remark This can only be called once `SetRxConfig` or `SetTxConfig` have been called.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param pkt_len       The packet payload length.\n     *  @return              The computed `airTime` for the given packet payload length.\n     */\n    virtual uint32_t time_on_air(radio_modems_t modem, uint8_t pkt_len) = 0;\n\n    /**\n     * Performs carrier sensing.\n     *\n     * Checks for a certain time if the RSSI is above a given threshold.\n     * This threshold determines whether or not there is a transmission going on\n     * in the channel already.\n     *\n     * @param modem                     The type of the radio modem.\n     * @param freq                      The carrier frequency.\n     * @param rssi_threshold            The threshold value of RSSI.\n     * @param max_carrier_sense_time    The time set for sensing the channel (ms).\n     *\n     * @return                          True if there is no active transmission\n     *                                  in the channel, otherwise false.\n     */\n    virtual bool perform_carrier_sense(radio_modems_t modem,\n                                       uint32_t freq,\n                                       int16_t rssi_threshold,\n                                       uint32_t max_carrier_sense_time) = 0;\n\n    /**\n     *  Sets the radio in CAD mode.\n     *\n     */\n    virtual void start_cad(void) = 0;\n\n    /**\n     *  Checks whether the given RF is in range.\n     *\n     *  @param frequency       The frequency to be checked.\n     */\n    virtual bool check_rf_frequency(uint32_t frequency) = 0;\n\n    /** Sets the radio in continuous wave transmission mode.\n     *\n     *  @param freq          The RF frequency of the channel.\n     *  @param power         The output power [dBm].\n     *  @param time          The transmission mode timeout [s].\n     */\n    virtual void set_tx_continuous_wave(uint32_t freq, int8_t power, uint16_t time) = 0;\n\n    /**\n     * Acquires exclusive access to this radio.\n     */\n    virtual void lock(void) = 0;\n\n    /**\n     * Releases the exclusive access to this radio.\n     */\n    virtual void unlock(void) = 0;\n};\n\n#endif // LORARADIO_H_\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRa MAC layer implementation\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"LoRaMacCommand.h\"\n#include \"LoRaMac.h\"\n\n#include \"mbed-trace/mbed_trace.h\"\n#define TRACE_GROUP \"LMACC\"\n\n/**\n * LoRaMAC max EIRP (dBm) table.\n */\nstatic const uint8_t max_eirp_table[] = { 8, 10, 12, 13, 14, 16, 18, 20, 21, 24, 26, 27, 29, 30, 33, 36 };\n\n\nLoRaMacCommand::LoRaMacCommand()\n{\n    mac_cmd_in_next_tx = false;\n    sticky_mac_cmd = false;\n    mac_cmd_buf_idx = 0;\n    mac_cmd_buf_idx_to_repeat = 0;\n\n    memset(mac_cmd_buffer, 0, sizeof(mac_cmd_buffer));\n    memset(mac_cmd_buffer_to_repeat, 0, sizeof(mac_cmd_buffer_to_repeat));\n}\n\nvoid LoRaMacCommand::clear_command_buffer()\n{\n    mac_cmd_buf_idx = 0;\n}\n\nuint8_t LoRaMacCommand::get_mac_cmd_length() const\n{\n    return mac_cmd_buf_idx;\n}\n\nuint8_t *LoRaMacCommand::get_mac_commands_buffer()\n{\n    return mac_cmd_buffer;\n}\n\nvoid LoRaMacCommand::parse_mac_commands_to_repeat()\n{\n    uint8_t i = 0;\n    uint8_t cmd_cnt = 0;\n\n    for (i = 0; i < mac_cmd_buf_idx; i++) {\n        switch (mac_cmd_buffer[i]) {\n            // STICKY\n            case MOTE_MAC_DL_CHANNEL_ANS:\n            case MOTE_MAC_RX_PARAM_SETUP_ANS: { // 1 byte payload\n                mac_cmd_buffer_to_repeat[cmd_cnt++] = mac_cmd_buffer[i++];\n                mac_cmd_buffer_to_repeat[cmd_cnt++] = mac_cmd_buffer[i];\n                break;\n            }\n            case MOTE_MAC_RX_TIMING_SETUP_ANS: { // 0 byte payload\n                mac_cmd_buffer_to_repeat[cmd_cnt++] = mac_cmd_buffer[i];\n                break;\n            }\n\n            // NON-STICKY\n            case MOTE_MAC_DEV_STATUS_ANS: { // 2 bytes payload\n                i += 2;\n                break;\n            }\n            case MOTE_MAC_LINK_ADR_ANS:\n            case MOTE_MAC_NEW_CHANNEL_ANS: { // 1 byte payload\n                i++;\n                break;\n            }\n            case MOTE_MAC_TX_PARAM_SETUP_ANS:\n            case MOTE_MAC_DUTY_CYCLE_ANS:\n            case MOTE_MAC_LINK_CHECK_REQ: { // 0 byte payload\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    if (cmd_cnt > 0) {\n        mac_cmd_in_next_tx = true;\n    } else {\n        mac_cmd_in_next_tx = false;\n    }\n    mac_cmd_buf_idx_to_repeat = cmd_cnt;\n}\n\n\nvoid LoRaMacCommand::clear_repeat_buffer()\n{\n    mac_cmd_buf_idx_to_repeat = 0;\n}\n\nvoid LoRaMacCommand::copy_repeat_commands_to_buffer()\n{\n    memcpy(&mac_cmd_buffer[mac_cmd_buf_idx], mac_cmd_buffer_to_repeat, mac_cmd_buf_idx_to_repeat);\n    mac_cmd_buf_idx += mac_cmd_buf_idx_to_repeat;\n}\n\nuint8_t LoRaMacCommand::get_repeat_commands_length() const\n{\n    return mac_cmd_buf_idx_to_repeat;\n}\n\nvoid LoRaMacCommand::clear_mac_commands_in_next_tx()\n{\n    mac_cmd_in_next_tx = false;\n}\n\nbool LoRaMacCommand::is_mac_command_in_next_tx() const\n{\n    return mac_cmd_in_next_tx;\n}\n\nvoid LoRaMacCommand::clear_sticky_mac_cmd()\n{\n    sticky_mac_cmd = false;\n}\n\nbool LoRaMacCommand::has_sticky_mac_cmd() const\n{\n    return sticky_mac_cmd;\n}\n\nlorawan_status_t LoRaMacCommand::process_mac_commands(const uint8_t *payload, uint8_t mac_index,\n                                                      uint8_t commands_size, uint8_t snr,\n                                                      loramac_mlme_confirm_t& mlme_conf,\n                                                      lora_mac_system_params_t &mac_sys_params,\n                                                      LoRaPHY &lora_phy)\n{\n    uint8_t status = 0;\n    lorawan_status_t ret_value = LORAWAN_STATUS_OK;\n\n    while (mac_index < commands_size) {\n        // Decode Frame MAC commands\n        switch (payload[mac_index++]) {\n            case SRV_MAC_LINK_CHECK_ANS:\n                mlme_conf.status = LORAMAC_EVENT_INFO_STATUS_OK;\n                mlme_conf.demod_margin = payload[mac_index++];\n                mlme_conf.nb_gateways = payload[mac_index++];\n                break;\n            case SRV_MAC_LINK_ADR_REQ: {\n                adr_req_params_t linkAdrReq;\n                int8_t linkAdrDatarate = DR_0;\n                int8_t linkAdrTxPower = TX_POWER_0;\n                uint8_t linkAdrNbRep = 0;\n                uint8_t linkAdrNbBytesParsed = 0;\n\n                // Fill parameter structure\n                linkAdrReq.payload = &payload[mac_index - 1];\n                linkAdrReq.payload_size = commands_size - (mac_index - 1);\n                linkAdrReq.adr_enabled = mac_sys_params.adr_on;\n                linkAdrReq.ul_dwell_time = mac_sys_params.uplink_dwell_time;\n                linkAdrReq.current_datarate = mac_sys_params.channel_data_rate;\n                linkAdrReq.current_tx_power = mac_sys_params.channel_tx_power;\n                linkAdrReq.current_nb_rep = mac_sys_params.retry_num;\n\n                // Process the ADR requests\n                status = lora_phy.link_ADR_request(&linkAdrReq,\n                                                   &linkAdrDatarate,\n                                                   &linkAdrTxPower,\n                                                   &linkAdrNbRep,\n                                                   &linkAdrNbBytesParsed);\n\n                if ((status & 0x07) == 0x07) {\n                    mac_sys_params.channel_data_rate = linkAdrDatarate;\n                    mac_sys_params.channel_tx_power = linkAdrTxPower;\n                    mac_sys_params.retry_num = linkAdrNbRep;\n                }\n\n                // Add the answers to the buffer\n                for (uint8_t i = 0; i < (linkAdrNbBytesParsed / 5); i++) {\n                    ret_value = add_link_adr_ans(status);\n                }\n                // Update MAC index\n                mac_index += linkAdrNbBytesParsed - 1;\n            }\n                break;\n            case SRV_MAC_DUTY_CYCLE_REQ:\n                mac_sys_params.max_duty_cycle = payload[mac_index++];\n                mac_sys_params.aggregated_duty_cycle = 1 << mac_sys_params.max_duty_cycle;\n                ret_value = add_duty_cycle_ans();\n                break;\n            case SRV_MAC_RX_PARAM_SETUP_REQ: {\n                rx_param_setup_req_t rxParamSetupReq;\n\n                rxParamSetupReq.dr_offset = (payload[mac_index] >> 4) & 0x07;\n                rxParamSetupReq.datarate = payload[mac_index] & 0x0F;\n                mac_index++;\n\n                rxParamSetupReq.frequency = (uint32_t) payload[mac_index++];\n                rxParamSetupReq.frequency |= (uint32_t) payload[mac_index++] << 8;\n                rxParamSetupReq.frequency |= (uint32_t) payload[mac_index++] << 16;\n                rxParamSetupReq.frequency *= 100;\n\n                // Perform request on region\n                status = lora_phy.accept_rx_param_setup_req(&rxParamSetupReq);\n\n                if ((status & 0x07) == 0x07) {\n                    mac_sys_params.rx2_channel.datarate = rxParamSetupReq.datarate;\n                    mac_sys_params.rx2_channel.frequency = rxParamSetupReq.frequency;\n                    mac_sys_params.rx1_dr_offset = rxParamSetupReq.dr_offset;\n                }\n                ret_value = add_rx_param_setup_ans(status);\n            }\n                break;\n            case SRV_MAC_DEV_STATUS_REQ: {\n                uint8_t battery_level = BAT_LEVEL_NO_MEASURE;\n                if (_battery_level_cb) {\n                    battery_level = _battery_level_cb();\n                }\n                ret_value = add_dev_status_ans(battery_level, snr & 0x3F);\n                break;\n            }\n            case SRV_MAC_NEW_CHANNEL_REQ: {\n                channel_params_t chParam;\n                int8_t channel_id = payload[mac_index++];\n\n                chParam.frequency = (uint32_t) payload[mac_index++];\n                chParam.frequency |= (uint32_t) payload[mac_index++] << 8;\n                chParam.frequency |= (uint32_t) payload[mac_index++] << 16;\n                chParam.frequency *= 100;\n                chParam.rx1_frequency = 0;\n                chParam.dr_range.value = payload[mac_index++];\n\n                status = lora_phy.request_new_channel(channel_id, &chParam);\n\n                ret_value = add_new_channel_ans(status);\n            }\n                break;\n            case SRV_MAC_RX_TIMING_SETUP_REQ: {\n                uint8_t delay = payload[mac_index++] & 0x0F;\n\n                if (delay == 0) {\n                    delay++;\n                }\n                mac_sys_params.recv_delay1 = delay * 1000;\n                mac_sys_params.recv_delay2 = mac_sys_params.recv_delay1 + 1000;\n                ret_value = add_rx_timing_setup_ans();\n            }\n                break;\n            case SRV_MAC_TX_PARAM_SETUP_REQ: {\n                uint8_t eirpDwellTime = payload[mac_index++];\n                uint8_t ul_dwell_time;\n                uint8_t dl_dwell_time;\n                uint8_t max_eirp;\n\n                ul_dwell_time = 0;\n                dl_dwell_time = 0;\n\n                if ((eirpDwellTime & 0x20) == 0x20) {\n                    dl_dwell_time = 1;\n                }\n                if ((eirpDwellTime & 0x10) == 0x10) {\n                    ul_dwell_time = 1;\n                }\n                max_eirp = eirpDwellTime & 0x0F;\n\n                // Check the status for correctness\n                if (lora_phy.accept_tx_param_setup_req(ul_dwell_time, dl_dwell_time)) {\n                    // Accept command\n                    mac_sys_params.uplink_dwell_time = ul_dwell_time;\n                    mac_sys_params.downlink_dwell_time = dl_dwell_time;\n                    mac_sys_params.max_eirp = max_eirp_table[max_eirp];\n                    // Add command response\n                    ret_value = add_tx_param_setup_ans();\n                }\n            }\n                break;\n            case SRV_MAC_DL_CHANNEL_REQ: {\n                uint8_t channel_id = payload[mac_index++];\n                uint32_t rx1_frequency;\n\n                rx1_frequency = (uint32_t) payload[mac_index++];\n                rx1_frequency |= (uint32_t) payload[mac_index++] << 8;\n                rx1_frequency |= (uint32_t) payload[mac_index++] << 16;\n                rx1_frequency *= 100;\n                status = lora_phy.dl_channel_request(channel_id, rx1_frequency);\n\n                ret_value = add_dl_channel_ans(status);\n            }\n                break;\n            default:\n                // Unknown command. ABORT MAC commands processing\n                ret_value = LORAWAN_STATUS_UNSUPPORTED;\n        }\n    }\n    return ret_value;\n}\n\nbool LoRaMacCommand::is_sticky_mac_command_pending()\n{\n    if (mac_cmd_buf_idx_to_repeat > 0) {\n        return true;\n    }\n    return false;\n}\n\nint32_t LoRaMacCommand::cmd_buffer_remaining() const\n{\n    // The maximum buffer length must take MAC commands to re-send into account.\n    return sizeof(mac_cmd_buffer) - mac_cmd_buf_idx_to_repeat - mac_cmd_buf_idx;\n}\n\nvoid LoRaMacCommand::set_batterylevel_callback(mbed::Callback<uint8_t(void)> battery_level)\n{\n    _battery_level_cb = battery_level;\n}\n\nlorawan_status_t LoRaMacCommand::add_link_check_req()\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 0) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_LINK_CHECK_REQ;\n        // No payload for this command\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_link_adr_ans(uint8_t status)\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 1) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_LINK_ADR_ANS;\n        mac_cmd_buffer[mac_cmd_buf_idx++] = status;\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_duty_cycle_ans()\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 0) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_DUTY_CYCLE_ANS;\n        // No payload for this answer\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_rx_param_setup_ans(uint8_t status)\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 1) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_RX_PARAM_SETUP_ANS;\n        // Status: Datarate ACK, Channel ACK\n        mac_cmd_buffer[mac_cmd_buf_idx++] = status;\n        // This is a sticky MAC command answer. Setup indication\n        sticky_mac_cmd = true;\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_dev_status_ans(uint8_t battery, uint8_t margin)\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 2) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_DEV_STATUS_ANS;\n        // 1st byte Battery\n        // 2nd byte Margin\n        mac_cmd_buffer[mac_cmd_buf_idx++] = battery;\n        mac_cmd_buffer[mac_cmd_buf_idx++] = margin;\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_new_channel_ans(uint8_t status)\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 1) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_NEW_CHANNEL_ANS;\n        // Status: Datarate range OK, Channel frequency OK\n        mac_cmd_buffer[mac_cmd_buf_idx++] = status;\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_rx_timing_setup_ans()\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 0) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_RX_TIMING_SETUP_ANS;\n        // No payload for this answer\n        // This is a sticky MAC command answer. Setup indication\n        sticky_mac_cmd = true;\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_tx_param_setup_ans()\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 0) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_TX_PARAM_SETUP_ANS;\n        // No payload for this answer\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n\nlorawan_status_t LoRaMacCommand::add_dl_channel_ans(uint8_t status)\n{\n    lorawan_status_t ret = LORAWAN_STATUS_LENGTH_ERROR;\n    if (cmd_buffer_remaining() > 0) {\n        mac_cmd_buffer[mac_cmd_buf_idx++] = MOTE_MAC_DL_CHANNEL_ANS;\n        // Status: Uplink frequency exists, Channel frequency OK\n        mac_cmd_buffer[mac_cmd_buf_idx++] = status;\n        // This is a sticky MAC command answer. Setup indication\n        sticky_mac_cmd = true;\n        ret = LORAWAN_STATUS_OK;\n        mac_cmd_in_next_tx = true;\n    }\n    return ret;\n}\n","/*\n *  FIPS-197 compliant AES implementation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n/*\n *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.\n *\n *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf\n *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_AES_C)\n\n#include <string.h>\n\n#include \"mbedtls/aes.h\"\n#include \"mbedtls/platform_util.h\"\n#if defined(MBEDTLS_PADLOCK_C)\n#include \"mbedtls/padlock.h\"\n#endif\n#if defined(MBEDTLS_AESNI_C)\n#include \"mbedtls/aesni.h\"\n#endif\n\n#if defined(MBEDTLS_SELF_TEST)\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdio.h>\n#define mbedtls_printf printf\n#endif /* MBEDTLS_PLATFORM_C */\n#endif /* MBEDTLS_SELF_TEST */\n\n#if !defined(MBEDTLS_AES_ALT)\n\n/*\n * 32-bit integer manipulation macros (little endian)\n */\n#ifndef GET_UINT32_LE\n#define GET_UINT32_LE(n,b,i)                            \\\n{                                                       \\\n    (n) = ( (uint32_t) (b)[(i)    ]       )             \\\n        | ( (uint32_t) (b)[(i) + 1] <<  8 )             \\\n        | ( (uint32_t) (b)[(i) + 2] << 16 )             \\\n        | ( (uint32_t) (b)[(i) + 3] << 24 );            \\\n}\n#endif\n\n#ifndef PUT_UINT32_LE\n#define PUT_UINT32_LE(n,b,i)                                    \\\n{                                                               \\\n    (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );    \\\n    (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );    \\\n    (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );    \\\n    (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    \\\n}\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) &&                      \\\n    ( defined(MBEDTLS_HAVE_X86) || defined(MBEDTLS_PADLOCK_ALIGN16) )\nstatic int aes_padlock_ace = -1;\n#endif\n\n#if defined(MBEDTLS_AES_ROM_TABLES)\n/*\n * Forward S-box\n */\nstatic const unsigned char FSb[256] =\n{\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,\n    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,\n    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,\n    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,\n    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,\n    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,\n    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,\n    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,\n    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,\n    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,\n    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,\n    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,\n    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,\n    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,\n    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,\n    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,\n    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n};\n\n/*\n * Forward tables\n */\n#define FT \\\n\\\n    V(A5,63,63,C6), V(84,7C,7C,F8), V(99,77,77,EE), V(8D,7B,7B,F6), \\\n    V(0D,F2,F2,FF), V(BD,6B,6B,D6), V(B1,6F,6F,DE), V(54,C5,C5,91), \\\n    V(50,30,30,60), V(03,01,01,02), V(A9,67,67,CE), V(7D,2B,2B,56), \\\n    V(19,FE,FE,E7), V(62,D7,D7,B5), V(E6,AB,AB,4D), V(9A,76,76,EC), \\\n    V(45,CA,CA,8F), V(9D,82,82,1F), V(40,C9,C9,89), V(87,7D,7D,FA), \\\n    V(15,FA,FA,EF), V(EB,59,59,B2), V(C9,47,47,8E), V(0B,F0,F0,FB), \\\n    V(EC,AD,AD,41), V(67,D4,D4,B3), V(FD,A2,A2,5F), V(EA,AF,AF,45), \\\n    V(BF,9C,9C,23), V(F7,A4,A4,53), V(96,72,72,E4), V(5B,C0,C0,9B), \\\n    V(C2,B7,B7,75), V(1C,FD,FD,E1), V(AE,93,93,3D), V(6A,26,26,4C), \\\n    V(5A,36,36,6C), V(41,3F,3F,7E), V(02,F7,F7,F5), V(4F,CC,CC,83), \\\n    V(5C,34,34,68), V(F4,A5,A5,51), V(34,E5,E5,D1), V(08,F1,F1,F9), \\\n    V(93,71,71,E2), V(73,D8,D8,AB), V(53,31,31,62), V(3F,15,15,2A), \\\n    V(0C,04,04,08), V(52,C7,C7,95), V(65,23,23,46), V(5E,C3,C3,9D), \\\n    V(28,18,18,30), V(A1,96,96,37), V(0F,05,05,0A), V(B5,9A,9A,2F), \\\n    V(09,07,07,0E), V(36,12,12,24), V(9B,80,80,1B), V(3D,E2,E2,DF), \\\n    V(26,EB,EB,CD), V(69,27,27,4E), V(CD,B2,B2,7F), V(9F,75,75,EA), \\\n    V(1B,09,09,12), V(9E,83,83,1D), V(74,2C,2C,58), V(2E,1A,1A,34), \\\n    V(2D,1B,1B,36), V(B2,6E,6E,DC), V(EE,5A,5A,B4), V(FB,A0,A0,5B), \\\n    V(F6,52,52,A4), V(4D,3B,3B,76), V(61,D6,D6,B7), V(CE,B3,B3,7D), \\\n    V(7B,29,29,52), V(3E,E3,E3,DD), V(71,2F,2F,5E), V(97,84,84,13), \\\n    V(F5,53,53,A6), V(68,D1,D1,B9), V(00,00,00,00), V(2C,ED,ED,C1), \\\n    V(60,20,20,40), V(1F,FC,FC,E3), V(C8,B1,B1,79), V(ED,5B,5B,B6), \\\n    V(BE,6A,6A,D4), V(46,CB,CB,8D), V(D9,BE,BE,67), V(4B,39,39,72), \\\n    V(DE,4A,4A,94), V(D4,4C,4C,98), V(E8,58,58,B0), V(4A,CF,CF,85), \\\n    V(6B,D0,D0,BB), V(2A,EF,EF,C5), V(E5,AA,AA,4F), V(16,FB,FB,ED), \\\n    V(C5,43,43,86), V(D7,4D,4D,9A), V(55,33,33,66), V(94,85,85,11), \\\n    V(CF,45,45,8A), V(10,F9,F9,E9), V(06,02,02,04), V(81,7F,7F,FE), \\\n    V(F0,50,50,A0), V(44,3C,3C,78), V(BA,9F,9F,25), V(E3,A8,A8,4B), \\\n    V(F3,51,51,A2), V(FE,A3,A3,5D), V(C0,40,40,80), V(8A,8F,8F,05), \\\n    V(AD,92,92,3F), V(BC,9D,9D,21), V(48,38,38,70), V(04,F5,F5,F1), \\\n    V(DF,BC,BC,63), V(C1,B6,B6,77), V(75,DA,DA,AF), V(63,21,21,42), \\\n    V(30,10,10,20), V(1A,FF,FF,E5), V(0E,F3,F3,FD), V(6D,D2,D2,BF), \\\n    V(4C,CD,CD,81), V(14,0C,0C,18), V(35,13,13,26), V(2F,EC,EC,C3), \\\n    V(E1,5F,5F,BE), V(A2,97,97,35), V(CC,44,44,88), V(39,17,17,2E), \\\n    V(57,C4,C4,93), V(F2,A7,A7,55), V(82,7E,7E,FC), V(47,3D,3D,7A), \\\n    V(AC,64,64,C8), V(E7,5D,5D,BA), V(2B,19,19,32), V(95,73,73,E6), \\\n    V(A0,60,60,C0), V(98,81,81,19), V(D1,4F,4F,9E), V(7F,DC,DC,A3), \\\n    V(66,22,22,44), V(7E,2A,2A,54), V(AB,90,90,3B), V(83,88,88,0B), \\\n    V(CA,46,46,8C), V(29,EE,EE,C7), V(D3,B8,B8,6B), V(3C,14,14,28), \\\n    V(79,DE,DE,A7), V(E2,5E,5E,BC), V(1D,0B,0B,16), V(76,DB,DB,AD), \\\n    V(3B,E0,E0,DB), V(56,32,32,64), V(4E,3A,3A,74), V(1E,0A,0A,14), \\\n    V(DB,49,49,92), V(0A,06,06,0C), V(6C,24,24,48), V(E4,5C,5C,B8), \\\n    V(5D,C2,C2,9F), V(6E,D3,D3,BD), V(EF,AC,AC,43), V(A6,62,62,C4), \\\n    V(A8,91,91,39), V(A4,95,95,31), V(37,E4,E4,D3), V(8B,79,79,F2), \\\n    V(32,E7,E7,D5), V(43,C8,C8,8B), V(59,37,37,6E), V(B7,6D,6D,DA), \\\n    V(8C,8D,8D,01), V(64,D5,D5,B1), V(D2,4E,4E,9C), V(E0,A9,A9,49), \\\n    V(B4,6C,6C,D8), V(FA,56,56,AC), V(07,F4,F4,F3), V(25,EA,EA,CF), \\\n    V(AF,65,65,CA), V(8E,7A,7A,F4), V(E9,AE,AE,47), V(18,08,08,10), \\\n    V(D5,BA,BA,6F), V(88,78,78,F0), V(6F,25,25,4A), V(72,2E,2E,5C), \\\n    V(24,1C,1C,38), V(F1,A6,A6,57), V(C7,B4,B4,73), V(51,C6,C6,97), \\\n    V(23,E8,E8,CB), V(7C,DD,DD,A1), V(9C,74,74,E8), V(21,1F,1F,3E), \\\n    V(DD,4B,4B,96), V(DC,BD,BD,61), V(86,8B,8B,0D), V(85,8A,8A,0F), \\\n    V(90,70,70,E0), V(42,3E,3E,7C), V(C4,B5,B5,71), V(AA,66,66,CC), \\\n    V(D8,48,48,90), V(05,03,03,06), V(01,F6,F6,F7), V(12,0E,0E,1C), \\\n    V(A3,61,61,C2), V(5F,35,35,6A), V(F9,57,57,AE), V(D0,B9,B9,69), \\\n    V(91,86,86,17), V(58,C1,C1,99), V(27,1D,1D,3A), V(B9,9E,9E,27), \\\n    V(38,E1,E1,D9), V(13,F8,F8,EB), V(B3,98,98,2B), V(33,11,11,22), \\\n    V(BB,69,69,D2), V(70,D9,D9,A9), V(89,8E,8E,07), V(A7,94,94,33), \\\n    V(B6,9B,9B,2D), V(22,1E,1E,3C), V(92,87,87,15), V(20,E9,E9,C9), \\\n    V(49,CE,CE,87), V(FF,55,55,AA), V(78,28,28,50), V(7A,DF,DF,A5), \\\n    V(8F,8C,8C,03), V(F8,A1,A1,59), V(80,89,89,09), V(17,0D,0D,1A), \\\n    V(DA,BF,BF,65), V(31,E6,E6,D7), V(C6,42,42,84), V(B8,68,68,D0), \\\n    V(C3,41,41,82), V(B0,99,99,29), V(77,2D,2D,5A), V(11,0F,0F,1E), \\\n    V(CB,B0,B0,7B), V(FC,54,54,A8), V(D6,BB,BB,6D), V(3A,16,16,2C)\n\n#define V(a,b,c,d) 0x##a##b##c##d\nstatic const uint32_t FT0[256] = { FT };\n#undef V\n\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\n\n#define V(a,b,c,d) 0x##b##c##d##a\nstatic const uint32_t FT1[256] = { FT };\n#undef V\n\n#define V(a,b,c,d) 0x##c##d##a##b\nstatic const uint32_t FT2[256] = { FT };\n#undef V\n\n#define V(a,b,c,d) 0x##d##a##b##c\nstatic const uint32_t FT3[256] = { FT };\n#undef V\n\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n\n#undef FT\n\n/*\n * Reverse S-box\n */\nstatic const unsigned char RSb[256] =\n{\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n};\n\n/*\n * Reverse tables\n */\n#define RT \\\n\\\n    V(50,A7,F4,51), V(53,65,41,7E), V(C3,A4,17,1A), V(96,5E,27,3A), \\\n    V(CB,6B,AB,3B), V(F1,45,9D,1F), V(AB,58,FA,AC), V(93,03,E3,4B), \\\n    V(55,FA,30,20), V(F6,6D,76,AD), V(91,76,CC,88), V(25,4C,02,F5), \\\n    V(FC,D7,E5,4F), V(D7,CB,2A,C5), V(80,44,35,26), V(8F,A3,62,B5), \\\n    V(49,5A,B1,DE), V(67,1B,BA,25), V(98,0E,EA,45), V(E1,C0,FE,5D), \\\n    V(02,75,2F,C3), V(12,F0,4C,81), V(A3,97,46,8D), V(C6,F9,D3,6B), \\\n    V(E7,5F,8F,03), V(95,9C,92,15), V(EB,7A,6D,BF), V(DA,59,52,95), \\\n    V(2D,83,BE,D4), V(D3,21,74,58), V(29,69,E0,49), V(44,C8,C9,8E), \\\n    V(6A,89,C2,75), V(78,79,8E,F4), V(6B,3E,58,99), V(DD,71,B9,27), \\\n    V(B6,4F,E1,BE), V(17,AD,88,F0), V(66,AC,20,C9), V(B4,3A,CE,7D), \\\n    V(18,4A,DF,63), V(82,31,1A,E5), V(60,33,51,97), V(45,7F,53,62), \\\n    V(E0,77,64,B1), V(84,AE,6B,BB), V(1C,A0,81,FE), V(94,2B,08,F9), \\\n    V(58,68,48,70), V(19,FD,45,8F), V(87,6C,DE,94), V(B7,F8,7B,52), \\\n    V(23,D3,73,AB), V(E2,02,4B,72), V(57,8F,1F,E3), V(2A,AB,55,66), \\\n    V(07,28,EB,B2), V(03,C2,B5,2F), V(9A,7B,C5,86), V(A5,08,37,D3), \\\n    V(F2,87,28,30), V(B2,A5,BF,23), V(BA,6A,03,02), V(5C,82,16,ED), \\\n    V(2B,1C,CF,8A), V(92,B4,79,A7), V(F0,F2,07,F3), V(A1,E2,69,4E), \\\n    V(CD,F4,DA,65), V(D5,BE,05,06), V(1F,62,34,D1), V(8A,FE,A6,C4), \\\n    V(9D,53,2E,34), V(A0,55,F3,A2), V(32,E1,8A,05), V(75,EB,F6,A4), \\\n    V(39,EC,83,0B), V(AA,EF,60,40), V(06,9F,71,5E), V(51,10,6E,BD), \\\n    V(F9,8A,21,3E), V(3D,06,DD,96), V(AE,05,3E,DD), V(46,BD,E6,4D), \\\n    V(B5,8D,54,91), V(05,5D,C4,71), V(6F,D4,06,04), V(FF,15,50,60), \\\n    V(24,FB,98,19), V(97,E9,BD,D6), V(CC,43,40,89), V(77,9E,D9,67), \\\n    V(BD,42,E8,B0), V(88,8B,89,07), V(38,5B,19,E7), V(DB,EE,C8,79), \\\n    V(47,0A,7C,A1), V(E9,0F,42,7C), V(C9,1E,84,F8), V(00,00,00,00), \\\n    V(83,86,80,09), V(48,ED,2B,32), V(AC,70,11,1E), V(4E,72,5A,6C), \\\n    V(FB,FF,0E,FD), V(56,38,85,0F), V(1E,D5,AE,3D), V(27,39,2D,36), \\\n    V(64,D9,0F,0A), V(21,A6,5C,68), V(D1,54,5B,9B), V(3A,2E,36,24), \\\n    V(B1,67,0A,0C), V(0F,E7,57,93), V(D2,96,EE,B4), V(9E,91,9B,1B), \\\n    V(4F,C5,C0,80), V(A2,20,DC,61), V(69,4B,77,5A), V(16,1A,12,1C), \\\n    V(0A,BA,93,E2), V(E5,2A,A0,C0), V(43,E0,22,3C), V(1D,17,1B,12), \\\n    V(0B,0D,09,0E), V(AD,C7,8B,F2), V(B9,A8,B6,2D), V(C8,A9,1E,14), \\\n    V(85,19,F1,57), V(4C,07,75,AF), V(BB,DD,99,EE), V(FD,60,7F,A3), \\\n    V(9F,26,01,F7), V(BC,F5,72,5C), V(C5,3B,66,44), V(34,7E,FB,5B), \\\n    V(76,29,43,8B), V(DC,C6,23,CB), V(68,FC,ED,B6), V(63,F1,E4,B8), \\\n    V(CA,DC,31,D7), V(10,85,63,42), V(40,22,97,13), V(20,11,C6,84), \\\n    V(7D,24,4A,85), V(F8,3D,BB,D2), V(11,32,F9,AE), V(6D,A1,29,C7), \\\n    V(4B,2F,9E,1D), V(F3,30,B2,DC), V(EC,52,86,0D), V(D0,E3,C1,77), \\\n    V(6C,16,B3,2B), V(99,B9,70,A9), V(FA,48,94,11), V(22,64,E9,47), \\\n    V(C4,8C,FC,A8), V(1A,3F,F0,A0), V(D8,2C,7D,56), V(EF,90,33,22), \\\n    V(C7,4E,49,87), V(C1,D1,38,D9), V(FE,A2,CA,8C), V(36,0B,D4,98), \\\n    V(CF,81,F5,A6), V(28,DE,7A,A5), V(26,8E,B7,DA), V(A4,BF,AD,3F), \\\n    V(E4,9D,3A,2C), V(0D,92,78,50), V(9B,CC,5F,6A), V(62,46,7E,54), \\\n    V(C2,13,8D,F6), V(E8,B8,D8,90), V(5E,F7,39,2E), V(F5,AF,C3,82), \\\n    V(BE,80,5D,9F), V(7C,93,D0,69), V(A9,2D,D5,6F), V(B3,12,25,CF), \\\n    V(3B,99,AC,C8), V(A7,7D,18,10), V(6E,63,9C,E8), V(7B,BB,3B,DB), \\\n    V(09,78,26,CD), V(F4,18,59,6E), V(01,B7,9A,EC), V(A8,9A,4F,83), \\\n    V(65,6E,95,E6), V(7E,E6,FF,AA), V(08,CF,BC,21), V(E6,E8,15,EF), \\\n    V(D9,9B,E7,BA), V(CE,36,6F,4A), V(D4,09,9F,EA), V(D6,7C,B0,29), \\\n    V(AF,B2,A4,31), V(31,23,3F,2A), V(30,94,A5,C6), V(C0,66,A2,35), \\\n    V(37,BC,4E,74), V(A6,CA,82,FC), V(B0,D0,90,E0), V(15,D8,A7,33), \\\n    V(4A,98,04,F1), V(F7,DA,EC,41), V(0E,50,CD,7F), V(2F,F6,91,17), \\\n    V(8D,D6,4D,76), V(4D,B0,EF,43), V(54,4D,AA,CC), V(DF,04,96,E4), \\\n    V(E3,B5,D1,9E), V(1B,88,6A,4C), V(B8,1F,2C,C1), V(7F,51,65,46), \\\n    V(04,EA,5E,9D), V(5D,35,8C,01), V(73,74,87,FA), V(2E,41,0B,FB), \\\n    V(5A,1D,67,B3), V(52,D2,DB,92), V(33,56,10,E9), V(13,47,D6,6D), \\\n    V(8C,61,D7,9A), V(7A,0C,A1,37), V(8E,14,F8,59), V(89,3C,13,EB), \\\n    V(EE,27,A9,CE), V(35,C9,61,B7), V(ED,E5,1C,E1), V(3C,B1,47,7A), \\\n    V(59,DF,D2,9C), V(3F,73,F2,55), V(79,CE,14,18), V(BF,37,C7,73), \\\n    V(EA,CD,F7,53), V(5B,AA,FD,5F), V(14,6F,3D,DF), V(86,DB,44,78), \\\n    V(81,F3,AF,CA), V(3E,C4,68,B9), V(2C,34,24,38), V(5F,40,A3,C2), \\\n    V(72,C3,1D,16), V(0C,25,E2,BC), V(8B,49,3C,28), V(41,95,0D,FF), \\\n    V(71,01,A8,39), V(DE,B3,0C,08), V(9C,E4,B4,D8), V(90,C1,56,64), \\\n    V(61,84,CB,7B), V(70,B6,32,D5), V(74,5C,6C,48), V(42,57,B8,D0)\n\n#define V(a,b,c,d) 0x##a##b##c##d\nstatic const uint32_t RT0[256] = { RT };\n#undef V\n\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\n\n#define V(a,b,c,d) 0x##b##c##d##a\nstatic const uint32_t RT1[256] = { RT };\n#undef V\n\n#define V(a,b,c,d) 0x##c##d##a##b\nstatic const uint32_t RT2[256] = { RT };\n#undef V\n\n#define V(a,b,c,d) 0x##d##a##b##c\nstatic const uint32_t RT3[256] = { RT };\n#undef V\n\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n\n#undef RT\n\n/*\n * Round constants\n */\nstatic const uint32_t RCON[10] =\n{\n    0x00000001, 0x00000002, 0x00000004, 0x00000008,\n    0x00000010, 0x00000020, 0x00000040, 0x00000080,\n    0x0000001B, 0x00000036\n};\n\n#else /* MBEDTLS_AES_ROM_TABLES */\n\n/*\n * Forward S-box & tables\n */\nstatic unsigned char FSb[256];\nstatic uint32_t FT0[256];\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\nstatic uint32_t FT1[256];\nstatic uint32_t FT2[256];\nstatic uint32_t FT3[256];\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n\n/*\n * Reverse S-box & tables\n */\nstatic unsigned char RSb[256];\nstatic uint32_t RT0[256];\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\nstatic uint32_t RT1[256];\nstatic uint32_t RT2[256];\nstatic uint32_t RT3[256];\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n\n/*\n * Round constants\n */\nstatic uint32_t RCON[10];\n\n/*\n * Tables generation code\n */\n#define ROTL8(x) ( ( x << 8 ) & 0xFFFFFFFF ) | ( x >> 24 )\n#define XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )\n#define MUL(x,y) ( ( x && y ) ? pow[(log[x]+log[y]) % 255] : 0 )\n\nstatic int aes_init_done = 0;\n\nstatic void aes_gen_tables( void )\n{\n    int i, x, y, z;\n    int pow[256];\n    int log[256];\n\n    /*\n     * compute pow and log tables over GF(2^8)\n     */\n    for( i = 0, x = 1; i < 256; i++ )\n    {\n        pow[i] = x;\n        log[x] = i;\n        x = ( x ^ XTIME( x ) ) & 0xFF;\n    }\n\n    /*\n     * calculate the round constants\n     */\n    for( i = 0, x = 1; i < 10; i++ )\n    {\n        RCON[i] = (uint32_t) x;\n        x = XTIME( x ) & 0xFF;\n    }\n\n    /*\n     * generate the forward and reverse S-boxes\n     */\n    FSb[0x00] = 0x63;\n    RSb[0x63] = 0x00;\n\n    for( i = 1; i < 256; i++ )\n    {\n        x = pow[255 - log[i]];\n\n        y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y ^ 0x63;\n\n        FSb[i] = (unsigned char) x;\n        RSb[x] = (unsigned char) i;\n    }\n\n    /*\n     * generate the forward and reverse tables\n     */\n    for( i = 0; i < 256; i++ )\n    {\n        x = FSb[i];\n        y = XTIME( x ) & 0xFF;\n        z =  ( y ^ x ) & 0xFF;\n\n        FT0[i] = ( (uint32_t) y       ) ^\n                 ( (uint32_t) x <<  8 ) ^\n                 ( (uint32_t) x << 16 ) ^\n                 ( (uint32_t) z << 24 );\n\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\n        FT1[i] = ROTL8( FT0[i] );\n        FT2[i] = ROTL8( FT1[i] );\n        FT3[i] = ROTL8( FT2[i] );\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n\n        x = RSb[i];\n\n        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^\n                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^\n                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^\n                 ( (uint32_t) MUL( 0x0B, x ) << 24 );\n\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\n        RT1[i] = ROTL8( RT0[i] );\n        RT2[i] = ROTL8( RT1[i] );\n        RT3[i] = ROTL8( RT2[i] );\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n    }\n}\n\n#undef ROTL8\n\n#endif /* MBEDTLS_AES_ROM_TABLES */\n\n#if defined(MBEDTLS_AES_FEWER_TABLES)\n\n#define ROTL8(x)  ( (uint32_t)( ( x ) <<  8 ) + (uint32_t)( ( x ) >> 24 ) )\n#define ROTL16(x) ( (uint32_t)( ( x ) << 16 ) + (uint32_t)( ( x ) >> 16 ) )\n#define ROTL24(x) ( (uint32_t)( ( x ) << 24 ) + (uint32_t)( ( x ) >>  8 ) )\n\n#define AES_RT0(idx) RT0[idx]\n#define AES_RT1(idx) ROTL8(  RT0[idx] )\n#define AES_RT2(idx) ROTL16( RT0[idx] )\n#define AES_RT3(idx) ROTL24( RT0[idx] )\n\n#define AES_FT0(idx) FT0[idx]\n#define AES_FT1(idx) ROTL8(  FT0[idx] )\n#define AES_FT2(idx) ROTL16( FT0[idx] )\n#define AES_FT3(idx) ROTL24( FT0[idx] )\n\n#else /* MBEDTLS_AES_FEWER_TABLES */\n\n#define AES_RT0(idx) RT0[idx]\n#define AES_RT1(idx) RT1[idx]\n#define AES_RT2(idx) RT2[idx]\n#define AES_RT3(idx) RT3[idx]\n\n#define AES_FT0(idx) FT0[idx]\n#define AES_FT1(idx) FT1[idx]\n#define AES_FT2(idx) FT2[idx]\n#define AES_FT3(idx) FT3[idx]\n\n#endif /* MBEDTLS_AES_FEWER_TABLES */\n\nvoid mbedtls_aes_init( mbedtls_aes_context *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_aes_context ) );\n}\n\nvoid mbedtls_aes_free( mbedtls_aes_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_aes_context ) );\n}\n\n/*\n * AES key schedule (encryption)\n */\n#if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)\nint mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    unsigned int i;\n    uint32_t *RK;\n\n#if !defined(MBEDTLS_AES_ROM_TABLES)\n    if( aes_init_done == 0 )\n    {\n        aes_gen_tables();\n        aes_init_done = 1;\n\n    }\n#endif\n\n    switch( keybits )\n    {\n        case 128: ctx->nr = 10; break;\n        case 192: ctx->nr = 12; break;\n        case 256: ctx->nr = 14; break;\n        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );\n    else\n#endif\n    ctx->rk = RK = ctx->buf;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );\n#endif\n\n    for( i = 0; i < ( keybits >> 5 ); i++ )\n    {\n        GET_UINT32_LE( RK[i], key, i << 2 );\n    }\n\n    switch( ctx->nr )\n    {\n        case 10:\n\n            for( i = 0; i < 10; i++, RK += 4 )\n            {\n                RK[4]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );\n\n                RK[5]  = RK[1] ^ RK[4];\n                RK[6]  = RK[2] ^ RK[5];\n                RK[7]  = RK[3] ^ RK[6];\n            }\n            break;\n\n        case 12:\n\n            for( i = 0; i < 8; i++, RK += 6 )\n            {\n                RK[6]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );\n\n                RK[7]  = RK[1] ^ RK[6];\n                RK[8]  = RK[2] ^ RK[7];\n                RK[9]  = RK[3] ^ RK[8];\n                RK[10] = RK[4] ^ RK[9];\n                RK[11] = RK[5] ^ RK[10];\n            }\n            break;\n\n        case 14:\n\n            for( i = 0; i < 7; i++, RK += 8 )\n            {\n                RK[8]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );\n\n                RK[9]  = RK[1] ^ RK[8];\n                RK[10] = RK[2] ^ RK[9];\n                RK[11] = RK[3] ^ RK[10];\n\n                RK[12] = RK[4] ^\n                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );\n\n                RK[13] = RK[5] ^ RK[12];\n                RK[14] = RK[6] ^ RK[13];\n                RK[15] = RK[7] ^ RK[14];\n            }\n            break;\n    }\n\n    return( 0 );\n}\n#endif /* !MBEDTLS_AES_SETKEY_ENC_ALT */\n\n/*\n * AES key schedule (decryption)\n */\n#if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)\nint mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    int i, j, ret;\n    mbedtls_aes_context cty;\n    uint32_t *RK;\n    uint32_t *SK;\n\n    mbedtls_aes_init( &cty );\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );\n    else\n#endif\n    ctx->rk = RK = ctx->buf;\n\n    /* Also checks keybits */\n    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )\n        goto exit;\n\n    ctx->nr = cty.nr;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n    {\n        mbedtls_aesni_inverse_key( (unsigned char *) ctx->rk,\n                           (const unsigned char *) cty.rk, ctx->nr );\n        goto exit;\n    }\n#endif\n\n    SK = cty.rk + cty.nr * 4;\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\n    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )\n    {\n        for( j = 0; j < 4; j++, SK++ )\n        {\n            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^\n                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^\n                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^\n                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );\n        }\n    }\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\nexit:\n    mbedtls_aes_free( &cty );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_AES_SETKEY_DEC_ALT */\n\n#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)         \\\n{                                                   \\\n    X0 = *RK++ ^ AES_FT0( ( Y0       ) & 0xFF ) ^   \\\n                 AES_FT1( ( Y1 >>  8 ) & 0xFF ) ^   \\\n                 AES_FT2( ( Y2 >> 16 ) & 0xFF ) ^   \\\n                 AES_FT3( ( Y3 >> 24 ) & 0xFF );    \\\n                                                    \\\n    X1 = *RK++ ^ AES_FT0( ( Y1       ) & 0xFF ) ^   \\\n                 AES_FT1( ( Y2 >>  8 ) & 0xFF ) ^   \\\n                 AES_FT2( ( Y3 >> 16 ) & 0xFF ) ^   \\\n                 AES_FT3( ( Y0 >> 24 ) & 0xFF );    \\\n                                                    \\\n    X2 = *RK++ ^ AES_FT0( ( Y2       ) & 0xFF ) ^   \\\n                 AES_FT1( ( Y3 >>  8 ) & 0xFF ) ^   \\\n                 AES_FT2( ( Y0 >> 16 ) & 0xFF ) ^   \\\n                 AES_FT3( ( Y1 >> 24 ) & 0xFF );    \\\n                                                    \\\n    X3 = *RK++ ^ AES_FT0( ( Y3       ) & 0xFF ) ^   \\\n                 AES_FT1( ( Y0 >>  8 ) & 0xFF ) ^   \\\n                 AES_FT2( ( Y1 >> 16 ) & 0xFF ) ^   \\\n                 AES_FT3( ( Y2 >> 24 ) & 0xFF );    \\\n}\n\n#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)         \\\n{                                                   \\\n    X0 = *RK++ ^ AES_RT0( ( Y0       ) & 0xFF ) ^   \\\n                 AES_RT1( ( Y3 >>  8 ) & 0xFF ) ^   \\\n                 AES_RT2( ( Y2 >> 16 ) & 0xFF ) ^   \\\n                 AES_RT3( ( Y1 >> 24 ) & 0xFF );    \\\n                                                    \\\n    X1 = *RK++ ^ AES_RT0( ( Y1       ) & 0xFF ) ^   \\\n                 AES_RT1( ( Y0 >>  8 ) & 0xFF ) ^   \\\n                 AES_RT2( ( Y3 >> 16 ) & 0xFF ) ^   \\\n                 AES_RT3( ( Y2 >> 24 ) & 0xFF );    \\\n                                                    \\\n    X2 = *RK++ ^ AES_RT0( ( Y2       ) & 0xFF ) ^   \\\n                 AES_RT1( ( Y1 >>  8 ) & 0xFF ) ^   \\\n                 AES_RT2( ( Y0 >> 16 ) & 0xFF ) ^   \\\n                 AES_RT3( ( Y3 >> 24 ) & 0xFF );    \\\n                                                    \\\n    X3 = *RK++ ^ AES_RT0( ( Y3       ) & 0xFF ) ^   \\\n                 AES_RT1( ( Y2 >>  8 ) & 0xFF ) ^   \\\n                 AES_RT2( ( Y1 >> 16 ) & 0xFF ) ^   \\\n                 AES_RT3( ( Y0 >> 24 ) & 0xFF );    \\\n}\n\n/*\n * AES-ECB block encryption\n */\n#if !defined(MBEDTLS_AES_ENCRYPT_ALT)\nint mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,\n                                  const unsigned char input[16],\n                                  unsigned char output[16] )\n{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n    RK = ctx->rk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )\n    {\n        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n    }\n\n    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n    X0 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );\n\n    X1 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );\n\n    X2 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );\n\n    X3 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    return( 0 );\n}\n#endif /* !MBEDTLS_AES_ENCRYPT_ALT */\n\n#if !defined(MBEDTLS_DEPRECATED_REMOVED)\nvoid mbedtls_aes_encrypt( mbedtls_aes_context *ctx,\n                          const unsigned char input[16],\n                          unsigned char output[16] )\n{\n    mbedtls_internal_aes_encrypt( ctx, input, output );\n}\n#endif /* !MBEDTLS_DEPRECATED_REMOVED */\n\n/*\n * AES-ECB block decryption\n */\n#if !defined(MBEDTLS_AES_DECRYPT_ALT)\nint mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,\n                                  const unsigned char input[16],\n                                  unsigned char output[16] )\n{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n    RK = ctx->rk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )\n    {\n        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n    }\n\n    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n    X0 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );\n\n    X1 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );\n\n    X2 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );\n\n    X3 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    return( 0 );\n}\n#endif /* !MBEDTLS_AES_DECRYPT_ALT */\n\n#if !defined(MBEDTLS_DEPRECATED_REMOVED)\nvoid mbedtls_aes_decrypt( mbedtls_aes_context *ctx,\n                          const unsigned char input[16],\n                          unsigned char output[16] )\n{\n    mbedtls_internal_aes_decrypt( ctx, input, output );\n}\n#endif /* !MBEDTLS_DEPRECATED_REMOVED */\n\n/*\n * AES-ECB block encryption/decryption\n */\nint mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,\n                    int mode,\n                    const unsigned char input[16],\n                    unsigned char output[16] )\n{\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( mbedtls_padlock_xcryptecb( ctx, mode, input, output ) == 0 )\n            return( 0 );\n\n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    if( mode == MBEDTLS_AES_ENCRYPT )\n        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );\n    else\n        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n/*\n * AES-CBC buffer encryption/decryption\n */\nint mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx,\n                    int mode,\n                    size_t length,\n                    unsigned char iv[16],\n                    const unsigned char *input,\n                    unsigned char *output )\n{\n    int i;\n    unsigned char temp[16];\n\n    if( length % 16 )\n        return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( mbedtls_padlock_xcryptcbc( ctx, mode, length, iv, input, output ) == 0 )\n            return( 0 );\n\n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    if( mode == MBEDTLS_AES_DECRYPT )\n    {\n        while( length > 0 )\n        {\n            memcpy( temp, input, 16 );\n            mbedtls_aes_crypt_ecb( ctx, mode, input, output );\n\n            for( i = 0; i < 16; i++ )\n                output[i] = (unsigned char)( output[i] ^ iv[i] );\n\n            memcpy( iv, temp, 16 );\n\n            input  += 16;\n            output += 16;\n            length -= 16;\n        }\n    }\n    else\n    {\n        while( length > 0 )\n        {\n            for( i = 0; i < 16; i++ )\n                output[i] = (unsigned char)( input[i] ^ iv[i] );\n\n            mbedtls_aes_crypt_ecb( ctx, mode, output, output );\n            memcpy( iv, output, 16 );\n\n            input  += 16;\n            output += 16;\n            length -= 16;\n        }\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n/*\n * AES-CFB128 buffer encryption/decryption\n */\nint mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       size_t *iv_off,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    int c;\n    size_t n = *iv_off;\n\n    if( mode == MBEDTLS_AES_DECRYPT )\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );\n\n            c = *input++;\n            *output++ = (unsigned char)( c ^ iv[n] );\n            iv[n] = (unsigned char) c;\n\n            n = ( n + 1 ) & 0x0F;\n        }\n    }\n    else\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );\n\n            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );\n\n            n = ( n + 1 ) & 0x0F;\n        }\n    }\n\n    *iv_off = n;\n\n    return( 0 );\n}\n\n/*\n * AES-CFB8 buffer encryption/decryption\n */\nint mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    unsigned char c;\n    unsigned char ov[17];\n\n    while( length-- )\n    {\n        memcpy( ov, iv, 16 );\n        mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n            ov[16] = *input;\n\n        c = *output++ = (unsigned char)( iv[0] ^ *input++ );\n\n        if( mode == MBEDTLS_AES_ENCRYPT )\n            ov[16] = c;\n\n        memcpy( iv, ov + 1, 16 );\n    }\n\n    return( 0 );\n}\n#endif /*MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n/*\n * AES-CTR buffer encryption/decryption\n */\nint mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,\n                       size_t length,\n                       size_t *nc_off,\n                       unsigned char nonce_counter[16],\n                       unsigned char stream_block[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    int c, i;\n    size_t n = *nc_off;\n\n    if ( n > 0x0F )\n        return( MBEDTLS_ERR_AES_BAD_INPUT_DATA );\n\n    while( length-- )\n    {\n        if( n == 0 ) {\n            mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block );\n\n            for( i = 16; i > 0; i-- )\n                if( ++nonce_counter[i - 1] != 0 )\n                    break;\n        }\n        c = *input++;\n        *output++ = (unsigned char)( c ^ stream_block[n] );\n\n        n = ( n + 1 ) & 0x0F;\n    }\n\n    *nc_off = n;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#endif /* !MBEDTLS_AES_ALT */\n\n#if defined(MBEDTLS_SELF_TEST)\n/*\n * AES test vectors from:\n *\n * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip\n */\nstatic const unsigned char aes_test_ecb_dec[3][16] =\n{\n    { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,\n      0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },\n    { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,\n      0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },\n    { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,\n      0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }\n};\n\nstatic const unsigned char aes_test_ecb_enc[3][16] =\n{\n    { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,\n      0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },\n    { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,\n      0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },\n    { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,\n      0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const unsigned char aes_test_cbc_dec[3][16] =\n{\n    { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,\n      0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },\n    { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,\n      0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },\n    { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,\n      0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }\n};\n\nstatic const unsigned char aes_test_cbc_enc[3][16] =\n{\n    { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,\n      0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },\n    { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,\n      0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },\n    { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,\n      0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n/*\n * AES-CFB128 test vectors from:\n *\n * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf\n */\nstatic const unsigned char aes_test_cfb128_key[3][32] =\n{\n    { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,\n      0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },\n    { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,\n      0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,\n      0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },\n    { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,\n      0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,\n      0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,\n      0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }\n};\n\nstatic const unsigned char aes_test_cfb128_iv[16] =\n{\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F\n};\n\nstatic const unsigned char aes_test_cfb128_pt[64] =\n{\n    0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,\n    0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,\n    0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,\n    0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,\n    0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,\n    0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,\n    0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,\n    0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10\n};\n\nstatic const unsigned char aes_test_cfb128_ct[3][64] =\n{\n    { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,\n      0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,\n      0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,\n      0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,\n      0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,\n      0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,\n      0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,\n      0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6 },\n    { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,\n      0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,\n      0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,\n      0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,\n      0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,\n      0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,\n      0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,\n      0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF },\n    { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,\n      0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,\n      0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,\n      0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,\n      0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,\n      0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,\n      0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,\n      0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71 }\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n/*\n * AES-CTR test vectors from:\n *\n * http://www.faqs.org/rfcs/rfc3686.html\n */\n\nstatic const unsigned char aes_test_ctr_key[3][16] =\n{\n    { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,\n      0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },\n    { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,\n      0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },\n    { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,\n      0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }\n};\n\nstatic const unsigned char aes_test_ctr_nonce_counter[3][16] =\n{\n    { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },\n    { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,\n      0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },\n    { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,\n      0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }\n};\n\nstatic const unsigned char aes_test_ctr_pt[3][48] =\n{\n    { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,\n      0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },\n\n    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },\n\n    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n      0x20, 0x21, 0x22, 0x23 }\n};\n\nstatic const unsigned char aes_test_ctr_ct[3][48] =\n{\n    { 0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,\n      0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8 },\n    { 0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,\n      0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,\n      0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,\n      0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28 },\n    { 0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,\n      0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,\n      0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,\n      0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,\n      0x25, 0xB2, 0x07, 0x2F }\n};\n\nstatic const int aes_test_ctr_len[3] =\n    { 16, 32, 36 };\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n/*\n * Checkup routine\n */\nint mbedtls_aes_self_test( int verbose )\n{\n    int ret = 0, i, j, u, mode;\n    unsigned int keybits;\n    unsigned char key[32];\n    unsigned char buf[64];\n    const unsigned char *aes_tests;\n#if defined(MBEDTLS_CIPHER_MODE_CBC) || defined(MBEDTLS_CIPHER_MODE_CFB)\n    unsigned char iv[16];\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    unsigned char prv[16];\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_CFB)\n    size_t offset;\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    int len;\n    unsigned char nonce_counter[16];\n    unsigned char stream_block[16];\n#endif\n    mbedtls_aes_context ctx;\n\n    memset( key, 0, 32 );\n    mbedtls_aes_init( &ctx );\n\n    /*\n     * ECB mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        keybits = 128 + u * 64;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-ECB-%3d (%s): \", keybits,\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memset( buf, 0, 16 );\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );\n            aes_tests = aes_test_ecb_dec[u];\n        }\n        else\n        {\n            ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );\n            aes_tests = aes_test_ecb_enc[u];\n        }\n\n        /*\n         * AES-192 is an optional feature that may be unavailable when\n         * there is an alternative underlying implementation i.e. when\n         * MBEDTLS_AES_ALT is defined.\n         */\n        if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )\n        {\n            mbedtls_printf( \"skipped\\n\" );\n            continue;\n        }\n        else if( ret != 0 )\n        {\n            goto exit;\n        }\n\n        for( j = 0; j < 10000; j++ )\n        {\n            ret = mbedtls_aes_crypt_ecb( &ctx, mode, buf, buf );\n            if( ret != 0 )\n                goto exit;\n        }\n\n        if( memcmp( buf, aes_tests, 16 ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    /*\n     * CBC mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        keybits = 128 + u * 64;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-CBC-%3d (%s): \", keybits,\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memset( iv , 0, 16 );\n        memset( prv, 0, 16 );\n        memset( buf, 0, 16 );\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );\n            aes_tests = aes_test_cbc_dec[u];\n        }\n        else\n        {\n            ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );\n            aes_tests = aes_test_cbc_enc[u];\n        }\n\n        /*\n         * AES-192 is an optional feature that may be unavailable when\n         * there is an alternative underlying implementation i.e. when\n         * MBEDTLS_AES_ALT is defined.\n         */\n        if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )\n        {\n            mbedtls_printf( \"skipped\\n\" );\n            continue;\n        }\n        else if( ret != 0 )\n        {\n            goto exit;\n        }\n\n        for( j = 0; j < 10000; j++ )\n        {\n            if( mode == MBEDTLS_AES_ENCRYPT )\n            {\n                unsigned char tmp[16];\n\n                memcpy( tmp, prv, 16 );\n                memcpy( prv, buf, 16 );\n                memcpy( buf, tmp, 16 );\n            }\n\n            ret = mbedtls_aes_crypt_cbc( &ctx, mode, 16, iv, buf, buf );\n            if( ret != 0 )\n                goto exit;\n\n        }\n\n        if( memcmp( buf, aes_tests, 16 ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    /*\n     * CFB128 mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        keybits = 128 + u * 64;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-CFB128-%3d (%s): \", keybits,\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memcpy( iv,  aes_test_cfb128_iv, 16 );\n        memcpy( key, aes_test_cfb128_key[u], keybits / 8 );\n\n        offset = 0;\n        ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );\n        /*\n         * AES-192 is an optional feature that may be unavailable when\n         * there is an alternative underlying implementation i.e. when\n         * MBEDTLS_AES_ALT is defined.\n         */\n        if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )\n        {\n            mbedtls_printf( \"skipped\\n\" );\n            continue;\n        }\n        else if( ret != 0 )\n        {\n            goto exit;\n        }\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            memcpy( buf, aes_test_cfb128_ct[u], 64 );\n            aes_tests = aes_test_cfb128_pt;\n        }\n        else\n        {\n            memcpy( buf, aes_test_cfb128_pt, 64 );\n            aes_tests = aes_test_cfb128_ct[u];\n        }\n\n        ret = mbedtls_aes_crypt_cfb128( &ctx, mode, 64, &offset, iv, buf, buf );\n        if( ret != 0 )\n            goto exit;\n\n        if( memcmp( buf, aes_tests, 64 ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    /*\n     * CTR mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-CTR-128 (%s): \",\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memcpy( nonce_counter, aes_test_ctr_nonce_counter[u], 16 );\n        memcpy( key, aes_test_ctr_key[u], 16 );\n\n        offset = 0;\n        if( ( ret = mbedtls_aes_setkey_enc( &ctx, key, 128 ) ) != 0 )\n            goto exit;\n\n        len = aes_test_ctr_len[u];\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            memcpy( buf, aes_test_ctr_ct[u], len );\n            aes_tests = aes_test_ctr_pt[u];\n        }\n        else\n        {\n            memcpy( buf, aes_test_ctr_pt[u], len );\n            aes_tests = aes_test_ctr_ct[u];\n        }\n\n        ret = mbedtls_aes_crypt_ctr( &ctx, len, &offset, nonce_counter,\n                                     stream_block, buf, buf );\n        if( ret != 0 )\n            goto exit;\n\n        if( memcmp( buf, aes_tests, len ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n    ret = 0;\n\nexit:\n    if( ret != 0 && verbose != 0 )\n        mbedtls_printf( \"failed\\n\" );\n\n    mbedtls_aes_free( &ctx );\n\n    return( ret );\n}\n\n#endif /* MBEDTLS_SELF_TEST */\n\n#endif /* MBEDTLS_AES_C */\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n\n#include \"LoRaPHY.h\"\n\n#define BACKOFF_DC_1_HOUR       100\n#define BACKOFF_DC_10_HOURS     1000\n#define BACKOFF_DC_24_HOURS     10000\n\n#define CHANNELS_IN_MASK  16\n\nLoRaPHY::LoRaPHY(LoRaWANTimeHandler &lora_time)\n    : _radio(NULL),\n      _lora_time(lora_time)\n{\n    memset(&phy_params, 0, sizeof(phy_params));\n}\n\nLoRaPHY::~LoRaPHY()\n{\n    _radio = NULL;\n}\n\nbool LoRaPHY::mask_bit_test(const uint16_t *mask, unsigned bit) {\n    return mask[bit/16] & (1U << (bit % 16));\n}\n\nvoid LoRaPHY::mask_bit_set(uint16_t *mask, unsigned bit) {\n    mask[bit/16] |= (1U << (bit % 16));\n}\n\nvoid LoRaPHY::mask_bit_clear(uint16_t *mask, unsigned bit) {\n    mask[bit/16] &= ~(1U << (bit % 16));\n}\n\nvoid LoRaPHY::set_radio_instance(LoRaRadio& radio)\n{\n    _radio = &radio;\n}\n\nvoid LoRaPHY::put_radio_to_sleep() {\n    _radio->lock();\n    _radio->sleep();\n    _radio->unlock();\n}\n\nvoid LoRaPHY::put_radio_to_standby() {\n    _radio->lock();\n    _radio->standby();\n    _radio->unlock();\n}\n\nvoid LoRaPHY::setup_public_network_mode(bool set)\n{\n    _radio->lock();\n    _radio->set_public_network(set);\n    _radio->unlock();\n}\n\nvoid LoRaPHY::setup_rx_window(bool rx_continuous, uint32_t max_rx_window)\n{\n    _radio->lock();\n    if (!rx_continuous) {\n        _radio->receive(max_rx_window);\n    } else {\n        _radio->receive(0); // Continuous mode\n    }\n    _radio->unlock();\n}\n\n// For DevNonce for example\nuint32_t LoRaPHY::get_radio_rng()\n{\n    uint32_t rand;\n\n    _radio->lock();\n    rand =_radio->random();\n    _radio->unlock();\n\n    return rand;\n}\n\nvoid LoRaPHY::handle_send(uint8_t *buf, uint8_t size)\n{\n    _radio->lock();\n    _radio->send(buf, size);\n    _radio->unlock();\n}\n\nuint8_t LoRaPHY::request_new_channel(int8_t channel_id, channel_params_t* new_channel)\n{\n    if (!phy_params.custom_channelplans_supported) {\n        return 0;\n    }\n\n    uint8_t status = 0x03;\n\n    if (new_channel->frequency == 0) {\n        // Remove\n        if (remove_channel(channel_id) == false) {\n            status &= 0xFC;\n        }\n    } else {\n        new_channel->band = lookup_band_for_frequency(new_channel->frequency);\n        switch (add_channel(new_channel, channel_id)) {\n            case LORAWAN_STATUS_OK:\n            {\n                break;\n            }\n            case LORAWAN_STATUS_FREQUENCY_INVALID:\n            {\n                status &= 0xFE;\n                break;\n            }\n            case LORAWAN_STATUS_DATARATE_INVALID:\n            {\n                status &= 0xFD;\n                break;\n            }\n            case LORAWAN_STATUS_FREQ_AND_DR_INVALID:\n            {\n                status &= 0xFC;\n                break;\n            }\n            default:\n            {\n                status &= 0xFC;\n                break;\n            }\n        }\n    }\n\n    return status;\n}\n\nint32_t LoRaPHY::get_random(int32_t min, int32_t max)\n{\n    return (int32_t) rand() % (max - min + 1) + min;\n}\n\nbool LoRaPHY::verify_channel_DR(uint8_t nb_channels, uint16_t* channel_mask,\n                                int8_t dr, int8_t min_dr, int8_t max_dr,\n                                channel_params_t* channels)\n{\n    if (val_in_range(dr, min_dr, max_dr) == 0) {\n        return false;\n    }\n\n    for (uint8_t i = 0; i < phy_params.max_channel_cnt; i++) {\n        if (mask_bit_test(channel_mask, i)) {\n            // Check datarate validity for enabled channels\n            if (val_in_range(dr, (channels[i].dr_range.fields.min & 0x0F),\n                             (channels[i].dr_range.fields.max & 0x0F))) {\n                // At least 1 channel has been found we can return OK.\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nbool LoRaPHY::val_in_range( int8_t value, int8_t min, int8_t max )\n{\n    if ((value >= min) && (value <= max)) {\n        return true;\n    }\n\n    return false;\n}\n\nbool LoRaPHY::disable_channel(uint16_t* channel_mask, uint8_t id,\n                              uint8_t max_channels_num)\n{\n    uint8_t index = id / 16;\n\n    if ((index > phy_params.channels.mask_size) || (id >= max_channels_num)) {\n        return false;\n    }\n\n    // Deactivate channel\n    mask_bit_clear(channel_mask, id);\n\n    return true;\n}\n\nuint8_t LoRaPHY::count_bits(uint16_t mask, uint8_t nbBits)\n{\n    uint8_t nbActiveBits = 0;\n\n    for(uint8_t j = 0; j < nbBits; j++) {\n        if (mask_bit_test(&mask, j)) {\n            nbActiveBits++;\n        }\n    }\n\n    return nbActiveBits;\n}\n\nuint8_t LoRaPHY::num_active_channels(uint16_t* channel_mask, uint8_t start_idx,\n                                     uint8_t stop_idx)\n{\n    uint8_t nb_channels = 0;\n\n    if (channel_mask == NULL) {\n        return 0;\n    }\n\n    for (uint8_t i = start_idx; i < stop_idx; i++) {\n        nb_channels += count_bits(channel_mask[i], 16);\n    }\n\n    return nb_channels;\n}\n\nvoid LoRaPHY::copy_channel_mask(uint16_t* dest_mask, uint16_t* src_mask, uint8_t len)\n{\n    if ((dest_mask != NULL) && (src_mask != NULL)) {\n        for( uint8_t i = 0; i < len; i++ ) {\n            dest_mask[i] = src_mask[i];\n        }\n    }\n}\n\nvoid LoRaPHY::set_last_tx_done(uint8_t channel, bool joined, lorawan_time_t last_tx_done_time)\n{\n    band_t *band_table = (band_t *) phy_params.bands.table;\n    channel_params_t *channel_list = phy_params.channels.channel_list;\n\n    if (joined == true) {\n        band_table[channel_list[channel].band].last_tx_time = last_tx_done_time;\n        return;\n    }\n\n    band_table[channel_list[channel].band].last_tx_time = last_tx_done_time;\n    band_table[channel_list[channel].band].last_join_tx_time = last_tx_done_time;\n\n}\n\nlorawan_time_t LoRaPHY::update_band_timeoff(bool joined, bool duty_cycle,\n                                            band_t* bands, uint8_t nb_bands)\n{\n    lorawan_time_t next_tx_delay = (lorawan_time_t) (-1);\n\n    // Update bands Time OFF\n    for (uint8_t i = 0; i < nb_bands; i++) {\n\n        if (joined == false) {\n            uint32_t txDoneTime =  MAX(_lora_time.get_elapsed_time(bands[i].last_join_tx_time),\n                                        (duty_cycle == true) ?\n                                        _lora_time.get_elapsed_time(bands[i].last_tx_time) : 0);\n\n            if (bands[i].off_time <= txDoneTime) {\n                bands[i].off_time = 0;\n            }\n\n            if (bands[i].off_time != 0) {\n                next_tx_delay = MIN( bands[i].off_time - txDoneTime, next_tx_delay );\n            }\n\n        } else {\n            // if network has been joined\n            if (duty_cycle == true) {\n\n                if( bands[i].off_time <= _lora_time.get_elapsed_time(bands[i].last_tx_time)) {\n                    bands[i].off_time = 0;\n                }\n\n                if(bands[i].off_time != 0 ) {\n                    next_tx_delay = MIN(bands[i].off_time - _lora_time.get_elapsed_time(bands[i].last_tx_time),\n                                       next_tx_delay);\n                }\n            } else {\n                // if duty cycle is not on\n                next_tx_delay = 0;\n                bands[i].off_time = 0;\n            }\n        }\n    }\n\n    return next_tx_delay;\n}\n\nuint8_t LoRaPHY::parse_link_ADR_req(const uint8_t* payload, link_adr_params_t* params)\n{\n    uint8_t ret_index = 0;\n\n    if (payload[0] == SRV_MAC_LINK_ADR_REQ) {\n\n        // Parse datarate and tx power\n        params->datarate = payload[1];\n        params->tx_power = params->datarate & 0x0F;\n        params->datarate = (params->datarate >> 4) & 0x0F;\n\n        // Parse ChMask\n        params->channel_mask = (uint16_t) payload[2];\n        params->channel_mask |= (uint16_t) payload[3] << 8;\n\n        // Parse ChMaskCtrl and nbRep\n        params->nb_rep = payload[4];\n        params->ch_mask_ctrl = ( params->nb_rep >> 4 ) & 0x07;\n        params->nb_rep &= 0x0F;\n\n        // LinkAdrReq has 4 bytes length + 1 byte CMD\n        ret_index = 5;\n    }\n\n    return ret_index;\n}\n\nuint8_t LoRaPHY::verify_link_ADR_req(verify_adr_params_t* verify_params,\n                                     int8_t* dr, int8_t* tx_pow, uint8_t* nb_rep)\n{\n    uint8_t status = verify_params->status;\n    int8_t datarate = verify_params->datarate;\n    int8_t tx_power = verify_params->tx_power;\n    int8_t nb_repetitions = verify_params->nb_rep;\n\n    // Handle the case when ADR is off.\n    if (verify_params->adr_enabled == false) {\n        // When ADR is off, we are allowed to change the channels mask and the NbRep,\n        // if the datarate and the TX power of the LinkAdrReq are set to 0x0F.\n        if ((verify_params->datarate != 0x0F) || (verify_params->tx_power != 0x0F)) {\n            status = 0;\n            nb_repetitions = verify_params->current_nb_rep;\n        }\n\n        // Get the current datarate and tx power\n        datarate = verify_params->current_datarate;\n        tx_power = verify_params->current_tx_power;\n    }\n\n    if (status != 0) {\n        // Verify channel datarate\n        if (verify_channel_DR(phy_params.max_channel_cnt, verify_params->channel_mask,\n                              datarate, phy_params.min_tx_datarate,\n                              phy_params.max_tx_datarate, phy_params.channels.channel_list)\n                == false) {\n            status &= 0xFD; // Datarate KO\n        }\n\n        // Verify tx power\n        if (val_in_range(tx_power, phy_params.max_tx_power,\n                         phy_params.min_tx_power) == 0) {\n            // Verify if the maximum TX power is exceeded\n            if (phy_params.max_tx_power > tx_power) {\n                // Apply maximum TX power. Accept TX power.\n                tx_power = phy_params.max_tx_power;\n            } else {\n                status &= 0xFB; // TxPower KO\n            }\n        }\n    }\n\n    // If the status is ok, verify the NbRep\n    if (status == 0x07 && nb_repetitions == 0) {\n        // Restore the default value according to the LoRaWAN specification\n        nb_repetitions = 1;\n    }\n\n    // Apply changes\n    *dr = datarate;\n    *tx_pow = tx_power;\n    *nb_rep = nb_repetitions;\n\n    return status;\n}\n\ndouble LoRaPHY::compute_symb_timeout_lora(uint8_t phy_dr, uint32_t bandwidth)\n{\n    return ((double)(1 << phy_dr) / (double) bandwidth) * 1000;\n}\n\ndouble LoRaPHY::compute_symb_timeout_fsk(uint8_t phy_dr)\n{\n    return (8.0 / (double) phy_dr); // 1 symbol equals 1 byte\n}\n\nvoid LoRaPHY::get_rx_window_params(double t_symb, uint8_t min_rx_symb,\n                                   uint32_t rx_error, uint32_t wakeup_time,\n                                   uint32_t* window_timeout, int32_t* window_offset)\n{\n    // Computed number of symbols\n    *window_timeout = MAX ((uint32_t) ceil(((2 * min_rx_symb - 8) * t_symb + 2 * rx_error) / t_symb), min_rx_symb );\n    *window_offset = (int32_t) ceil((4.0 * t_symb) - ((*window_timeout * t_symb) / 2.0 ) - wakeup_time);\n}\n\nint8_t LoRaPHY::compute_tx_power(int8_t tx_power_idx, float max_eirp,\n                                 float antenna_gain)\n{\n    int8_t phy_tx_power = 0;\n\n    phy_tx_power = (int8_t) floor((max_eirp - (tx_power_idx * 2U)) - antenna_gain);\n\n    return phy_tx_power;\n}\n\n\nint8_t LoRaPHY::get_next_lower_dr(int8_t dr, int8_t min_dr)\n{\n    uint8_t next_lower_dr = dr;\n\n    do {\n        if (next_lower_dr != min_dr) {\n            next_lower_dr -= 1;\n        }\n    } while((next_lower_dr != min_dr) && !is_datarate_supported(next_lower_dr));\n\n    return next_lower_dr;\n}\n\nuint8_t LoRaPHY::get_bandwidth(uint8_t dr)\n{\n    uint32_t *bandwidths = (uint32_t *) phy_params.bandwidths.table;\n\n    switch(bandwidths[dr]) {\n        default:\n        case 125000:\n            return 0;\n        case 250000:\n            return 1;\n        case 500000:\n            return 2;\n    }\n}\n\nuint8_t LoRaPHY::enabled_channel_count(bool joined, uint8_t datarate,\n                                       const uint16_t *channel_mask,\n                                       uint8_t *channel_indices,\n                                       uint8_t *delayTx)\n{\n    uint8_t count = 0;\n    uint8_t delay_transmission = 0;\n\n    for (uint8_t i = 0; i < phy_params.max_channel_cnt; i++) {\n        if (mask_bit_test(channel_mask, i)) {\n\n            if (val_in_range(datarate, phy_params.channels.channel_list[i].dr_range.fields.min,\n                             phy_params.channels.channel_list[i].dr_range.fields.max ) == 0) {\n                // data rate range invalid for this channel\n                continue;\n            }\n\n            band_t *band_table = (band_t *) phy_params.bands.table;\n            if (band_table[phy_params.channels.channel_list[i].band].off_time > 0) {\n                // Check if the band is available for transmission\n                delay_transmission++;\n                continue;\n            }\n\n            // otherwise count the channel as enabled\n            channel_indices[count++] = i;\n        }\n    }\n\n    *delayTx = delay_transmission;\n\n    return count;\n}\n\nbool LoRaPHY::is_datarate_supported(const int8_t datarate) const\n{\n    if (datarate < phy_params.datarates.size) {\n        return (((uint8_t *)phy_params.datarates.table)[datarate] != 0) ? true : false;\n    } else {\n        return false;\n    }\n}\n\nvoid LoRaPHY::reset_to_default_values(loramac_protocol_params *params, bool init)\n{\n    if (init) {\n        params->is_dutycycle_on = phy_params.duty_cycle_enabled;\n\n        params->sys_params.max_rx_win_time = phy_params.max_rx_window;\n\n        params->sys_params.recv_delay1 = phy_params.recv_delay1;\n\n        params->sys_params.recv_delay2 = phy_params.recv_delay2;\n\n        params->sys_params.join_accept_delay1 = phy_params.join_accept_delay1;\n\n        params->sys_params.join_accept_delay2 = phy_params.join_accept_delay2;\n\n        params->sys_params.downlink_dwell_time = phy_params.dl_dwell_time_setting;\n    }\n\n    params->sys_params.channel_tx_power = get_default_tx_power();\n\n    params->sys_params.channel_data_rate = get_default_tx_datarate();\n\n    params->sys_params.rx1_dr_offset = phy_params.default_rx1_dr_offset;\n\n    params->sys_params.rx2_channel.frequency = get_default_rx2_frequency();\n\n    params->sys_params.rx2_channel.datarate = get_default_rx2_datarate();\n\n    params->sys_params.uplink_dwell_time = phy_params.ul_dwell_time_setting;\n\n    params->sys_params.max_eirp = phy_params.default_max_eirp;\n\n    params->sys_params.antenna_gain = phy_params.default_antenna_gain;\n}\n\nint8_t LoRaPHY::get_next_lower_tx_datarate(int8_t datarate)\n{\n    if (phy_params.ul_dwell_time_setting == 0) {\n        return get_next_lower_dr(datarate, phy_params.min_tx_datarate);\n    }\n\n    return get_next_lower_dr(datarate, phy_params.dwell_limit_datarate);\n\n}\n\nuint8_t LoRaPHY::get_minimum_rx_datarate()\n{\n    if (phy_params.dl_dwell_time_setting == 0) {\n        return phy_params.min_rx_datarate;\n    }\n    return phy_params.dwell_limit_datarate;\n}\n\nuint8_t LoRaPHY::get_minimum_tx_datarate()\n{\n    if (phy_params.ul_dwell_time_setting == 0) {\n        return phy_params.min_tx_datarate;\n    }\n    return phy_params.dwell_limit_datarate;\n}\n\nuint8_t LoRaPHY::get_default_tx_datarate()\n{\n    return phy_params.default_datarate;\n}\n\nuint8_t LoRaPHY::get_default_tx_power()\n{\n    return phy_params.default_tx_power;\n}\n\nuint8_t LoRaPHY::get_max_payload(uint8_t datarate, bool use_repeater)\n{\n    uint8_t *payload_table = NULL;\n\n    if (use_repeater) {\n//        if (datarate >= phy_params.payloads_with_repeater.size) {\n//            //TODO: Can this ever happen? If yes, should we return 0?\n//        }\n        payload_table = (uint8_t *) phy_params.payloads_with_repeater.table;\n    } else {\n        payload_table = (uint8_t *) phy_params.payloads.table;\n    }\n\n    return payload_table[datarate];\n}\n\nuint16_t LoRaPHY::get_maximum_frame_counter_gap()\n{\n    return phy_params.max_fcnt_gap;\n}\n\nuint32_t LoRaPHY::get_ack_timeout()\n{\n    uint16_t ack_timeout_rnd = phy_params.ack_timeout_rnd;\n    return (phy_params.ack_timeout\n            + get_random(-ack_timeout_rnd, ack_timeout_rnd));\n}\n\nuint32_t LoRaPHY::get_default_rx2_frequency()\n{\n    return phy_params.rx_window2_frequency;\n}\n\nuint8_t LoRaPHY::get_default_rx2_datarate()\n{\n    return phy_params.rx_window2_datarate;\n}\n\nuint16_t* LoRaPHY::get_channel_mask(bool get_default)\n{\n    if (get_default) {\n        return phy_params.channels.default_mask;\n    }\n    return phy_params.channels.mask;\n}\n\nuint8_t LoRaPHY::get_max_nb_channels()\n{\n    return phy_params.max_channel_cnt;\n}\n\nchannel_params_t* LoRaPHY::get_phy_channels()\n{\n    return phy_params.channels.channel_list;\n}\n\nbool LoRaPHY::is_custom_channel_plan_supported()\n{\n    return phy_params.custom_channelplans_supported;\n}\n\nvoid LoRaPHY::restore_default_channels()\n{\n    // Restore channels default mask\n    for (uint8_t i=0; i < phy_params.channels.mask_size; i++) {\n        phy_params.channels.mask[i] |= phy_params.channels.default_mask[i];\n    }\n}\n\nbool LoRaPHY::verify_rx_datarate(uint8_t datarate)\n{\n    if (is_datarate_supported(datarate)) {\n        if (phy_params.dl_dwell_time_setting == 0) {\n            //TODO: Check this! datarate must be same as minimum! Can be compared directly if OK\n            return val_in_range(datarate,\n                                phy_params.min_rx_datarate,\n                                phy_params.max_rx_datarate);\n        } else {\n            return val_in_range(datarate,\n                                phy_params.dwell_limit_datarate,\n                                phy_params.max_rx_datarate );\n        }\n    }\n    return false;\n}\n\nbool LoRaPHY::verify_tx_datarate(uint8_t datarate, bool use_default)\n{\n    if (!is_datarate_supported(datarate)) {\n        return false;\n    }\n\n    if (use_default) {\n        return val_in_range(datarate, phy_params.default_datarate,\n                            phy_params.default_max_datarate);\n    } else if (phy_params.ul_dwell_time_setting == 0) {\n        return val_in_range(datarate, phy_params.min_tx_datarate,\n                            phy_params.max_tx_datarate);\n    } else {\n        return val_in_range(datarate, phy_params.dwell_limit_datarate,\n                            phy_params.max_tx_datarate);\n    }\n}\n\nbool LoRaPHY::verify_tx_power(uint8_t tx_power)\n{\n    return val_in_range(tx_power, phy_params.max_tx_power,\n                        phy_params.min_tx_power);\n}\n\nbool LoRaPHY::verify_duty_cycle(bool cycle)\n{\n    if (cycle == phy_params.duty_cycle_enabled) {\n        return true;\n    }\n    return false;\n}\n\nbool LoRaPHY::verify_nb_join_trials(uint8_t nb_join_trials)\n{\n    if (nb_join_trials < MBED_CONF_LORA_NB_TRIALS) {\n        return false;\n    }\n    return true;\n}\n\nvoid LoRaPHY::apply_cf_list(const uint8_t* payload, uint8_t size)\n{\n    // if the underlying PHY doesn't support CF-List, ignore the request\n    if (!phy_params.cflist_supported) {\n        return;\n    }\n\n    channel_params_t new_channel;\n\n    // Setup default datarate range\n    new_channel.dr_range.value = (phy_params.default_max_datarate << 4)\n            | phy_params.default_datarate;\n\n    // Size of the optional CF list\n    if (size != 16) {\n        return;\n    }\n\n    // Last byte is RFU, don't take it into account\n    // NOTE: Currently the PHY layers supported by LoRaWAN who accept a CF-List\n    // define first 2 or 3 channels as default channels. this function is\n    // written keeping that in mind. If there would be a PHY in the future that\n    // accepts CF-list but have haphazard allocation of default channels, we\n    // should override this function in the implementation of that particular\n    // PHY.\n    for (uint8_t i = 0, channel_id = phy_params.default_channel_cnt;\n         channel_id < phy_params.max_channel_cnt; i+=3, channel_id++) {\n        if (channel_id < (phy_params.cflist_channel_cnt + phy_params.default_channel_cnt)) {\n            // Channel frequency\n            new_channel.frequency = (uint32_t) payload[i];\n            new_channel.frequency |= ((uint32_t) payload[i + 1] << 8);\n            new_channel.frequency |= ((uint32_t) payload[i + 2] << 16);\n            new_channel.frequency *= 100;\n\n            // Initialize alternative frequency to 0\n            new_channel.rx1_frequency = 0;\n        } else {\n            new_channel.frequency = 0;\n            new_channel.dr_range.value = 0;\n            new_channel.rx1_frequency = 0;\n        }\n\n        if (new_channel.frequency != 0) {\n            //lookup for band\n            new_channel.band = lookup_band_for_frequency(new_channel.frequency);\n\n            // Try to add channel\n            add_channel(&new_channel, channel_id);\n        } else {\n            remove_channel(channel_id);\n        }\n    }\n}\n\n\nbool LoRaPHY::get_next_ADR(bool restore_channel_mask, int8_t& dr_out,\n                           int8_t& tx_power_out, uint32_t& adr_ack_cnt)\n{\n    bool set_adr_ack_bit = false;\n\n    uint16_t ack_limit_plus_delay = phy_params.adr_ack_limit + phy_params.adr_ack_delay;\n\n    if (dr_out == phy_params.min_tx_datarate) {\n        adr_ack_cnt = 0;\n        return set_adr_ack_bit;\n    }\n\n    if (adr_ack_cnt < phy_params.adr_ack_limit) {\n        return set_adr_ack_bit;\n    }\n\n    // ADR ack counter is larger than ADR-ACK-LIMIT\n    set_adr_ack_bit = true;\n    tx_power_out = phy_params.max_tx_power;\n\n    if (adr_ack_cnt >= ack_limit_plus_delay) {\n        if ((adr_ack_cnt % phy_params.adr_ack_delay) == 1) {\n            // Decrease the datarate\n            dr_out = get_next_lower_tx_datarate(dr_out);\n\n            if (dr_out == phy_params.min_tx_datarate) {\n                // We must set adrAckReq to false as soon as we reach the lowest datarate\n                set_adr_ack_bit = false;\n                if (restore_channel_mask) {\n                    // Re-enable default channels\n                    restore_default_channels();\n                }\n            }\n        }\n    }\n\n    return set_adr_ack_bit;\n}\n\nvoid LoRaPHY::compute_rx_win_params(int8_t datarate, uint8_t min_rx_symbols,\n                                    uint32_t rx_error,\n                                    rx_config_params_t *rx_conf_params)\n{\n    double t_symbol = 0.0;\n\n    // Get the datarate, perform a boundary check\n    rx_conf_params->datarate = MIN( datarate, phy_params.max_rx_datarate);\n\n    rx_conf_params->bandwidth = get_bandwidth(rx_conf_params->datarate);\n\n    if (phy_params.fsk_supported && rx_conf_params->datarate == phy_params.max_rx_datarate) {\n        // FSK\n        t_symbol = compute_symb_timeout_fsk(((uint8_t *)phy_params.datarates.table)[rx_conf_params->datarate]);\n    } else {\n        // LoRa\n        t_symbol = compute_symb_timeout_lora(((uint8_t *)phy_params.datarates.table)[rx_conf_params->datarate],\n                                            ((uint32_t *)phy_params.bandwidths.table)[rx_conf_params->datarate]);\n    }\n\n    get_rx_window_params(t_symbol, min_rx_symbols, rx_error, RADIO_WAKEUP_TIME,\n                         &rx_conf_params->window_timeout, &rx_conf_params->window_offset);\n}\n\nbool LoRaPHY::rx_config(rx_config_params_t* rx_conf)\n{\n    radio_modems_t modem;\n    uint8_t dr = rx_conf->datarate;\n    uint8_t max_payload = 0;\n    uint8_t phy_dr = 0;\n    uint32_t frequency = rx_conf->frequency;\n\n    _radio->lock();\n\n    if (_radio->get_status() != RF_IDLE) {\n        _radio->unlock();\n        return false;\n    }\n\n    _radio->unlock();\n\n    if (rx_conf->rx_slot == RX_SLOT_WIN_1) {\n        // Apply window 1 frequency\n        frequency = phy_params.channels.channel_list[rx_conf->channel].frequency;\n        // Apply the alternative RX 1 window frequency, if it is available\n        if (phy_params.channels.channel_list[rx_conf->channel].rx1_frequency != 0) {\n            frequency = phy_params.channels.channel_list[rx_conf->channel].rx1_frequency;\n        }\n    }\n\n    // Read the physical datarate from the datarates table\n    uint8_t *datarate_table = (uint8_t *) phy_params.datarates.table;\n    uint8_t *payload_table = (uint8_t *) phy_params.payloads.table;\n    uint8_t *payload_with_repeater_table = (uint8_t *) phy_params.payloads_with_repeater.table;\n\n    phy_dr = datarate_table[dr];\n\n    _radio->lock();\n\n    _radio->set_channel(frequency);\n\n    // Radio configuration\n    if (dr == DR_7 && phy_params.fsk_supported) {\n        modem = MODEM_FSK;\n        _radio->set_rx_config(modem, 50000, phy_dr * 1000, 0, 83333, 5,\n                              rx_conf->window_timeout, false, 0, true, 0, 0,\n                              false, rx_conf->is_rx_continuous);\n    } else {\n        modem = MODEM_LORA;\n        _radio->set_rx_config(modem, rx_conf->bandwidth, phy_dr, 1, 0, 8,\n                              rx_conf->window_timeout, false, 0, false, 0, 0,\n                              true, rx_conf->is_rx_continuous);\n    }\n\n    if (rx_conf->is_repeater_supported) {\n        max_payload = payload_with_repeater_table[dr];\n    } else {\n        max_payload = payload_table[dr];\n    }\n\n    _radio->set_max_payload_length(modem, max_payload + LORA_MAC_FRMPAYLOAD_OVERHEAD);\n\n    _radio->unlock();\n\n    return true;\n}\n\nbool LoRaPHY::tx_config(tx_config_params_t* tx_conf, int8_t* tx_power,\n                        lorawan_time_t* tx_toa)\n{\n    radio_modems_t modem;\n    int8_t phy_dr = ((uint8_t *)phy_params.datarates.table)[tx_conf->datarate];\n    channel_params_t *list = phy_params.channels.channel_list;\n    uint8_t band_idx = list[tx_conf->channel].band;\n    band_t *bands = (band_t *)phy_params.bands.table;\n\n    // limit TX power if set to too much\n    tx_conf->tx_power = MAX(tx_conf->tx_power, bands[band_idx].max_tx_pwr);\n\n    uint8_t bandwidth = get_bandwidth(tx_conf->datarate);\n    int8_t phy_tx_power = 0;\n\n    // Calculate physical TX power\n    phy_tx_power = compute_tx_power(tx_conf->tx_power, tx_conf->max_eirp,\n                                    tx_conf->antenna_gain);\n\n    _radio->lock();\n\n    // Setup the radio frequency\n    _radio->set_channel(list[tx_conf->channel].frequency);\n\n    if( tx_conf->datarate == phy_params.max_tx_datarate ) {\n        // High Speed FSK channel\n        modem = MODEM_FSK;\n        _radio->set_tx_config(modem, phy_tx_power, 25000, bandwidth,\n                              phy_dr * 1000, 0, 5, false, true, 0, 0, false,\n                              3000);\n    } else {\n        modem = MODEM_LORA;\n        _radio->set_tx_config(modem, phy_tx_power, 0, bandwidth, phy_dr, 1, 8,\n                              false, true, 0, 0, false, 3000 );\n    }\n\n    // Setup maximum payload lenght of the radio driver\n    _radio->set_max_payload_length( modem, tx_conf->pkt_len);\n    // Get the time-on-air of the next tx frame\n    *tx_toa = _radio->time_on_air(modem, tx_conf->pkt_len);\n\n    _radio->unlock();\n\n    *tx_power = tx_conf->tx_power;\n\n    return true;\n}\n\nuint8_t LoRaPHY::link_ADR_request(adr_req_params_t* link_adr_req,\n                                  int8_t* dr_out, int8_t* tx_power_out,\n                                  uint8_t* nb_rep_out, uint8_t* nb_bytes_processed)\n{\n    uint8_t status = 0x07;\n    link_adr_params_t adr_settings;\n    uint8_t next_index = 0;\n    uint8_t bytes_processed = 0;\n\n    // rather than dynamically allocating memory, we choose to set\n    // a channel mask list size of unity here as we know that all\n    // the PHY layer implementations who have more than 16 channels, i.e.,\n    // have channel mask list size more than unity, override this method.\n    uint16_t temp_channel_mask[1] = {0};\n\n    verify_adr_params_t verify_params;\n\n    while (bytes_processed < link_adr_req->payload_size) {\n        // Get ADR request parameters\n        next_index = parse_link_ADR_req(&(link_adr_req->payload[bytes_processed]),\n                                       &adr_settings);\n\n        if (next_index == 0) {\n            break; // break loop, since no more request has been found\n        }\n\n        // Update bytes processed\n        bytes_processed += next_index;\n\n        // Revert status, as we only check the last ADR request for the channel mask KO\n        status = 0x07;\n\n        // Setup temporary channels mask\n        temp_channel_mask[0] = adr_settings.channel_mask;\n\n        // Verify channels mask\n        if (adr_settings.ch_mask_ctrl == 0 && temp_channel_mask[0] == 0) {\n            status &= 0xFE; // Channel mask KO\n        }\n\n        // channel mask applies to first 16 channels\n        if (adr_settings.ch_mask_ctrl == 0 ||\n            adr_settings.ch_mask_ctrl == 6) {\n\n            for (uint8_t i = 0; i < phy_params.max_channel_cnt; i++) {\n\n                // turn on all channels if channel mask control is 6\n                if (adr_settings.ch_mask_ctrl == 6) {\n                    if (phy_params.channels.channel_list[i].frequency != 0) {\n                        mask_bit_set(temp_channel_mask, i);\n                    }\n\n                    continue;\n                }\n\n                // if channel mask control is 0, we test the bits and\n                // frequencies and change the status if we find a discrepancy\n                if ((mask_bit_test(temp_channel_mask, i)) &&\n                    (phy_params.channels.channel_list[i].frequency == 0)) {\n                    // Trying to enable an undefined channel\n                    status &= 0xFE; // Channel mask KO\n                }\n            }\n        } else {\n            // Channel mask control applies to RFUs\n            status &= 0xFE; // Channel mask KO\n        }\n    }\n\n    if (is_datarate_supported(adr_settings.datarate)) {\n        verify_params.status = status;\n\n        verify_params.adr_enabled = link_adr_req->adr_enabled;\n        verify_params.current_datarate = link_adr_req->current_datarate;\n        verify_params.current_tx_power = link_adr_req->current_tx_power;\n        verify_params.current_nb_rep = link_adr_req->current_nb_rep;\n\n        verify_params.datarate = adr_settings.datarate;\n        verify_params.tx_power = adr_settings.tx_power;\n        verify_params.nb_rep = adr_settings.nb_rep;\n\n\n        verify_params.channel_mask = temp_channel_mask;\n\n        // Verify the parameters and update, if necessary\n        status = verify_link_ADR_req(&verify_params, &adr_settings.datarate,\n                                     &adr_settings.tx_power, &adr_settings.nb_rep);\n    } else {\n        status &= 0xFD; // Datarate KO\n    }\n\n    // Update channelsMask if everything is correct\n    if (status == 0x07) {\n        // Set the channels mask to a default value\n        memset(phy_params.channels.mask, 0,\n               sizeof(uint16_t)*phy_params.channels.mask_size);\n\n        // Update the channels mask\n        copy_channel_mask(phy_params.channels.mask, temp_channel_mask,\n                          phy_params.channels.mask_size);\n    }\n\n    // Update status variables\n    *dr_out = adr_settings.datarate;\n    *tx_power_out = adr_settings.tx_power;\n    *nb_rep_out = adr_settings.nb_rep;\n    *nb_bytes_processed = bytes_processed;\n\n    return status;\n}\n\nuint8_t LoRaPHY::accept_rx_param_setup_req(rx_param_setup_req_t* params)\n{\n    uint8_t status = 0x07;\n\n    // Verify radio frequency\n    if (_radio->check_rf_frequency(params->frequency) == false) {\n        status &= 0xFE; // Channel frequency KO\n    }\n\n    // Verify datarate\n    if (val_in_range(params->datarate, phy_params.min_rx_datarate,\n                     phy_params.max_rx_datarate) == 0) {\n        status &= 0xFD; // Datarate KO\n    }\n\n    // Verify datarate offset\n    if (val_in_range(params->dr_offset, phy_params.min_rx1_dr_offset,\n                     phy_params.max_rx1_dr_offset) == 0) {\n        status &= 0xFB; // Rx1DrOffset range KO\n    }\n\n    return status;\n}\n\nbool LoRaPHY::accept_tx_param_setup_req(uint8_t ul_dwell_time, uint8_t dl_dwell_time)\n{\n    if (phy_params.accept_tx_param_setup_req) {\n        phy_params.ul_dwell_time_setting = ul_dwell_time;\n        phy_params.dl_dwell_time_setting = dl_dwell_time;\n    }\n\n    return phy_params.accept_tx_param_setup_req;\n}\n\nint LoRaPHY::lookup_band_for_frequency(uint32_t freq) const\n{\n    // check all sub bands (if there are sub-bands) to check if the given\n    // frequency falls into any of the frequency ranges\n\n    for (int band=0; band<phy_params.bands.size; band++) {\n        if (verify_frequency_for_band(freq, band)) {\n            return band;\n        }\n    }\n\n    return -1;\n}\n\nbool LoRaPHY::verify_frequency_for_band(uint32_t freq, uint8_t band) const\n{\n    band_t *bands_table = (band_t *)phy_params.bands.table;\n\n    if (freq <= bands_table[band].higher_band_freq\n            && freq >= bands_table[band].lower_band_freq) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nuint8_t LoRaPHY::dl_channel_request(uint8_t channel_id, uint32_t rx1_frequency)\n{\n    if (!phy_params.dl_channel_req_supported) {\n        return 0;\n    }\n\n    uint8_t status = 0x03;\n\n    // Verify if the frequency is supported\n    uint8_t band = lookup_band_for_frequency(rx1_frequency);\n    if (verify_frequency_for_band(rx1_frequency, band) == false) {\n        status &= 0xFE;\n    }\n\n    // Verify if an uplink frequency exists\n    if (phy_params.channels.channel_list[channel_id].frequency == 0) {\n        status &= 0xFD;\n    }\n\n    // Apply Rx1 frequency, if the status is OK\n    if (status == 0x03) {\n        phy_params.channels.channel_list[channel_id].rx1_frequency = rx1_frequency;\n    }\n\n    return status;\n}\n\n/**\n * Alternate datarate algorithm for join requests.\n *  - We check from the PHY and take note of total\n *    number of data rates available upto the default data rate for\n *    default channels.\n *\n *  - Application sets a total number of re-trials for a Join Request, i.e.,\n *    MBED_CONF_LORA_NB_TRIALS. So MAC layer will send us a counter\n *    nb_trials < MBED_CONF_LORA_NB_TRIALS which is the current number of trial.\n *\n *  - We roll over total available datarates and pick one according to the\n *    number of trial sequentially.\n *\n *  - We always start from the Default Data rate and and set the next lower\n *    data rate for every iteration.\n *\n *  - MAC layer will stop when maximum number of re-trials, i.e.,\n *    MBED_CONF_LORA_NB_TRIALS is achieved.\n *\n * So essentially MBED_CONF_LORA_NB_TRIALS should be a multiple of range of\n * data rates available. For example, in EU868 band, default max. data rate is\n * DR_5 and min. data rate is DR_0, so total data rates available are 6.\n *\n * Hence MBED_CONF_LORA_NB_TRIALS should be a multiple of 6. Setting,\n * MBED_CONF_LORA_NB_TRIALS = 6 would mean that every data rate will be tried\n * exactly once starting from the largest and finishing at the smallest.\n *\n * PHY layers which do not have datarates scheme similar to EU band will ofcourse\n * override this method.\n */\nint8_t LoRaPHY::get_alternate_DR(uint8_t nb_trials)\n{\n    int8_t datarate = 0;\n    uint8_t total_nb_datrates = (phy_params.default_max_datarate - phy_params.min_tx_datarate) + 1;\n\n    uint8_t res = nb_trials % total_nb_datrates;\n\n    if (res == 0) {\n        datarate = phy_params.min_tx_datarate;\n    } else if (res == 1) {\n        datarate = phy_params.default_max_datarate;\n    } else {\n        datarate = (phy_params.default_max_datarate - res) + 1;\n    }\n\n    return datarate;\n}\n\nvoid LoRaPHY::calculate_backoff(bool joined, bool last_tx_was_join_req, bool dc_enabled, uint8_t channel,\n                                lorawan_time_t elapsed_time, lorawan_time_t tx_toa)\n{\n    band_t *band_table = (band_t *) phy_params.bands.table;\n    channel_params_t *channel_list = phy_params.channels.channel_list;\n\n    uint8_t band_idx = channel_list[channel].band;\n    uint16_t duty_cycle = band_table[band_idx].duty_cycle;\n    uint16_t join_duty_cycle = 0;\n\n    // Reset time-off to initial value.\n    band_table[band_idx].off_time = 0;\n\n    if (joined == false) {\n        // Get the join duty cycle\n        if (elapsed_time < 3600000) {\n            join_duty_cycle = BACKOFF_DC_1_HOUR;\n        } else if (elapsed_time < (3600000 + 36000000)) {\n            join_duty_cycle = BACKOFF_DC_10_HOURS;\n        } else {\n            join_duty_cycle = BACKOFF_DC_24_HOURS;\n        }\n\n        // Apply the most restricting duty cycle\n        duty_cycle = MAX(duty_cycle, join_duty_cycle);\n    }\n\n    // No back-off if the last frame was not a join request and when the\n    // duty cycle is not enabled\n    if (dc_enabled == false &&\n        last_tx_was_join_req == false) {\n        band_table[band_idx].off_time = 0;\n    } else {\n        // Apply band time-off.\n        band_table[band_idx].off_time = tx_toa * duty_cycle - tx_toa;\n    }\n}\n\nlorawan_status_t LoRaPHY::set_next_channel(channel_selection_params_t* params,\n                                           uint8_t* channel, lorawan_time_t* time,\n                                           lorawan_time_t* aggregate_timeoff)\n{\n    uint8_t channel_count = 0;\n    uint8_t delay_tx = 0;\n\n    // Note here that the PHY layer implementations which have more than\n    // 16 channels at their disposal, override this function. That's why\n    // it is safe to assume that we are dealing with a block of 16 channels\n    // i.e., EU like implementations. So rather than dynamically allocating\n    // memory we chose to use a magic number of 16\n    uint8_t enabled_channels[16];\n\n    memset(enabled_channels, 0xFF, sizeof(uint8_t)*16);\n\n    lorawan_time_t next_tx_delay = 0;\n    band_t *band_table = (band_t *) phy_params.bands.table;\n\n    if (num_active_channels(phy_params.channels.mask, 0,\n                            phy_params.channels.mask_size) == 0) {\n\n        // Reactivate default channels\n        copy_channel_mask(phy_params.channels.mask,\n                          phy_params.channels.default_mask,\n                          phy_params.channels.mask_size);\n    }\n\n    if (params->aggregate_timeoff\n            <= _lora_time.get_elapsed_time(params->last_aggregate_tx_time)) {\n        // Reset Aggregated time off\n        *aggregate_timeoff = 0;\n\n        // Update bands Time OFF\n        next_tx_delay = update_band_timeoff(params->joined,\n                                          params->dc_enabled,\n                                          band_table, phy_params.bands.size);\n\n        // Search how many channels are enabled\n        channel_count = enabled_channel_count(params->joined, params->current_datarate,\n                                                  phy_params.channels.mask,\n                                                  enabled_channels, &delay_tx);\n    } else {\n        delay_tx++;\n        next_tx_delay = params->aggregate_timeoff\n                - _lora_time.get_elapsed_time(params->last_aggregate_tx_time);\n    }\n\n    if (channel_count > 0) {\n        // We found a valid channel\n        *channel = enabled_channels[get_random(0, channel_count - 1)];\n        *time = 0;\n        return LORAWAN_STATUS_OK;\n    }\n\n    if (delay_tx > 0) {\n        // Delay transmission due to AggregatedTimeOff or to a band time off\n        *time = next_tx_delay;\n        return LORAWAN_STATUS_DUTYCYCLE_RESTRICTED;\n    }\n\n    // Datarate not supported by any channel, restore defaults\n    copy_channel_mask(phy_params.channels.mask,\n                      phy_params.channels.default_mask,\n                      phy_params.channels.mask_size);\n    *time = 0;\n    return LORAWAN_STATUS_NO_CHANNEL_FOUND;\n}\n\nlorawan_status_t LoRaPHY::add_channel(const channel_params_t* new_channel, uint8_t id)\n{\n    bool dr_invalid = false;\n    bool freq_invalid = false;\n\n    if (!phy_params.custom_channelplans_supported\n            || id >= phy_params.max_channel_cnt) {\n\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    // Validate the datarate range\n    if (val_in_range(new_channel->dr_range.fields.min,\n                     phy_params.min_tx_datarate,\n                     phy_params.max_tx_datarate) == 0) {\n        dr_invalid = true;\n    }\n\n    if (val_in_range(new_channel->dr_range.fields.max, phy_params.min_tx_datarate,\n                     phy_params.max_tx_datarate) == 0) {\n        dr_invalid = true;\n    }\n\n    if (new_channel->dr_range.fields.min > new_channel->dr_range.fields.max) {\n        dr_invalid = true;\n    }\n\n    // Default channels don't accept all values\n    if (id < phy_params.default_channel_cnt) {\n        // Validate the datarate range for min: must be DR_0\n        if (new_channel->dr_range.fields.min > phy_params.min_tx_datarate) {\n            dr_invalid = true;\n        }\n\n        // Validate the datarate range for max: must be DR_5 <= Max <= TX_MAX_DATARATE\n        if (val_in_range(new_channel->dr_range.fields.max,\n                         phy_params.default_max_datarate,\n                         phy_params.max_tx_datarate) == 0) {\n            dr_invalid = true;\n        }\n\n        // We are not allowed to change the frequency\n        if (new_channel->frequency != phy_params.channels.channel_list[id].frequency) {\n            freq_invalid = true;\n        }\n    }\n\n    // Check frequency\n    if (!freq_invalid) {\n        if (new_channel->band >= phy_params.bands.size\n                || verify_frequency_for_band(new_channel->frequency,\n                                             new_channel->band) == false) {\n            freq_invalid = true;\n        }\n    }\n\n    // Check status\n    if (dr_invalid && freq_invalid) {\n        return LORAWAN_STATUS_FREQ_AND_DR_INVALID;\n    }\n\n    if (dr_invalid) {\n        return LORAWAN_STATUS_DATARATE_INVALID;\n    }\n\n    if (freq_invalid) {\n        return LORAWAN_STATUS_FREQUENCY_INVALID;\n    }\n\n    memcpy(&(phy_params.channels.channel_list[id]), new_channel, sizeof(channel_params_t));\n\n    phy_params.channels.channel_list[id].band = new_channel->band;\n\n    mask_bit_set(phy_params.channels.mask, id);\n\n    return LORAWAN_STATUS_OK;\n}\n\nbool LoRaPHY::remove_channel(uint8_t channel_id)\n{\n    // upper layers are checking if the custom channel planning is supported or\n    // not. So we don't need to worry about that\n    if (mask_bit_test(phy_params.channels.default_mask, channel_id)) {\n        return false;\n    }\n\n\n    // Remove the channel from the list of channels\n    const channel_params_t empty_channel = { 0, 0, {0}, 0 };\n    phy_params.channels.channel_list[channel_id] = empty_channel;\n\n    return disable_channel(phy_params.channels.mask, channel_id,\n                           phy_params.max_channel_cnt);\n}\n\nvoid LoRaPHY::set_tx_cont_mode(cw_mode_params_t* params, uint32_t given_frequency)\n{\n    band_t *bands_table = (band_t *) phy_params.bands.table;\n    channel_params_t *channels = phy_params.channels.channel_list;\n\n    if (params->tx_power > bands_table[channels[params->channel].band].max_tx_pwr) {\n        params->tx_power = bands_table[channels[params->channel].band].max_tx_pwr;\n    }\n\n    int8_t phy_tx_power = 0;\n    uint32_t frequency  = 0;\n\n    if (given_frequency == 0) {\n       frequency = channels[params->channel].frequency;\n    } else {\n        frequency = given_frequency;\n    }\n\n    // Calculate physical TX power\n    if (params->max_eirp > 0 && params->antenna_gain > 0) {\n        phy_tx_power = compute_tx_power(params->tx_power, params->max_eirp,\n                                    params->antenna_gain );\n    } else {\n        phy_tx_power = params->tx_power;\n    }\n\n    _radio->lock();\n    _radio->set_tx_continuous_wave(frequency, phy_tx_power, params->timeout);\n    _radio->unlock();\n}\n\nuint8_t LoRaPHY::apply_DR_offset(int8_t dr, int8_t dr_offset)\n{\n    int8_t datarate = dr - dr_offset;\n\n    if (datarate < 0) {\n        datarate = phy_params.min_tx_datarate;\n    }\n\n    return datarate;\n}\n\n\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"LoRaMacChannelPlan.h\"\n\nLoRaMacChannelPlan::LoRaMacChannelPlan() : _lora_phy(NULL)\n{\n}\n\nLoRaMacChannelPlan::~LoRaMacChannelPlan()\n{\n}\n\nvoid LoRaMacChannelPlan::activate_channelplan_subsystem(LoRaPHY *phy)\n{\n    _lora_phy = phy;\n}\n\nlorawan_status_t LoRaMacChannelPlan::set_plan(const lorawan_channelplan_t& plan)\n{\n    lorawan_status_t status;\n\n    uint8_t max_num_channels;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    // check if user is setting more channels than supported\n    if (plan.nb_channels > max_num_channels) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    for (uint8_t i = 0; i < plan.nb_channels; i++) {\n        status = _lora_phy->add_channel(&plan.channels[i].ch_param, plan.channels[i].id);\n\n        if (status != LORAWAN_STATUS_OK) {\n            return status;\n        }\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMacChannelPlan::get_plan(lorawan_channelplan_t& plan,\n                                              const channel_params_t* channel_list)\n{\n    uint8_t max_num_channels;\n    uint16_t *channel_mask;\n    uint8_t count = 0;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    channel_mask = _lora_phy->get_channel_mask(false);\n\n    for (uint8_t i = 0; i < max_num_channels; i++) {\n        // skip the channels which are not enabled\n        if (_lora_phy->mask_bit_test(channel_mask, i) == 0) {\n            continue;\n        }\n\n        // otherwise add them to the channel_plan struct\n        plan.channels[count].id = i;\n        plan.channels[count].ch_param.frequency = channel_list[i].frequency;\n        plan.channels[count].ch_param.dr_range.value = channel_list[i].dr_range.value;\n        plan.channels[count].ch_param.dr_range.fields.min = channel_list[i].dr_range.fields.min;\n        plan.channels[count].ch_param.dr_range.fields.max = channel_list[i].dr_range.fields.max;\n        plan.channels[count].ch_param.band = channel_list[i].band;\n        plan.channels[count].ch_param.rx1_frequency = channel_list[i].rx1_frequency;\n        count++;\n    }\n\n    plan.nb_channels = count;\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMacChannelPlan::remove_plan()\n{\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    uint8_t max_num_channels;\n    uint16_t *channel_mask;\n    uint16_t *default_channel_mask;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    channel_mask = _lora_phy->get_channel_mask(false);\n\n    default_channel_mask = _lora_phy->get_channel_mask(true);\n\n    for (uint8_t i = 0; i < max_num_channels; i++) {\n        // skip any default channels\n        if (_lora_phy->mask_bit_test(default_channel_mask, i) != 0) {\n            continue;\n        }\n\n        // skip any channels which are not currently enabled\n        if (_lora_phy->mask_bit_test(channel_mask, i) == 0) {\n            continue;\n        }\n\n        status = remove_single_channel(i);\n\n        if (status != LORAWAN_STATUS_OK) {\n            return status;\n        }\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMacChannelPlan::remove_single_channel(uint8_t channel_id)\n{\n    uint8_t max_num_channels;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    // According to specification channel IDs start from 0 and last valid\n    // channel ID is N-1 where N=MAX_NUM_CHANNELS.\n    // So any ID which is larger or equal to the Max number of channels is invalid\n    if (channel_id >= max_num_channels) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    if (_lora_phy->remove_channel(channel_id) == false) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _lora_phy->put_radio_to_sleep();\n\n    return LORAWAN_STATUS_OK;\n}\n\n","/**\n * \\file cmac.c\n *\n * \\brief NIST SP800-38B compliant CMAC implementation for AES and 3DES\n *\n *  Copyright (C) 2006-2016, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n/*\n * References:\n *\n * - NIST SP 800-38B Recommendation for Block Cipher Modes of Operation: The\n *      CMAC Mode for Authentication\n *   http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf\n *\n * - RFC 4493 - The AES-CMAC Algorithm\n *   https://tools.ietf.org/html/rfc4493\n *\n * - RFC 4615 - The Advanced Encryption Standard-Cipher-based Message\n *      Authentication Code-Pseudo-Random Function-128 (AES-CMAC-PRF-128)\n *      Algorithm for the Internet Key Exchange Protocol (IKE)\n *   https://tools.ietf.org/html/rfc4615\n *\n *   Additional test vectors: ISO/IEC 9797-1\n *\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CMAC_C)\n\n#include \"mbedtls/cmac.h\"\n#include \"mbedtls/platform_util.h\"\n\n#include <string.h>\n\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc     calloc\n#define mbedtls_free       free\n#if defined(MBEDTLS_SELF_TEST)\n#include <stdio.h>\n#define mbedtls_printf     printf\n#endif /* MBEDTLS_SELF_TEST */\n#endif /* MBEDTLS_PLATFORM_C */\n\n#if !defined(MBEDTLS_CMAC_ALT) || defined(MBEDTLS_SELF_TEST)\n\n/*\n * Multiplication by u in the Galois field of GF(2^n)\n *\n * As explained in NIST SP 800-38B, this can be computed:\n *\n *   If MSB(p) = 0, then p = (p << 1)\n *   If MSB(p) = 1, then p = (p << 1) ^ R_n\n *   with R_64 = 0x1B and  R_128 = 0x87\n *\n * Input and output MUST NOT point to the same buffer\n * Block size must be 8 bytes or 16 bytes - the block sizes for DES and AES.\n */\nstatic int cmac_multiply_by_u( unsigned char *output,\n                               const unsigned char *input,\n                               size_t blocksize )\n{\n    const unsigned char R_128 = 0x87;\n    const unsigned char R_64 = 0x1B;\n    unsigned char R_n, mask;\n    unsigned char overflow = 0x00;\n    int i;\n\n    if( blocksize == MBEDTLS_AES_BLOCK_SIZE )\n    {\n        R_n = R_128;\n    }\n    else if( blocksize == MBEDTLS_DES3_BLOCK_SIZE )\n    {\n        R_n = R_64;\n    }\n    else\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    for( i = (int)blocksize - 1; i >= 0; i-- )\n    {\n        output[i] = input[i] << 1 | overflow;\n        overflow = input[i] >> 7;\n    }\n\n    /* mask = ( input[0] >> 7 ) ? 0xff : 0x00\n     * using bit operations to avoid branches */\n\n    /* MSVC has a warning about unary minus on unsigned, but this is\n     * well-defined and precisely what we want to do here */\n#if defined(_MSC_VER)\n#pragma warning( push )\n#pragma warning( disable : 4146 )\n#endif\n    mask = - ( input[0] >> 7 );\n#if defined(_MSC_VER)\n#pragma warning( pop )\n#endif\n\n    output[ blocksize - 1 ] ^= R_n & mask;\n\n    return( 0 );\n}\n\n/*\n * Generate subkeys\n *\n * - as specified by RFC 4493, section 2.3 Subkey Generation Algorithm\n */\nstatic int cmac_generate_subkeys( mbedtls_cipher_context_t *ctx,\n                                  unsigned char* K1, unsigned char* K2 )\n{\n    int ret;\n    unsigned char L[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    size_t olen, block_size;\n\n    mbedtls_platform_zeroize( L, sizeof( L ) );\n\n    block_size = ctx->cipher_info->block_size;\n\n    /* Calculate Ek(0) */\n    if( ( ret = mbedtls_cipher_update( ctx, L, block_size, L, &olen ) ) != 0 )\n        goto exit;\n\n    /*\n     * Generate K1 and K2\n     */\n    if( ( ret = cmac_multiply_by_u( K1, L , block_size ) ) != 0 )\n        goto exit;\n\n    if( ( ret = cmac_multiply_by_u( K2, K1 , block_size ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_platform_zeroize( L, sizeof( L ) );\n\n    return( ret );\n}\n#endif /* !defined(MBEDTLS_CMAC_ALT) || defined(MBEDTLS_SELF_TEST) */\n\n#if !defined(MBEDTLS_CMAC_ALT)\nstatic void cmac_xor_block( unsigned char *output, const unsigned char *input1,\n                            const unsigned char *input2,\n                            const size_t block_size )\n{\n    size_t idx;\n\n    for( idx = 0; idx < block_size; idx++ )\n        output[ idx ] = input1[ idx ] ^ input2[ idx ];\n}\n\n/*\n * Create padded last block from (partial) last block.\n *\n * We can't use the padding option from the cipher layer, as it only works for\n * CBC and we use ECB mode, and anyway we need to XOR K1 or K2 in addition.\n */\nstatic void cmac_pad( unsigned char padded_block[MBEDTLS_CIPHER_BLKSIZE_MAX],\n                      size_t padded_block_len,\n                      const unsigned char *last_block,\n                      size_t last_block_len )\n{\n    size_t j;\n\n    for( j = 0; j < padded_block_len; j++ )\n    {\n        if( j < last_block_len )\n            padded_block[j] = last_block[j];\n        else if( j == last_block_len )\n            padded_block[j] = 0x80;\n        else\n            padded_block[j] = 0x00;\n    }\n}\n\nint mbedtls_cipher_cmac_starts( mbedtls_cipher_context_t *ctx,\n                                const unsigned char *key, size_t keybits )\n{\n    mbedtls_cipher_type_t type;\n    mbedtls_cmac_context_t *cmac_ctx;\n    int retval;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || key == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( ( retval = mbedtls_cipher_setkey( ctx, key, (int)keybits,\n                                          MBEDTLS_ENCRYPT ) ) != 0 )\n        return( retval );\n\n    type = ctx->cipher_info->type;\n\n    switch( type )\n    {\n        case MBEDTLS_CIPHER_AES_128_ECB:\n        case MBEDTLS_CIPHER_AES_192_ECB:\n        case MBEDTLS_CIPHER_AES_256_ECB:\n        case MBEDTLS_CIPHER_DES_EDE3_ECB:\n            break;\n        default:\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    /* Allocated and initialise in the cipher context memory for the CMAC\n     * context */\n    cmac_ctx = mbedtls_calloc( 1, sizeof( mbedtls_cmac_context_t ) );\n    if( cmac_ctx == NULL )\n        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );\n\n    ctx->cmac_ctx = cmac_ctx;\n\n    mbedtls_platform_zeroize( cmac_ctx->state, sizeof( cmac_ctx->state ) );\n\n    return 0;\n}\n\nint mbedtls_cipher_cmac_update( mbedtls_cipher_context_t *ctx,\n                                const unsigned char *input, size_t ilen )\n{\n    mbedtls_cmac_context_t* cmac_ctx;\n    unsigned char *state;\n    int ret = 0;\n    size_t n, j, olen, block_size;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||\n        ctx->cmac_ctx == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cmac_ctx = ctx->cmac_ctx;\n    block_size = ctx->cipher_info->block_size;\n    state = ctx->cmac_ctx->state;\n\n    /* Is there data still to process from the last call, that's greater in\n     * size than a block? */\n    if( cmac_ctx->unprocessed_len > 0 &&\n        ilen > block_size - cmac_ctx->unprocessed_len )\n    {\n        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],\n                input,\n                block_size - cmac_ctx->unprocessed_len );\n\n        cmac_xor_block( state, cmac_ctx->unprocessed_block, state, block_size );\n\n        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,\n                                           &olen ) ) != 0 )\n        {\n           goto exit;\n        }\n\n        input += block_size - cmac_ctx->unprocessed_len;\n        ilen -= block_size - cmac_ctx->unprocessed_len;\n        cmac_ctx->unprocessed_len = 0;\n    }\n\n    /* n is the number of blocks including any final partial block */\n    n = ( ilen + block_size - 1 ) / block_size;\n\n    /* Iterate across the input data in block sized chunks, excluding any\n     * final partial or complete block */\n    for( j = 1; j < n; j++ )\n    {\n        cmac_xor_block( state, input, state, block_size );\n\n        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,\n                                           &olen ) ) != 0 )\n           goto exit;\n\n        ilen -= block_size;\n        input += block_size;\n    }\n\n    /* If there is data left over that wasn't aligned to a block */\n    if( ilen > 0 )\n    {\n        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],\n                input,\n                ilen );\n        cmac_ctx->unprocessed_len += ilen;\n    }\n\nexit:\n    return( ret );\n}\n\nint mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx,\n                                unsigned char *output )\n{\n    mbedtls_cmac_context_t* cmac_ctx;\n    unsigned char *state, *last_block;\n    unsigned char K1[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char M_last[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    int ret;\n    size_t olen, block_size;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL ||\n        output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cmac_ctx = ctx->cmac_ctx;\n    block_size = ctx->cipher_info->block_size;\n    state = cmac_ctx->state;\n\n    mbedtls_platform_zeroize( K1, sizeof( K1 ) );\n    mbedtls_platform_zeroize( K2, sizeof( K2 ) );\n    cmac_generate_subkeys( ctx, K1, K2 );\n\n    last_block = cmac_ctx->unprocessed_block;\n\n    /* Calculate last block */\n    if( cmac_ctx->unprocessed_len < block_size )\n    {\n        cmac_pad( M_last, block_size, last_block, cmac_ctx->unprocessed_len );\n        cmac_xor_block( M_last, M_last, K2, block_size );\n    }\n    else\n    {\n        /* Last block is complete block */\n        cmac_xor_block( M_last, last_block, K1, block_size );\n    }\n\n\n    cmac_xor_block( state, M_last, state, block_size );\n    if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,\n                                       &olen ) ) != 0 )\n    {\n        goto exit;\n    }\n\n    memcpy( output, state, block_size );\n\nexit:\n    /* Wipe the generated keys on the stack, and any other transients to avoid\n     * side channel leakage */\n    mbedtls_platform_zeroize( K1, sizeof( K1 ) );\n    mbedtls_platform_zeroize( K2, sizeof( K2 ) );\n\n    cmac_ctx->unprocessed_len = 0;\n    mbedtls_platform_zeroize( cmac_ctx->unprocessed_block,\n                              sizeof( cmac_ctx->unprocessed_block ) );\n\n    mbedtls_platform_zeroize( state, MBEDTLS_CIPHER_BLKSIZE_MAX );\n    return( ret );\n}\n\nint mbedtls_cipher_cmac_reset( mbedtls_cipher_context_t *ctx )\n{\n    mbedtls_cmac_context_t* cmac_ctx;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cmac_ctx = ctx->cmac_ctx;\n\n    /* Reset the internal state */\n    cmac_ctx->unprocessed_len = 0;\n    mbedtls_platform_zeroize( cmac_ctx->unprocessed_block,\n                              sizeof( cmac_ctx->unprocessed_block ) );\n    mbedtls_platform_zeroize( cmac_ctx->state,\n                              sizeof( cmac_ctx->state ) );\n\n    return( 0 );\n}\n\nint mbedtls_cipher_cmac( const mbedtls_cipher_info_t *cipher_info,\n                         const unsigned char *key, size_t keylen,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output )\n{\n    mbedtls_cipher_context_t ctx;\n    int ret;\n\n    if( cipher_info == NULL || key == NULL || input == NULL || output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    mbedtls_cipher_init( &ctx );\n\n    if( ( ret = mbedtls_cipher_setup( &ctx, cipher_info ) ) != 0 )\n        goto exit;\n\n    ret = mbedtls_cipher_cmac_starts( &ctx, key, keylen );\n    if( ret != 0 )\n        goto exit;\n\n    ret = mbedtls_cipher_cmac_update( &ctx, input, ilen );\n    if( ret != 0 )\n        goto exit;\n\n    ret = mbedtls_cipher_cmac_finish( &ctx, output );\n\nexit:\n    mbedtls_cipher_free( &ctx );\n\n    return( ret );\n}\n\n#if defined(MBEDTLS_AES_C)\n/*\n * Implementation of AES-CMAC-PRF-128 defined in RFC 4615\n */\nint mbedtls_aes_cmac_prf_128( const unsigned char *key, size_t key_length,\n                              const unsigned char *input, size_t in_len,\n                              unsigned char *output )\n{\n    int ret;\n    const mbedtls_cipher_info_t *cipher_info;\n    unsigned char zero_key[MBEDTLS_AES_BLOCK_SIZE];\n    unsigned char int_key[MBEDTLS_AES_BLOCK_SIZE];\n\n    if( key == NULL || input == NULL || output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cipher_info = mbedtls_cipher_info_from_type( MBEDTLS_CIPHER_AES_128_ECB );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;\n        goto exit;\n    }\n\n    if( key_length == MBEDTLS_AES_BLOCK_SIZE )\n    {\n        /* Use key as is */\n        memcpy( int_key, key, MBEDTLS_AES_BLOCK_SIZE );\n    }\n    else\n    {\n        memset( zero_key, 0, MBEDTLS_AES_BLOCK_SIZE );\n\n        ret = mbedtls_cipher_cmac( cipher_info, zero_key, 128, key,\n                                   key_length, int_key );\n        if( ret != 0 )\n            goto exit;\n    }\n\n    ret = mbedtls_cipher_cmac( cipher_info, int_key, 128, input, in_len,\n                               output );\n\nexit:\n    mbedtls_platform_zeroize( int_key, sizeof( int_key ) );\n\n    return( ret );\n}\n#endif /* MBEDTLS_AES_C */\n\n#endif /* !MBEDTLS_CMAC_ALT */\n\n#if defined(MBEDTLS_SELF_TEST)\n/*\n * CMAC test data for SP800-38B\n * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/AES_CMAC.pdf\n * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/TDES_CMAC.pdf\n *\n * AES-CMAC-PRF-128 test data from RFC 4615\n * https://tools.ietf.org/html/rfc4615#page-4\n */\n\n#define NB_CMAC_TESTS_PER_KEY 4\n#define NB_PRF_TESTS 3\n\n#if defined(MBEDTLS_AES_C) || defined(MBEDTLS_DES_C)\n/* All CMAC test inputs are truncated from the same 64 byte buffer. */\nstatic const unsigned char test_message[] = {\n    /* PT */\n    0x6b, 0xc1, 0xbe, 0xe2,     0x2e, 0x40, 0x9f, 0x96,\n    0xe9, 0x3d, 0x7e, 0x11,     0x73, 0x93, 0x17, 0x2a,\n    0xae, 0x2d, 0x8a, 0x57,     0x1e, 0x03, 0xac, 0x9c,\n    0x9e, 0xb7, 0x6f, 0xac,     0x45, 0xaf, 0x8e, 0x51,\n    0x30, 0xc8, 0x1c, 0x46,     0xa3, 0x5c, 0xe4, 0x11,\n    0xe5, 0xfb, 0xc1, 0x19,     0x1a, 0x0a, 0x52, 0xef,\n    0xf6, 0x9f, 0x24, 0x45,     0xdf, 0x4f, 0x9b, 0x17,\n    0xad, 0x2b, 0x41, 0x7b,     0xe6, 0x6c, 0x37, 0x10\n};\n#endif /* MBEDTLS_AES_C || MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n/* Truncation point of message for AES CMAC tests  */\nstatic const  unsigned int  aes_message_lengths[NB_CMAC_TESTS_PER_KEY] = {\n    /* Mlen */\n    0,\n    16,\n    20,\n    64\n};\n\n/* CMAC-AES128 Test Data */\nstatic const unsigned char aes_128_key[16] = {\n    0x2b, 0x7e, 0x15, 0x16,     0x28, 0xae, 0xd2, 0xa6,\n    0xab, 0xf7, 0x15, 0x88,     0x09, 0xcf, 0x4f, 0x3c\n};\nstatic const unsigned char aes_128_subkeys[2][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* K1 */\n        0xfb, 0xee, 0xd6, 0x18,     0x35, 0x71, 0x33, 0x66,\n        0x7c, 0x85, 0xe0, 0x8f,     0x72, 0x36, 0xa8, 0xde\n    },\n    {\n        /* K2 */\n        0xf7, 0xdd, 0xac, 0x30,     0x6a, 0xe2, 0x66, 0xcc,\n        0xf9, 0x0b, 0xc1, 0x1e,     0xe4, 0x6d, 0x51, 0x3b\n    }\n};\nstatic const unsigned char aes_128_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* Example #1 */\n        0xbb, 0x1d, 0x69, 0x29,     0xe9, 0x59, 0x37, 0x28,\n        0x7f, 0xa3, 0x7d, 0x12,     0x9b, 0x75, 0x67, 0x46\n    },\n    {\n        /* Example #2 */\n        0x07, 0x0a, 0x16, 0xb4,     0x6b, 0x4d, 0x41, 0x44,\n        0xf7, 0x9b, 0xdd, 0x9d,     0xd0, 0x4a, 0x28, 0x7c\n    },\n    {\n        /* Example #3 */\n        0x7d, 0x85, 0x44, 0x9e,     0xa6, 0xea, 0x19, 0xc8,\n        0x23, 0xa7, 0xbf, 0x78,     0x83, 0x7d, 0xfa, 0xde\n    },\n    {\n        /* Example #4 */\n        0x51, 0xf0, 0xbe, 0xbf,     0x7e, 0x3b, 0x9d, 0x92,\n        0xfc, 0x49, 0x74, 0x17,     0x79, 0x36, 0x3c, 0xfe\n    }\n};\n\n/* CMAC-AES192 Test Data */\nstatic const unsigned char aes_192_key[24] = {\n    0x8e, 0x73, 0xb0, 0xf7,     0xda, 0x0e, 0x64, 0x52,\n    0xc8, 0x10, 0xf3, 0x2b,     0x80, 0x90, 0x79, 0xe5,\n    0x62, 0xf8, 0xea, 0xd2,     0x52, 0x2c, 0x6b, 0x7b\n};\nstatic const unsigned char aes_192_subkeys[2][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* K1 */\n        0x44, 0x8a, 0x5b, 0x1c,     0x93, 0x51, 0x4b, 0x27,\n        0x3e, 0xe6, 0x43, 0x9d,     0xd4, 0xda, 0xa2, 0x96\n    },\n    {\n        /* K2 */\n        0x89, 0x14, 0xb6, 0x39,     0x26, 0xa2, 0x96, 0x4e,\n        0x7d, 0xcc, 0x87, 0x3b,     0xa9, 0xb5, 0x45, 0x2c\n    }\n};\nstatic const unsigned char aes_192_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* Example #1 */\n        0xd1, 0x7d, 0xdf, 0x46,     0xad, 0xaa, 0xcd, 0xe5,\n        0x31, 0xca, 0xc4, 0x83,     0xde, 0x7a, 0x93, 0x67\n    },\n    {\n        /* Example #2 */\n        0x9e, 0x99, 0xa7, 0xbf,     0x31, 0xe7, 0x10, 0x90,\n        0x06, 0x62, 0xf6, 0x5e,     0x61, 0x7c, 0x51, 0x84\n    },\n    {\n        /* Example #3 */\n        0x3d, 0x75, 0xc1, 0x94,     0xed, 0x96, 0x07, 0x04,\n        0x44, 0xa9, 0xfa, 0x7e,     0xc7, 0x40, 0xec, 0xf8\n    },\n    {\n        /* Example #4 */\n        0xa1, 0xd5, 0xdf, 0x0e,     0xed, 0x79, 0x0f, 0x79,\n        0x4d, 0x77, 0x58, 0x96,     0x59, 0xf3, 0x9a, 0x11\n    }\n};\n\n/* CMAC-AES256 Test Data */\nstatic const unsigned char aes_256_key[32] = {\n    0x60, 0x3d, 0xeb, 0x10,     0x15, 0xca, 0x71, 0xbe,\n    0x2b, 0x73, 0xae, 0xf0,     0x85, 0x7d, 0x77, 0x81,\n    0x1f, 0x35, 0x2c, 0x07,     0x3b, 0x61, 0x08, 0xd7,\n    0x2d, 0x98, 0x10, 0xa3,     0x09, 0x14, 0xdf, 0xf4\n};\nstatic const unsigned char aes_256_subkeys[2][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* K1 */\n        0xca, 0xd1, 0xed, 0x03,     0x29, 0x9e, 0xed, 0xac,\n        0x2e, 0x9a, 0x99, 0x80,     0x86, 0x21, 0x50, 0x2f\n    },\n    {\n        /* K2 */\n        0x95, 0xa3, 0xda, 0x06,     0x53, 0x3d, 0xdb, 0x58,\n        0x5d, 0x35, 0x33, 0x01,     0x0c, 0x42, 0xa0, 0xd9\n    }\n};\nstatic const unsigned char aes_256_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* Example #1 */\n        0x02, 0x89, 0x62, 0xf6,     0x1b, 0x7b, 0xf8, 0x9e,\n        0xfc, 0x6b, 0x55, 0x1f,     0x46, 0x67, 0xd9, 0x83\n    },\n    {\n        /* Example #2 */\n        0x28, 0xa7, 0x02, 0x3f,     0x45, 0x2e, 0x8f, 0x82,\n        0xbd, 0x4b, 0xf2, 0x8d,     0x8c, 0x37, 0xc3, 0x5c\n    },\n    {\n        /* Example #3 */\n        0x15, 0x67, 0x27, 0xdc,     0x08, 0x78, 0x94, 0x4a,\n        0x02, 0x3c, 0x1f, 0xe0,     0x3b, 0xad, 0x6d, 0x93\n    },\n    {\n        /* Example #4 */\n        0xe1, 0x99, 0x21, 0x90,     0x54, 0x9f, 0x6e, 0xd5,\n        0x69, 0x6a, 0x2c, 0x05,     0x6c, 0x31, 0x54, 0x10\n    }\n};\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_DES_C)\n/* Truncation point of message for 3DES CMAC tests  */\nstatic const unsigned int des3_message_lengths[NB_CMAC_TESTS_PER_KEY] = {\n    0,\n    16,\n    20,\n    32\n};\n\n/* CMAC-TDES (Generation) - 2 Key Test Data */\nstatic const unsigned char des3_2key_key[24] = {\n    /* Key1 */\n    0x01, 0x23, 0x45, 0x67,     0x89, 0xab, 0xcd, 0xef,\n    /* Key2 */\n    0x23, 0x45, 0x67, 0x89,     0xab, 0xcd, 0xEF, 0x01,\n    /* Key3 */\n    0x01, 0x23, 0x45, 0x67,     0x89, 0xab, 0xcd, 0xef\n};\nstatic const unsigned char des3_2key_subkeys[2][8] = {\n    {\n        /* K1 */\n        0x0d, 0xd2, 0xcb, 0x7a,     0x3d, 0x88, 0x88, 0xd9\n    },\n    {\n        /* K2 */\n        0x1b, 0xa5, 0x96, 0xf4,     0x7b, 0x11, 0x11, 0xb2\n    }\n};\nstatic const unsigned char des3_2key_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_DES3_BLOCK_SIZE] = {\n    {\n        /* Sample #1 */\n        0x79, 0xce, 0x52, 0xa7,     0xf7, 0x86, 0xa9, 0x60\n    },\n    {\n        /* Sample #2 */\n        0xcc, 0x18, 0xa0, 0xb7,     0x9a, 0xf2, 0x41, 0x3b\n    },\n    {\n        /* Sample #3 */\n        0xc0, 0x6d, 0x37, 0x7e,     0xcd, 0x10, 0x19, 0x69\n    },\n    {\n        /* Sample #4 */\n        0x9c, 0xd3, 0x35, 0x80,     0xf9, 0xb6, 0x4d, 0xfb\n    }\n};\n\n/* CMAC-TDES (Generation) - 3 Key Test Data */\nstatic const unsigned char des3_3key_key[24] = {\n    /* Key1 */\n    0x01, 0x23, 0x45, 0x67,     0x89, 0xaa, 0xcd, 0xef,\n    /* Key2 */\n    0x23, 0x45, 0x67, 0x89,     0xab, 0xcd, 0xef, 0x01,\n    /* Key3 */\n    0x45, 0x67, 0x89, 0xab,     0xcd, 0xef, 0x01, 0x23\n};\nstatic const unsigned char des3_3key_subkeys[2][8] = {\n    {\n        /* K1 */\n        0x9d, 0x74, 0xe7, 0x39,     0x33, 0x17, 0x96, 0xc0\n    },\n    {\n        /* K2 */\n        0x3a, 0xe9, 0xce, 0x72,     0x66, 0x2f, 0x2d, 0x9b\n    }\n};\nstatic const unsigned char des3_3key_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_DES3_BLOCK_SIZE] = {\n    {\n        /* Sample #1 */\n        0x7d, 0xb0, 0xd3, 0x7d,     0xf9, 0x36, 0xc5, 0x50\n    },\n    {\n        /* Sample #2 */\n        0x30, 0x23, 0x9c, 0xf1,     0xf5, 0x2e, 0x66, 0x09\n    },\n    {\n        /* Sample #3 */\n        0x6c, 0x9f, 0x3e, 0xe4,     0x92, 0x3f, 0x6b, 0xe2\n    },\n    {\n        /* Sample #4 */\n        0x99, 0x42, 0x9b, 0xd0,     0xbF, 0x79, 0x04, 0xe5\n    }\n};\n\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n/* AES AES-CMAC-PRF-128 Test Data */\nstatic const unsigned char PRFK[] = {\n    /* Key */\n    0x00, 0x01, 0x02, 0x03,     0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b,     0x0c, 0x0d, 0x0e, 0x0f,\n    0xed, 0xcb\n};\n\n/* Sizes in bytes */\nstatic const size_t PRFKlen[NB_PRF_TESTS] = {\n    18,\n    16,\n    10\n};\n\n/* Message */\nstatic const unsigned char PRFM[] = {\n    0x00, 0x01, 0x02, 0x03,     0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b,     0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13\n};\n\nstatic const unsigned char PRFT[NB_PRF_TESTS][16] = {\n    {\n        0x84, 0xa3, 0x48, 0xa4,     0xa4, 0x5d, 0x23, 0x5b,\n        0xab, 0xff, 0xfc, 0x0d,     0x2b, 0x4d, 0xa0, 0x9a\n    },\n    {\n        0x98, 0x0a, 0xe8, 0x7b,     0x5f, 0x4c, 0x9c, 0x52,\n        0x14, 0xf5, 0xb6, 0xa8,     0x45, 0x5e, 0x4c, 0x2d\n    },\n    {\n        0x29, 0x0d, 0x9e, 0x11,     0x2e, 0xdb, 0x09, 0xee,\n        0x14, 0x1f, 0xcf, 0x64,     0xc0, 0xb7, 0x2f, 0x3d\n    }\n};\n#endif /* MBEDTLS_AES_C */\n\nstatic int cmac_test_subkeys( int verbose,\n                              const char* testname,\n                              const unsigned char* key,\n                              int keybits,\n                              const unsigned char* subkeys,\n                              mbedtls_cipher_type_t cipher_type,\n                              int block_size,\n                              int num_tests )\n{\n    int i, ret = 0;\n    mbedtls_cipher_context_t ctx;\n    const mbedtls_cipher_info_t *cipher_info;\n    unsigned char K1[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];\n\n    cipher_info = mbedtls_cipher_info_from_type( cipher_type );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    for( i = 0; i < num_tests; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  %s CMAC subkey #%u: \", testname, i + 1 );\n\n        mbedtls_cipher_init( &ctx );\n\n        if( ( ret = mbedtls_cipher_setup( &ctx, cipher_info ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"test execution failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( ( ret = mbedtls_cipher_setkey( &ctx, key, keybits,\n                                       MBEDTLS_ENCRYPT ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"test execution failed\\n\" );\n\n            goto cleanup;\n        }\n\n        ret = cmac_generate_subkeys( &ctx, K1, K2 );\n        if( ret != 0 )\n        {\n           if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( ( ret = memcmp( K1, subkeys, block_size ) ) != 0  ||\n            ( ret = memcmp( K2, &subkeys[block_size], block_size ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n\n        mbedtls_cipher_free( &ctx );\n    }\n\n    goto exit;\n\ncleanup:\n    mbedtls_cipher_free( &ctx );\n\nexit:\n    return( ret );\n}\n\nstatic int cmac_test_wth_cipher( int verbose,\n                                 const char* testname,\n                                 const unsigned char* key,\n                                 int keybits,\n                                 const unsigned char* messages,\n                                 const unsigned int message_lengths[4],\n                                 const unsigned char* expected_result,\n                                 mbedtls_cipher_type_t cipher_type,\n                                 int block_size,\n                                 int num_tests )\n{\n    const mbedtls_cipher_info_t *cipher_info;\n    int i, ret = 0;\n    unsigned char output[MBEDTLS_CIPHER_BLKSIZE_MAX];\n\n    cipher_info = mbedtls_cipher_info_from_type( cipher_type );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;\n        goto exit;\n    }\n\n    for( i = 0; i < num_tests; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  %s CMAC #%u: \", testname, i + 1 );\n\n        if( ( ret = mbedtls_cipher_cmac( cipher_info, key, keybits, messages,\n                                         message_lengths[i], output ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n            goto exit;\n        }\n\n        if( ( ret = memcmp( output, &expected_result[i * block_size], block_size ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\nexit:\n    return( ret );\n}\n\n#if defined(MBEDTLS_AES_C)\nstatic int test_aes128_cmac_prf( int verbose )\n{\n    int i;\n    int ret;\n    unsigned char output[MBEDTLS_AES_BLOCK_SIZE];\n\n    for( i = 0; i < NB_PRF_TESTS; i++ )\n    {\n        mbedtls_printf( \"  AES CMAC 128 PRF #%u: \", i );\n        ret = mbedtls_aes_cmac_prf_128( PRFK, PRFKlen[i], PRFM, 20, output );\n        if( ret != 0 ||\n            memcmp( output, PRFT[i], MBEDTLS_AES_BLOCK_SIZE ) != 0 )\n        {\n\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            return( ret );\n        }\n        else if( verbose != 0 )\n        {\n            mbedtls_printf( \"passed\\n\" );\n        }\n    }\n    return( ret );\n}\n#endif /* MBEDTLS_AES_C */\n\nint mbedtls_cmac_self_test( int verbose )\n{\n    int ret;\n\n#if defined(MBEDTLS_AES_C)\n    /* AES-128 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 128\",\n                                   aes_128_key,\n                                   128,\n                                   (const unsigned char*)aes_128_subkeys,\n                                   MBEDTLS_CIPHER_AES_128_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"AES 128\",\n                                      aes_128_key,\n                                      128,\n                                      test_message,\n                                      aes_message_lengths,\n                                      (const unsigned char*)aes_128_expected_result,\n                                      MBEDTLS_CIPHER_AES_128_ECB,\n                                      MBEDTLS_AES_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* AES-192 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 192\",\n                                   aes_192_key,\n                                   192,\n                                   (const unsigned char*)aes_192_subkeys,\n                                   MBEDTLS_CIPHER_AES_192_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"AES 192\",\n                                      aes_192_key,\n                                      192,\n                                      test_message,\n                                      aes_message_lengths,\n                                      (const unsigned char*)aes_192_expected_result,\n                                      MBEDTLS_CIPHER_AES_192_ECB,\n                                      MBEDTLS_AES_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* AES-256 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 256\",\n                                   aes_256_key,\n                                   256,\n                                   (const unsigned char*)aes_256_subkeys,\n                                   MBEDTLS_CIPHER_AES_256_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher ( verbose,\n                                       \"AES 256\",\n                                       aes_256_key,\n                                       256,\n                                       test_message,\n                                       aes_message_lengths,\n                                       (const unsigned char*)aes_256_expected_result,\n                                       MBEDTLS_CIPHER_AES_256_ECB,\n                                       MBEDTLS_AES_BLOCK_SIZE,\n                                       NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_DES_C)\n    /* 3DES 2 key */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"3DES 2 key\",\n                                   des3_2key_key,\n                                   192,\n                                   (const unsigned char*)des3_2key_subkeys,\n                                   MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                   MBEDTLS_DES3_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"3DES 2 key\",\n                                      des3_2key_key,\n                                      192,\n                                      test_message,\n                                      des3_message_lengths,\n                                      (const unsigned char*)des3_2key_expected_result,\n                                      MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                      MBEDTLS_DES3_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* 3DES 3 key */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"3DES 3 key\",\n                                   des3_3key_key,\n                                   192,\n                                   (const unsigned char*)des3_3key_subkeys,\n                                   MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                   MBEDTLS_DES3_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"3DES 3 key\",\n                                      des3_3key_key,\n                                      192,\n                                      test_message,\n                                      des3_message_lengths,\n                                      (const unsigned char*)des3_3key_expected_result,\n                                      MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                      MBEDTLS_DES3_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n    if( ( ret = test_aes128_cmac_prf( verbose ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_AES_C */\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    return( 0 );\n}\n\n#endif /* MBEDTLS_SELF_TEST */\n\n#endif /* MBEDTLS_CMAC_C */\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n\nDescription: Timer objects and scheduling management\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis and Gregory Cristian\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"LoRaWANTimer.h\"\n\nLoRaWANTimeHandler::LoRaWANTimeHandler()\n    : _queue(NULL)\n{\n}\n\nLoRaWANTimeHandler::~LoRaWANTimeHandler()\n{\n}\n\nvoid LoRaWANTimeHandler::activate_timer_subsystem(events::EventQueue *queue)\n{\n    _queue = queue;\n}\n\nlorawan_time_t LoRaWANTimeHandler::get_current_time( void )\n{\n    const uint32_t current_time = _queue->tick();\n    return (lorawan_time_t)current_time;\n}\n\nlorawan_time_t LoRaWANTimeHandler::get_elapsed_time(lorawan_time_t saved_time)\n{\n    return get_current_time() - saved_time;\n}\n\nvoid LoRaWANTimeHandler::init(timer_event_t &obj, mbed::Callback<void()> callback)\n{\n    obj.callback = callback;\n    obj.timer_id = 0;\n}\n\nvoid LoRaWANTimeHandler::start(timer_event_t &obj, const uint32_t timeout)\n{\n    obj.timer_id = _queue->call_in(timeout, obj.callback);\n    MBED_ASSERT(obj.timer_id != 0);\n}\n\nvoid LoRaWANTimeHandler::stop(timer_event_t &obj)\n{\n    _queue->cancel(obj.timer_id);\n    obj.timer_id = 0;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n\n#include \"gpio_irq_api.h\"\n#include \"mbed_error.h\"\n#include \"emscripten.h\"\n\nstatic gpio_irq_handler irq_handler;\n\nEMSCRIPTEN_KEEPALIVE\nvoid handle_interrupt_in(uint32_t id, gpio_irq_event event) {\n    irq_handler(id, event);\n}\n\nint gpio_irq_init(gpio_irq_t *obj, PinName pin, gpio_irq_handler handler, uint32_t id) {\n    if (pin == NC) return -1;\n\n    irq_handler = handler;\n\n    obj->port = pin;\n    obj->pin = pin;\n\n    EM_ASM_({\n        MbedJSHal.gpio.irq_init($0, $1);\n    }, id, obj->pin);\n\n    return 0;\n}\n\nvoid gpio_irq_free(gpio_irq_t *obj) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_free($0);\n    }, obj->pin, obj->id);\n}\n\nvoid gpio_irq_set(gpio_irq_t *obj, gpio_irq_event event, uint32_t enable) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_set($0, $1, $2);\n    }, obj->pin, event, enable);\n}\n\nvoid gpio_irq_enable(gpio_irq_t *obj) {\n}\n\nvoid gpio_irq_disable(gpio_irq_t *obj) {\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","/*\n *  NIST SP800-38C compliant CCM implementation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n/*\n * Definition of CCM:\n * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf\n * RFC 3610 \"Counter with CBC-MAC (CCM)\"\n *\n * Related:\n * RFC 5116 \"An Interface and Algorithms for Authenticated Encryption\"\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n\n#include \"mbedtls/ccm.h\"\n#include \"mbedtls/platform_util.h\"\n\n#include <string.h>\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdio.h>\n#define mbedtls_printf printf\n#endif /* MBEDTLS_PLATFORM_C */\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#if !defined(MBEDTLS_CCM_ALT)\n\n#define CCM_ENCRYPT 0\n#define CCM_DECRYPT 1\n\n/*\n * Initialize context\n */\nvoid mbedtls_ccm_init( mbedtls_ccm_context *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_ccm_context ) );\n}\n\nint mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,\n                        mbedtls_cipher_id_t cipher,\n                        const unsigned char *key,\n                        unsigned int keybits )\n{\n    int ret;\n    const mbedtls_cipher_info_t *cipher_info;\n\n    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );\n    if( cipher_info == NULL )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    if( cipher_info->block_size != 16 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n\n    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,\n                               MBEDTLS_ENCRYPT ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}\n\n/*\n * Free context\n */\nvoid mbedtls_ccm_free( mbedtls_ccm_context *ctx )\n{\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );\n}\n\n/*\n * Macros for common operations.\n * Results in smaller compiled code than static inline functions.\n */\n\n/*\n * Update the CBC-MAC state in y using a block in b\n * (Always using b as the source helps the compiler optimise a bit better.)\n */\n#define UPDATE_CBC_MAC                                                      \\\n    for( i = 0; i < 16; i++ )                                               \\\n        y[i] ^= b[i];                                                       \\\n                                                                            \\\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, y, 16, y, &olen ) ) != 0 ) \\\n        return( ret );\n\n/*\n * Encrypt or decrypt a partial block with CTR\n * Warning: using b for temporary storage! src and dst must not be b!\n * This avoids allocating one more 16 bytes buffer while allowing src == dst.\n */\n#define CTR_CRYPT( dst, src, len  )                                            \\\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctr, 16, b, &olen ) ) != 0 )  \\\n        return( ret );                                                         \\\n                                                                               \\\n    for( i = 0; i < len; i++ )                                                 \\\n        dst[i] = src[i] ^ b[i];\n\n/*\n * Authenticated encryption or decryption\n */\nstatic int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,\n                           const unsigned char *iv, size_t iv_len,\n                           const unsigned char *add, size_t add_len,\n                           const unsigned char *input, unsigned char *output,\n                           unsigned char *tag, size_t tag_len )\n{\n    int ret;\n    unsigned char i;\n    unsigned char q;\n    size_t len_left, olen;\n    unsigned char b[16];\n    unsigned char y[16];\n    unsigned char ctr[16];\n    const unsigned char *src;\n    unsigned char *dst;\n\n    /*\n     * Check length requirements: SP800-38C A.1\n     * Additional requirement: a < 2^16 - 2^8 to simplify the code.\n     * 'length' checked later (when writing it to the first block)\n     */\n    if( tag_len < 4 || tag_len > 16 || tag_len % 2 != 0 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    /* Also implies q is within bounds */\n    if( iv_len < 7 || iv_len > 13 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    if( add_len > 0xFF00 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    q = 16 - 1 - (unsigned char) iv_len;\n\n    /*\n     * First block B_0:\n     * 0        .. 0        flags\n     * 1        .. iv_len   nonce (aka iv)\n     * iv_len+1 .. 15       length\n     *\n     * With flags as (bits):\n     * 7        0\n     * 6        add present?\n     * 5 .. 3   (t - 2) / 2\n     * 2 .. 0   q - 1\n     */\n    b[0] = 0;\n    b[0] |= ( add_len > 0 ) << 6;\n    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;\n    b[0] |= q - 1;\n\n    memcpy( b + 1, iv, iv_len );\n\n    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )\n        b[15-i] = (unsigned char)( len_left & 0xFF );\n\n    if( len_left > 0 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n\n    /* Start CBC-MAC with first block */\n    memset( y, 0, 16 );\n    UPDATE_CBC_MAC;\n\n    /*\n     * If there is additional data, update CBC-MAC with\n     * add_len, add, 0 (padding to a block boundary)\n     */\n    if( add_len > 0 )\n    {\n        size_t use_len;\n        len_left = add_len;\n        src = add;\n\n        memset( b, 0, 16 );\n        b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );\n        b[1] = (unsigned char)( ( add_len      ) & 0xFF );\n\n        use_len = len_left < 16 - 2 ? len_left : 16 - 2;\n        memcpy( b + 2, src, use_len );\n        len_left -= use_len;\n        src += use_len;\n\n        UPDATE_CBC_MAC;\n\n        while( len_left > 0 )\n        {\n            use_len = len_left > 16 ? 16 : len_left;\n\n            memset( b, 0, 16 );\n            memcpy( b, src, use_len );\n            UPDATE_CBC_MAC;\n\n            len_left -= use_len;\n            src += use_len;\n        }\n    }\n\n    /*\n     * Prepare counter block for encryption:\n     * 0        .. 0        flags\n     * 1        .. iv_len   nonce (aka iv)\n     * iv_len+1 .. 15       counter (initially 1)\n     *\n     * With flags as (bits):\n     * 7 .. 3   0\n     * 2 .. 0   q - 1\n     */\n    ctr[0] = q - 1;\n    memcpy( ctr + 1, iv, iv_len );\n    memset( ctr + 1 + iv_len, 0, q );\n    ctr[15] = 1;\n\n    /*\n     * Authenticate and {en,de}crypt the message.\n     *\n     * The only difference between encryption and decryption is\n     * the respective order of authentication and {en,de}cryption.\n     */\n    len_left = length;\n    src = input;\n    dst = output;\n\n    while( len_left > 0 )\n    {\n        size_t use_len = len_left > 16 ? 16 : len_left;\n\n        if( mode == CCM_ENCRYPT )\n        {\n            memset( b, 0, 16 );\n            memcpy( b, src, use_len );\n            UPDATE_CBC_MAC;\n        }\n\n        CTR_CRYPT( dst, src, use_len );\n\n        if( mode == CCM_DECRYPT )\n        {\n            memset( b, 0, 16 );\n            memcpy( b, dst, use_len );\n            UPDATE_CBC_MAC;\n        }\n\n        dst += use_len;\n        src += use_len;\n        len_left -= use_len;\n\n        /*\n         * Increment counter.\n         * No need to check for overflow thanks to the length check above.\n         */\n        for( i = 0; i < q; i++ )\n            if( ++ctr[15-i] != 0 )\n                break;\n    }\n\n    /*\n     * Authentication: reset counter and crypt/mask internal tag\n     */\n    for( i = 0; i < q; i++ )\n        ctr[15-i] = 0;\n\n    CTR_CRYPT( y, y, 16 );\n    memcpy( tag, y, tag_len );\n\n    return( 0 );\n}\n\n/*\n * Authenticated encryption\n */\nint mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *add, size_t add_len,\n                         const unsigned char *input, unsigned char *output,\n                         unsigned char *tag, size_t tag_len )\n{\n    return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,\n                            add, add_len, input, output, tag, tag_len ) );\n}\n\n/*\n * Authenticated decryption\n */\nint mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,\n                      const unsigned char *iv, size_t iv_len,\n                      const unsigned char *add, size_t add_len,\n                      const unsigned char *input, unsigned char *output,\n                      const unsigned char *tag, size_t tag_len )\n{\n    int ret;\n    unsigned char check_tag[16];\n    unsigned char i;\n    int diff;\n\n    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,\n                                iv, iv_len, add, add_len,\n                                input, output, check_tag, tag_len ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* Check tag in \"constant-time\" */\n    for( diff = 0, i = 0; i < tag_len; i++ )\n        diff |= tag[i] ^ check_tag[i];\n\n    if( diff != 0 )\n    {\n        mbedtls_platform_zeroize( output, length );\n        return( MBEDTLS_ERR_CCM_AUTH_FAILED );\n    }\n\n    return( 0 );\n}\n\n#endif /* !MBEDTLS_CCM_ALT */\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n/*\n * Examples 1 to 3 from SP800-38C Appendix C\n */\n\n#define NB_TESTS 3\n\n/*\n * The data is the same for all tests, only the used length changes\n */\nstatic const unsigned char key[] = {\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f\n};\n\nstatic const unsigned char iv[] = {\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b\n};\n\nstatic const unsigned char ad[] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13\n};\n\nstatic const unsigned char msg[] = {\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n};\n\nstatic const size_t iv_len [NB_TESTS] = { 7, 8,  12 };\nstatic const size_t add_len[NB_TESTS] = { 8, 16, 20 };\nstatic const size_t msg_len[NB_TESTS] = { 4, 16, 24 };\nstatic const size_t tag_len[NB_TESTS] = { 4, 6,  8  };\n\nstatic const unsigned char res[NB_TESTS][32] = {\n    {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },\n    {   0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,\n        0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,\n        0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd },\n    {   0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,\n        0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,\n        0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,\n        0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51 }\n};\n\nint mbedtls_ccm_self_test( int verbose )\n{\n    mbedtls_ccm_context ctx;\n    unsigned char out[32];\n    size_t i;\n    int ret;\n\n    mbedtls_ccm_init( &ctx );\n\n    if( mbedtls_ccm_setkey( &ctx, MBEDTLS_CIPHER_ID_AES, key, 8 * sizeof key ) != 0 )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  CCM: setup failed\" );\n\n        return( 1 );\n    }\n\n    for( i = 0; i < NB_TESTS; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  CCM-AES #%u: \", (unsigned int) i + 1 );\n\n        ret = mbedtls_ccm_encrypt_and_tag( &ctx, msg_len[i],\n                                   iv, iv_len[i], ad, add_len[i],\n                                   msg, out,\n                                   out + msg_len[i], tag_len[i] );\n\n        if( ret != 0 ||\n            memcmp( out, res[i], msg_len[i] + tag_len[i] ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        ret = mbedtls_ccm_auth_decrypt( &ctx, msg_len[i],\n                                iv, iv_len[i], ad, add_len[i],\n                                res[i], out,\n                                res[i] + msg_len[i], tag_len[i] );\n\n        if( ret != 0 ||\n            memcmp( out, msg, msg_len[i] ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    mbedtls_ccm_free( &ctx );\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    return( 0 );\n}\n\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#endif /* MBEDTLS_CCM_C */\n","/**\n * \\file cipher.c\n *\n * \\brief Generic cipher wrapper for mbed TLS\n *\n * \\author Adriaan de Jong <dejong@fox-it.com>\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CIPHER_C)\n\n#include \"mbedtls/cipher.h\"\n#include \"mbedtls/cipher_internal.h\"\n#include \"mbedtls/platform_util.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(MBEDTLS_GCM_C)\n#include \"mbedtls/gcm.h\"\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n#include \"mbedtls/ccm.h\"\n#endif\n\n#if defined(MBEDTLS_CMAC_C)\n#include \"mbedtls/cmac.h\"\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#define mbedtls_calloc calloc\n#define mbedtls_free   free\n#endif\n\n#if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)\n#define MBEDTLS_CIPHER_MODE_STREAM\n#endif\n\nstatic int supported_init = 0;\n\nconst int *mbedtls_cipher_list( void )\n{\n    const mbedtls_cipher_definition_t *def;\n    int *type;\n\n    if( ! supported_init )\n    {\n        def = mbedtls_cipher_definitions;\n        type = mbedtls_cipher_supported;\n\n        while( def->type != 0 )\n            *type++ = (*def++).type;\n\n        *type = 0;\n\n        supported_init = 1;\n    }\n\n    return( mbedtls_cipher_supported );\n}\n\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )\n        if( def->type == cipher_type )\n            return( def->info );\n\n    return( NULL );\n}\n\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    if( NULL == cipher_name )\n        return( NULL );\n\n    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )\n        if( !  strcmp( def->info->name, cipher_name ) )\n            return( def->info );\n\n    return( NULL );\n}\n\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,\n                                              int key_bitlen,\n                                              const mbedtls_cipher_mode_t mode )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )\n        if( def->info->base->cipher == cipher_id &&\n            def->info->key_bitlen == (unsigned) key_bitlen &&\n            def->info->mode == mode )\n            return( def->info );\n\n    return( NULL );\n}\n\nvoid mbedtls_cipher_init( mbedtls_cipher_context_t *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );\n}\n\nvoid mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n#if defined(MBEDTLS_CMAC_C)\n    if( ctx->cmac_ctx )\n    {\n       mbedtls_platform_zeroize( ctx->cmac_ctx,\n                                 sizeof( mbedtls_cmac_context_t ) );\n       mbedtls_free( ctx->cmac_ctx );\n    }\n#endif\n\n    if( ctx->cipher_ctx )\n        ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );\n\n    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );\n}\n\nint mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info )\n{\n    if( NULL == cipher_info || NULL == ctx )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );\n\n    if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )\n        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );\n\n    ctx->cipher_info = cipher_info;\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n    /*\n     * Ignore possible errors caused by a cipher mode that doesn't use padding\n     */\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );\n#else\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );\n#endif\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n    return( 0 );\n}\n\nint mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx, const unsigned char *key,\n        int key_bitlen, const mbedtls_operation_t operation )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&\n        (int) ctx->cipher_info->key_bitlen != key_bitlen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    ctx->key_bitlen = key_bitlen;\n    ctx->operation = operation;\n\n    /*\n     * For CFB and CTR mode always use the encryption key schedule\n     */\n    if( MBEDTLS_ENCRYPT == operation ||\n        MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_CTR == ctx->cipher_info->mode )\n    {\n        return ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,\n                ctx->key_bitlen );\n    }\n\n    if( MBEDTLS_DECRYPT == operation )\n        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,\n                ctx->key_bitlen );\n\n    return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n}\n\nint mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,\n                   const unsigned char *iv, size_t iv_len )\n{\n    size_t actual_iv_size;\n\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == iv )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    /* avoid buffer overflow in ctx->iv */\n    if( iv_len > MBEDTLS_MAX_IV_LENGTH )\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n\n    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )\n        actual_iv_size = iv_len;\n    else\n    {\n        actual_iv_size = ctx->cipher_info->iv_size;\n\n        /* avoid reading past the end of input buffer */\n        if( actual_iv_size > iv_len )\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    memcpy( ctx->iv, iv, actual_iv_size );\n    ctx->iv_size = actual_iv_size;\n\n    return( 0 );\n}\n\nint mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    ctx->unprocessed_len = 0;\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_GCM_C)\nint mbedtls_cipher_update_ad( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *ad, size_t ad_len )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        return mbedtls_gcm_starts( (mbedtls_gcm_context *) ctx->cipher_ctx, ctx->operation,\n                           ctx->iv, ctx->iv_size, ad, ad_len );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_GCM_C */\n\nint mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t block_size = 0;\n\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    *olen = 0;\n    block_size = mbedtls_cipher_get_block_size( ctx );\n\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )\n    {\n        if( ilen != block_size )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        *olen = ilen;\n\n        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,\n                    ctx->operation, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_GCM_C)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )\n    {\n        *olen = ilen;\n        return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,\n                           output );\n    }\n#endif\n\n    if ( 0 == block_size )\n    {\n        return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;\n    }\n\n    if( input == output &&\n       ( ctx->unprocessed_len != 0 || ilen % block_size ) )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )\n    {\n        size_t copy_len = 0;\n\n        /*\n         * If there is not enough data for a full block, cache it.\n         */\n        if( ( ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&\n                ilen <= block_size - ctx->unprocessed_len ) ||\n            ( ctx->operation == MBEDTLS_DECRYPT && NULL == ctx->add_padding &&\n                ilen < block_size - ctx->unprocessed_len ) ||\n             ( ctx->operation == MBEDTLS_ENCRYPT &&\n                ilen < block_size - ctx->unprocessed_len ) )\n        {\n            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,\n                    ilen );\n\n            ctx->unprocessed_len += ilen;\n            return( 0 );\n        }\n\n        /*\n         * Process cached data first\n         */\n        if( 0 != ctx->unprocessed_len )\n        {\n            copy_len = block_size - ctx->unprocessed_len;\n\n            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,\n                    copy_len );\n\n            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                    ctx->operation, block_size, ctx->iv,\n                    ctx->unprocessed_data, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += block_size;\n            output += block_size;\n            ctx->unprocessed_len = 0;\n\n            input += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Cache final, incomplete block\n         */\n        if( 0 != ilen )\n        {\n            if( 0 == block_size )\n            {\n                return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;\n            }\n\n            /* Encryption: only cache partial blocks\n             * Decryption w/ padding: always keep at least one whole block\n             * Decryption w/o padding: only cache partial blocks\n             */\n            copy_len = ilen % block_size;\n            if( copy_len == 0 &&\n                ctx->operation == MBEDTLS_DECRYPT &&\n                NULL != ctx->add_padding)\n            {\n                copy_len = block_size;\n            }\n\n            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),\n                    copy_len );\n\n            ctx->unprocessed_len += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Process remaining full blocks\n         */\n        if( ilen )\n        {\n            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                    ctx->operation, ilen, ctx->iv, input, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += ilen;\n        }\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CFB )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,\n                ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,\n                input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CTR )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,\n                ilen, &ctx->unprocessed_len, ctx->iv,\n                ctx->unprocessed_data, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_STREAM )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->stream_func( ctx->cipher_ctx,\n                                                    ilen, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_STREAM */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n/*\n * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len\n */\nstatic void add_pkcs_padding( unsigned char *output, size_t output_len,\n        size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i;\n\n    for( i = 0; i < padding_len; i++ )\n        output[data_len + i] = (unsigned char) padding_len;\n}\n\nstatic int get_pkcs_padding( unsigned char *input, size_t input_len,\n        size_t *data_len )\n{\n    size_t i, pad_idx;\n    unsigned char padding_len, bad = 0;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    padding_len = input[input_len - 1];\n    *data_len = input_len - padding_len;\n\n    /* Avoid logical || since it results in a branch */\n    bad |= padding_len > input_len;\n    bad |= padding_len == 0;\n\n    /* The number of bytes checked must be independent of padding_len,\n     * so pick input_len, which is usually 8 or 16 (one block) */\n    pad_idx = input_len - padding_len;\n    for( i = 0; i < input_len; i++ )\n        bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n}\n#endif /* MBEDTLS_CIPHER_PADDING_PKCS7 */\n\n#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)\n/*\n * One and zeros padding: fill with 80 00 ... 00\n */\nstatic void add_one_and_zeros_padding( unsigned char *output,\n                                       size_t output_len, size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i = 0;\n\n    output[data_len] = 0x80;\n    for( i = 1; i < padding_len; i++ )\n        output[data_len + i] = 0x00;\n}\n\nstatic int get_one_and_zeros_padding( unsigned char *input, size_t input_len,\n                                      size_t *data_len )\n{\n    size_t i;\n    unsigned char done = 0, prev_done, bad;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    bad = 0x80;\n    *data_len = 0;\n    for( i = input_len; i > 0; i-- )\n    {\n        prev_done = done;\n        done |= ( input[i - 1] != 0 );\n        *data_len |= ( i - 1 ) * ( done != prev_done );\n        bad ^= input[i - 1] * ( done != prev_done );\n    }\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n\n}\n#endif /* MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS */\n\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)\n/*\n * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length\n */\nstatic void add_zeros_and_len_padding( unsigned char *output,\n                                       size_t output_len, size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i = 0;\n\n    for( i = 1; i < padding_len; i++ )\n        output[data_len + i - 1] = 0x00;\n    output[output_len - 1] = (unsigned char) padding_len;\n}\n\nstatic int get_zeros_and_len_padding( unsigned char *input, size_t input_len,\n                                      size_t *data_len )\n{\n    size_t i, pad_idx;\n    unsigned char padding_len, bad = 0;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    padding_len = input[input_len - 1];\n    *data_len = input_len - padding_len;\n\n    /* Avoid logical || since it results in a branch */\n    bad |= padding_len > input_len;\n    bad |= padding_len == 0;\n\n    /* The number of bytes checked must be independent of padding_len */\n    pad_idx = input_len - padding_len;\n    for( i = 0; i < input_len - 1; i++ )\n        bad |= input[i] * ( i >= pad_idx );\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n}\n#endif /* MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN */\n\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)\n/*\n * Zero padding: fill with 00 ... 00\n */\nstatic void add_zeros_padding( unsigned char *output,\n                               size_t output_len, size_t data_len )\n{\n    size_t i;\n\n    for( i = data_len; i < output_len; i++ )\n        output[i] = 0x00;\n}\n\nstatic int get_zeros_padding( unsigned char *input, size_t input_len,\n                              size_t *data_len )\n{\n    size_t i;\n    unsigned char done = 0, prev_done;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *data_len = 0;\n    for( i = input_len; i > 0; i-- )\n    {\n        prev_done = done;\n        done |= ( input[i-1] != 0 );\n        *data_len |= i * ( done != prev_done );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_PADDING_ZEROS */\n\n/*\n * No padding: don't pad :)\n *\n * There is no add_padding function (check for NULL in mbedtls_cipher_finish)\n * but a trivial get_padding function\n */\nstatic int get_no_padding( unsigned char *input, size_t input_len,\n                              size_t *data_len )\n{\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *data_len = input_len;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\nint mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,\n                   unsigned char *output, size_t *olen )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *olen = 0;\n\n    if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )\n    {\n        return( 0 );\n    }\n\n    if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )\n    {\n        if( ctx->unprocessed_len != 0 )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( MBEDTLS_MODE_CBC == ctx->cipher_info->mode )\n    {\n        int ret = 0;\n\n        if( MBEDTLS_ENCRYPT == ctx->operation )\n        {\n            /* check for 'no padding' mode */\n            if( NULL == ctx->add_padding )\n            {\n                if( 0 != ctx->unprocessed_len )\n                    return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n                return( 0 );\n            }\n\n            ctx->add_padding( ctx->unprocessed_data, mbedtls_cipher_get_iv_size( ctx ),\n                    ctx->unprocessed_len );\n        }\n        else if( mbedtls_cipher_get_block_size( ctx ) != ctx->unprocessed_len )\n        {\n            /*\n             * For decrypt operations, expect a full block,\n             * or an empty block if no padding\n             */\n            if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )\n                return( 0 );\n\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n        }\n\n        /* cipher block */\n        if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                ctx->operation, mbedtls_cipher_get_block_size( ctx ), ctx->iv,\n                ctx->unprocessed_data, output ) ) )\n        {\n            return( ret );\n        }\n\n        /* Set output size for decryption */\n        if( MBEDTLS_DECRYPT == ctx->operation )\n            return ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),\n                                     olen );\n\n        /* Set output size for encryption */\n        *olen = mbedtls_cipher_get_block_size( ctx );\n        return( 0 );\n    }\n#else\n    ((void) output);\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\nint mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode )\n{\n    if( NULL == ctx ||\n        MBEDTLS_MODE_CBC != ctx->cipher_info->mode )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    switch( mode )\n    {\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    case MBEDTLS_PADDING_PKCS7:\n        ctx->add_padding = add_pkcs_padding;\n        ctx->get_padding = get_pkcs_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)\n    case MBEDTLS_PADDING_ONE_AND_ZEROS:\n        ctx->add_padding = add_one_and_zeros_padding;\n        ctx->get_padding = get_one_and_zeros_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)\n    case MBEDTLS_PADDING_ZEROS_AND_LEN:\n        ctx->add_padding = add_zeros_and_len_padding;\n        ctx->get_padding = get_zeros_and_len_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)\n    case MBEDTLS_PADDING_ZEROS:\n        ctx->add_padding = add_zeros_padding;\n        ctx->get_padding = get_zeros_padding;\n        break;\n#endif\n    case MBEDTLS_PADDING_NONE:\n        ctx->add_padding = NULL;\n        ctx->get_padding = get_no_padding;\n        break;\n\n    default:\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n#if defined(MBEDTLS_GCM_C)\nint mbedtls_cipher_write_tag( mbedtls_cipher_context_t *ctx,\n                      unsigned char *tag, size_t tag_len )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == tag )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( MBEDTLS_ENCRYPT != ctx->operation )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n        return mbedtls_gcm_finish( (mbedtls_gcm_context *) ctx->cipher_ctx, tag, tag_len );\n\n    return( 0 );\n}\n\nint mbedtls_cipher_check_tag( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *tag, size_t tag_len )\n{\n    int ret;\n\n    if( NULL == ctx || NULL == ctx->cipher_info ||\n        MBEDTLS_DECRYPT != ctx->operation )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        unsigned char check_tag[16];\n        size_t i;\n        int diff;\n\n        if( tag_len > sizeof( check_tag ) )\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n        if( 0 != ( ret = mbedtls_gcm_finish( (mbedtls_gcm_context *) ctx->cipher_ctx,\n                                     check_tag, tag_len ) ) )\n        {\n            return( ret );\n        }\n\n        /* Check the tag in \"constant-time\" */\n        for( diff = 0, i = 0; i < tag_len; i++ )\n            diff |= tag[i] ^ check_tag[i];\n\n        if( diff != 0 )\n            return( MBEDTLS_ERR_CIPHER_AUTH_FAILED );\n\n        return( 0 );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_GCM_C */\n\n/*\n * Packet-oriented wrapper for non-AEAD modes\n */\nint mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t finish_olen;\n\n    if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, &finish_olen ) ) != 0 )\n        return( ret );\n\n    *olen += finish_olen;\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_AEAD)\n/*\n * Packet-oriented encryption for AEAD modes\n */\nint mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         unsigned char *tag, size_t tag_len )\n{\n#if defined(MBEDTLS_GCM_C)\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        *olen = ilen;\n        return( mbedtls_gcm_crypt_and_tag( ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT, ilen,\n                                   iv, iv_len, ad, ad_len, input, output,\n                                   tag_len, tag ) );\n    }\n#endif /* MBEDTLS_GCM_C */\n#if defined(MBEDTLS_CCM_C)\n    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )\n    {\n        *olen = ilen;\n        return( mbedtls_ccm_encrypt_and_tag( ctx->cipher_ctx, ilen,\n                                     iv, iv_len, ad, ad_len, input, output,\n                                     tag, tag_len ) );\n    }\n#endif /* MBEDTLS_CCM_C */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n\n/*\n * Packet-oriented decryption for AEAD modes\n */\nint mbedtls_cipher_auth_decrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         const unsigned char *tag, size_t tag_len )\n{\n#if defined(MBEDTLS_GCM_C)\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        int ret;\n\n        *olen = ilen;\n        ret = mbedtls_gcm_auth_decrypt( ctx->cipher_ctx, ilen,\n                                iv, iv_len, ad, ad_len,\n                                tag, tag_len, input, output );\n\n        if( ret == MBEDTLS_ERR_GCM_AUTH_FAILED )\n            ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;\n\n        return( ret );\n    }\n#endif /* MBEDTLS_GCM_C */\n#if defined(MBEDTLS_CCM_C)\n    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )\n    {\n        int ret;\n\n        *olen = ilen;\n        ret = mbedtls_ccm_auth_decrypt( ctx->cipher_ctx, ilen,\n                                iv, iv_len, ad, ad_len,\n                                input, output, tag, tag_len );\n\n        if( ret == MBEDTLS_ERR_CCM_AUTH_FAILED )\n            ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;\n\n        return( ret );\n    }\n#endif /* MBEDTLS_CCM_C */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n#endif /* MBEDTLS_CIPHER_MODE_AEAD */\n\n#endif /* MBEDTLS_CIPHER_C */\n","/**\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *    (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * Description: LoRa MAC crypto implementation\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jckle ( STACKFORCE )\n *\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n *\n * SPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"LoRaMacCrypto.h\"\n#include \"system/lorawan_data_structures.h\"\n\n\n#if defined(MBEDTLS_CMAC_C) && defined(MBEDTLS_AES_C) && defined(MBEDTLS_CIPHER_C)\n\nLoRaMacCrypto::LoRaMacCrypto()\n    : mic_block_b0(),\n      computed_mic(),\n      a_block(),\n      s_block()\n{\n    mic_block_b0[0] = 0x49;\n    a_block[0] = 0x01;\n}\n\nint LoRaMacCrypto::compute_mic(const uint8_t *buffer, uint16_t size,\n                               const uint8_t *key, const uint32_t key_length,\n                               uint32_t address, uint8_t dir, uint32_t seq_counter,\n                               uint32_t *mic)\n{\n    int ret = 0;\n\n    mic_block_b0[5] = dir;\n\n    mic_block_b0[6] = (address) & 0xFF;\n    mic_block_b0[7] = (address >> 8) & 0xFF;\n    mic_block_b0[8] = (address >> 16) & 0xFF;\n    mic_block_b0[9] = (address >> 24) & 0xFF;\n\n    mic_block_b0[10] = (seq_counter) & 0xFF;\n    mic_block_b0[11] = (seq_counter >> 8) & 0xFF;\n    mic_block_b0[12] = (seq_counter >> 16) & 0xFF;\n    mic_block_b0[13] = (seq_counter >> 24) & 0xFF;\n\n    mic_block_b0[15] = size & 0xFF;\n\n    mbedtls_cipher_init(aes_cmac_ctx);\n\n    const mbedtls_cipher_info_t* cipher_info = mbedtls_cipher_info_from_type(MBEDTLS_CIPHER_AES_128_ECB);\n\n    if (NULL != cipher_info) {\n        ret = mbedtls_cipher_setup(aes_cmac_ctx, cipher_info);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_starts(aes_cmac_ctx, key, key_length);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_update(aes_cmac_ctx, mic_block_b0, sizeof(mic_block_b0));\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_update(aes_cmac_ctx, buffer, size & 0xFF);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_finish(aes_cmac_ctx, computed_mic);\n        if (0 != ret)\n            goto exit;\n\n        *mic = (uint32_t) ((uint32_t) computed_mic[3] << 24\n                | (uint32_t) computed_mic[2] << 16\n                | (uint32_t) computed_mic[1] << 8 | (uint32_t) computed_mic[0]);\n    } else {\n        ret = MBEDTLS_ERR_CIPHER_ALLOC_FAILED;\n    }\n\nexit: mbedtls_cipher_free(aes_cmac_ctx);\n    return ret;\n}\n\nint LoRaMacCrypto::encrypt_payload(const uint8_t *buffer, uint16_t size,\n                                   const uint8_t *key, const uint32_t key_length,\n                                   uint32_t address, uint8_t dir, uint32_t seq_counter,\n                                   uint8_t *enc_buffer)\n{\n    uint16_t i;\n    uint8_t bufferIndex = 0;\n    uint16_t ctr = 1;\n    int ret = 0;\n\n    mbedtls_aes_init(&aes_ctx);\n    ret = mbedtls_aes_setkey_enc(&aes_ctx, key, key_length);\n    if (0 != ret)\n        goto exit;\n\n    a_block[5] = dir;\n\n    a_block[6] = (address) & 0xFF;\n    a_block[7] = (address >> 8) & 0xFF;\n    a_block[8] = (address >> 16) & 0xFF;\n    a_block[9] = (address >> 24) & 0xFF;\n\n    a_block[10] = (seq_counter) & 0xFF;\n    a_block[11] = (seq_counter >> 8) & 0xFF;\n    a_block[12] = (seq_counter >> 16) & 0xFF;\n    a_block[13] = (seq_counter >> 24) & 0xFF;\n\n    while (size >= 16) {\n        a_block[15] = ((ctr) & 0xFF);\n        ctr++;\n        ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, a_block,\n                                    s_block);\n        if (0 != ret)\n            goto exit;\n\n        for (i = 0; i < 16; i++) {\n            enc_buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ s_block[i];\n        }\n        size -= 16;\n        bufferIndex += 16;\n    }\n\n    if (size > 0) {\n        a_block[15] = ((ctr) & 0xFF);\n        ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, a_block,\n                                    s_block);\n        if (0 != ret)\n            goto exit;\n\n        for (i = 0; i < size; i++) {\n            enc_buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ s_block[i];\n        }\n    }\n\nexit: mbedtls_aes_free(&aes_ctx);\n    return ret;\n}\n\nint LoRaMacCrypto::decrypt_payload(const uint8_t *buffer, uint16_t size,\n                                   const uint8_t *key, uint32_t key_length,\n                                   uint32_t address, uint8_t dir, uint32_t seq_counter,\n                                   uint8_t *dec_buffer)\n{\n    return encrypt_payload(buffer, size, key, key_length, address, dir, seq_counter,\n                           dec_buffer);\n}\n\nint LoRaMacCrypto::compute_join_frame_mic(const uint8_t *buffer, uint16_t size,\n                                          const uint8_t *key, uint32_t key_length,\n                                          uint32_t *mic)\n{\n    int ret = 0;\n\n    mbedtls_cipher_init(aes_cmac_ctx);\n    const mbedtls_cipher_info_t* cipher_info = mbedtls_cipher_info_from_type(MBEDTLS_CIPHER_AES_128_ECB);\n\n    if (NULL != cipher_info) {\n        ret = mbedtls_cipher_setup(aes_cmac_ctx, cipher_info);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_starts(aes_cmac_ctx, key, key_length);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_update(aes_cmac_ctx, buffer, size & 0xFF);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_finish(aes_cmac_ctx, computed_mic);\n        if (0 != ret)\n            goto exit;\n\n        *mic = (uint32_t) ((uint32_t) computed_mic[3] << 24\n                | (uint32_t) computed_mic[2] << 16\n                | (uint32_t) computed_mic[1] << 8 | (uint32_t) computed_mic[0]);\n    } else {\n        ret = MBEDTLS_ERR_CIPHER_ALLOC_FAILED;\n    }\n\nexit: mbedtls_cipher_free(aes_cmac_ctx);\n    return ret;\n}\n\nint LoRaMacCrypto::decrypt_join_frame(const uint8_t *buffer, uint16_t size,\n                                      const uint8_t *key, uint32_t key_length,\n                                      uint8_t *dec_buffer)\n{\n    int ret = 0;\n\n    mbedtls_aes_init(&aes_ctx);\n\n    ret = mbedtls_aes_setkey_enc(&aes_ctx, key, key_length);\n    if (0 != ret)\n        goto exit;\n\n    ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, buffer,\n                                dec_buffer);\n    if (0 != ret)\n        goto exit;\n\n    // Check if optional CFList is included\n    if (size >= 16) {\n        ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, buffer + 16,\n                                    dec_buffer + 16);\n    }\n\nexit: mbedtls_aes_free(&aes_ctx);\n    return ret;\n}\n\nint LoRaMacCrypto::compute_skeys_for_join_frame(const uint8_t *key, uint32_t key_length,\n                                                const uint8_t *app_nonce, uint16_t dev_nonce,\n                                                uint8_t *nwk_skey, uint8_t *app_skey)\n{\n    uint8_t nonce[16];\n    uint8_t *p_dev_nonce = (uint8_t *) &dev_nonce;\n    int ret = 0;\n\n    mbedtls_aes_init(&aes_ctx);\n\n    ret = mbedtls_aes_setkey_enc(&aes_ctx, key, key_length);\n    if (0 != ret)\n        goto exit;\n\n    memset(nonce, 0, sizeof(nonce));\n    nonce[0] = 0x01;\n    memcpy(nonce + 1, app_nonce, 6);\n    memcpy(nonce + 7, p_dev_nonce, 2);\n    ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, nonce, nwk_skey);\n    if (0 != ret)\n        goto exit;\n\n    memset(nonce, 0, sizeof(nonce));\n    nonce[0] = 0x02;\n    memcpy(nonce + 1, app_nonce, 6);\n    memcpy(nonce + 7, p_dev_nonce, 2);\n    ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, nonce, app_skey);\n\n    exit: mbedtls_aes_free(&aes_ctx);\n    return ret;\n}\n#else\n\nLoRaMacCrypto::LoRaMacCrypto()\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n}\n\n// If mbedTLS is not configured properly, these dummies will ensure that\n// user knows what is wrong and in addition to that these ensure that\n// Mbed-OS compiles properly under normal conditions where LoRaWAN in conjunction\n// with mbedTLS is not being used.\nint LoRaMacCrypto::compute_mic(const uint8_t *, uint16_t , const uint8_t *, uint32_t, uint32_t,\n                               uint8_t dir, uint32_t, uint32_t *)\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint LoRaMacCrypto::encrypt_payload(const uint8_t *, uint16_t , const uint8_t *, uint32_t, uint32_t,\n                                   uint8_t , uint32_t , uint8_t *)\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint LoRaMacCrypto::decrypt_payload(const uint8_t *, uint16_t , const uint8_t *, uint32_t, uint32_t,\n                                   uint8_t , uint32_t , uint8_t *)\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint LoRaMacCrypto::compute_join_frame_mic(const uint8_t *, uint16_t , const uint8_t *, uint32_t, uint32_t *)\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint LoRaMacCrypto::decrypt_join_frame(const uint8_t *, uint16_t , const uint8_t *, uint32_t, uint8_t *)\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint LoRaMacCrypto::compute_skeys_for_join_frame(const uint8_t *, uint32_t, const uint8_t *, uint16_t ,\n                                                uint8_t *, uint8_t *)\n{\n    MBED_ASSERT(0 && \"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <stddef.h>\n#include \"hal/ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n#include \"mbed_assert.h\"\n\nstatic void schedule_interrupt(const ticker_data_t *const ticker);\nstatic void update_present_time(const ticker_data_t *const ticker);\n\n/*\n * Initialize a ticker instance.  \n */\nstatic void initialize(const ticker_data_t *ticker)\n{\n    // return if the queue has already been initialized, in that case the \n    // interface used by the queue is already initialized.\n    if (ticker->queue->initialized) { \n        return;\n    }\n\n    ticker->interface->init();\n\n    const ticker_info_t *info = ticker->interface->get_info();\n    uint32_t frequency = info->frequency;\n    if (info->frequency == 0) {\n        MBED_ASSERT(0);\n        frequency = 1000000;\n    }\n\n    uint8_t frequency_shifts = 0;\n    for (uint8_t i = 31; i > 0; --i) {\n        if ((1 << i) == frequency) {\n            frequency_shifts = i;\n            break;\n        }\n    }\n\n    uint32_t bits = info->bits;\n    if ((info->bits > 32) || (info->bits < 4)) {\n        MBED_ASSERT(0);\n        bits = 32;\n    }\n    uint32_t max_delta = 0x7 << (bits - 4); // 7/16th\n    uint64_t max_delta_us =\n            ((uint64_t)max_delta * 1000000 + frequency - 1) / frequency;\n\n    ticker->queue->event_handler = NULL;\n    ticker->queue->head = NULL;\n    ticker->queue->tick_last_read = ticker->interface->read();\n    ticker->queue->tick_remainder = 0;\n    ticker->queue->frequency = frequency;\n    ticker->queue->frequency_shifts = frequency_shifts;\n    ticker->queue->bitmask = ((uint64_t)1 << bits) - 1;\n    ticker->queue->max_delta = max_delta;\n    ticker->queue->max_delta_us = max_delta_us;\n    ticker->queue->present_time = 0;\n    ticker->queue->initialized = true;\n    \n    update_present_time(ticker);\n    schedule_interrupt(ticker);\n}\n\n/**\n * Set the event handler function of a ticker instance. \n */\nstatic void set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)\n{\n    ticker->queue->event_handler = handler;\n}\n\n/*\n * Convert a 32 bit timestamp into a 64 bit timestamp.\n *\n * A 64 bit timestamp is used as the point of time of reference while the \n * timestamp to convert is relative to this point of time. \n *\n * The lower 32 bits of the timestamp returned will be equal to the timestamp to \n * convert. \n * \n * If the timestamp to convert is less than the lower 32 bits of the time \n * reference then the timestamp to convert is seen as an overflowed value and \n * the upper 32 bit of the timestamp returned will be equal to the upper 32 bit \n * of the reference point + 1. \n * Otherwise, the upper 32 bit returned will be equal to the upper 32 bit of the \n * reference point. \n *\n * @param ref: The 64 bit timestamp of reference.\n * @param timestamp: The timestamp to convert.\n */\nstatic us_timestamp_t convert_timestamp(us_timestamp_t ref, timestamp_t timestamp)\n{\n    bool overflow = timestamp < ((timestamp_t) ref) ? true : false;\n\n    us_timestamp_t result = (ref & ~((us_timestamp_t)UINT32_MAX)) | timestamp;\n    if (overflow) { \n        result += (1ULL<<32);\n    }\n\n    return result;\n}\n\n/**\n * Update the present timestamp value of a ticker.\n */\nstatic void update_present_time(const ticker_data_t *const ticker)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    uint32_t ticker_time = ticker->interface->read();\n    if (ticker_time == ticker->queue->tick_last_read) {\n        // No work to do\n        return;\n    }\n\n    uint64_t elapsed_ticks = (ticker_time - queue->tick_last_read) & queue->bitmask;\n    queue->tick_last_read = ticker_time;\n\n    uint64_t elapsed_us;\n    if (1000000 == queue->frequency) {\n        // Optimized for 1MHz\n\n        elapsed_us = elapsed_ticks;\n    } else if (0 != queue->frequency_shifts) {\n        // Optimized for frequencies divisible by 2\n        uint64_t us_x_ticks = elapsed_ticks * 1000000;\n        elapsed_us = us_x_ticks >> queue->frequency_shifts;\n\n        // Update remainder\n        queue->tick_remainder += us_x_ticks - (elapsed_us << queue->frequency_shifts);\n        if (queue->tick_remainder >= queue->frequency) {\n            elapsed_us += 1;\n            queue->tick_remainder -= queue->frequency;\n        }\n    } else {\n        // General case\n\n        uint64_t us_x_ticks = elapsed_ticks * 1000000;\n        elapsed_us = us_x_ticks / queue->frequency;\n\n        // Update remainder\n        queue->tick_remainder += us_x_ticks - elapsed_us * queue->frequency;\n        if (queue->tick_remainder >= queue->frequency) {\n            elapsed_us += 1;\n            queue->tick_remainder -= queue->frequency;\n        }\n    }\n\n    // Update current time\n    queue->present_time += elapsed_us;\n}\n\n/**\n * Given the absolute timestamp compute the hal tick timestamp.\n */\nstatic timestamp_t compute_tick(const ticker_data_t *const ticker, us_timestamp_t timestamp)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    us_timestamp_t delta_us = timestamp - queue->present_time;\n\n    timestamp_t delta = ticker->queue->max_delta;\n    if (delta_us <=  ticker->queue->max_delta_us) {\n        // Checking max_delta_us ensures the operation will not overflow\n\n        if (1000000 == queue->frequency) {\n            // Optimized for 1MHz\n\n            delta = delta_us;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        } else if (0 != queue->frequency_shifts) {\n            // Optimized frequencies divisible by 2\n\n            delta = (delta_us << ticker->queue->frequency_shifts) / 1000000;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        } else {\n            // General case\n\n            delta = delta_us * queue->frequency / 1000000;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        }\n    }\n    return (queue->tick_last_read + delta) & queue->bitmask;\n}\n\n/**\n * Return 1 if the tick has incremented to or past match_tick, otherwise 0.\n */\nint _ticker_match_interval_passed(timestamp_t prev_tick, timestamp_t cur_tick, timestamp_t match_tick)\n{\n    if (match_tick > prev_tick) {\n        return (cur_tick >= match_tick) || (cur_tick < prev_tick);\n    } else {\n        return (cur_tick < prev_tick) && (cur_tick >= match_tick);\n    }\n}\n\n/**\n * Compute the time when the interrupt has to be triggered and schedule it.  \n * \n * If there is no event in the queue or the next event to execute is in more \n * than ticker.queue.max_delta ticks from now then the ticker irq will be\n * scheduled in ticker.queue.max_delta ticks. Otherwise the irq will be\n * scheduled to happen when the running counter reach the timestamp of the\n * first event in the queue.\n * \n * @note If there is no event in the queue then the interrupt is scheduled to \n * in ticker.queue.max_delta. This is necessary to keep track\n * of the timer overflow.\n */\nstatic void schedule_interrupt(const ticker_data_t *const ticker)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    update_present_time(ticker);\n\n    if (ticker->queue->head) {\n        us_timestamp_t present = ticker->queue->present_time;\n        us_timestamp_t match_time = ticker->queue->head->timestamp;\n\n        // if the event at the head of the queue is in the past then schedule\n        // it immediately.\n        if (match_time <= present) {\n            ticker->interface->fire_interrupt();\n            return;\n        }\n\n        timestamp_t match_tick = compute_tick(ticker, match_time);\n        // The time has been checked to be future, but it could still round\n        // to the last tick as a result of us to ticks conversion\n        if (match_tick == queue->tick_last_read) {\n            // Match time has already expired so fire immediately\n            ticker->interface->fire_interrupt();\n            return;\n        }\n\n        ticker->interface->set_interrupt(match_tick);\n        timestamp_t cur_tick = ticker->interface->read();\n\n        if (_ticker_match_interval_passed(queue->tick_last_read, cur_tick, match_tick)) {\n            ticker->interface->fire_interrupt();\n        }\n    } else {\n        uint32_t match_tick =\n                (queue->tick_last_read + queue->max_delta) & queue->bitmask;\n        ticker->interface->set_interrupt(match_tick);\n    }\n}\n\nvoid ticker_set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)\n{\n    initialize(ticker);\n\n    core_util_critical_section_enter();\n    set_handler(ticker, handler);\n    core_util_critical_section_exit();\n}\n\nvoid ticker_irq_handler(const ticker_data_t *const ticker)\n{\n    core_util_critical_section_enter();\n\n    ticker->interface->clear_interrupt();\n\n    /* Go through all the pending TimerEvents */\n    while (1) {\n        if (ticker->queue->head == NULL) {\n            break;\n        }\n\n        // update the current timestamp used by the queue \n        update_present_time(ticker);\n\n        if (ticker->queue->head->timestamp <= ticker->queue->present_time) { \n            // This event was in the past:\n            //      point to the following one and execute its handler\n            ticker_event_t *p = ticker->queue->head;\n            ticker->queue->head = ticker->queue->head->next;\n            if (ticker->queue->event_handler != NULL) {\n                (*ticker->queue->event_handler)(p->id); // NOTE: the handler can set new events\n            }\n            /* Note: We continue back to examining the head because calling the\n             * event handler may have altered the chain of pending events. */\n        } else {\n            break;\n        } \n    }\n\n    schedule_interrupt(ticker);\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_insert_event(const ticker_data_t *const ticker, ticker_event_t *obj, timestamp_t timestamp, uint32_t id)\n{\n    core_util_critical_section_enter();\n\n    // update the current timestamp\n    update_present_time(ticker);\n    us_timestamp_t absolute_timestamp = convert_timestamp(\n        ticker->queue->present_time, \n        timestamp\n    );\n\n    // defer to ticker_insert_event_us\n    ticker_insert_event_us(\n        ticker, \n        obj, absolute_timestamp, id\n    );\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_insert_event_us(const ticker_data_t *const ticker, ticker_event_t *obj, us_timestamp_t timestamp, uint32_t id)\n{\n    core_util_critical_section_enter();\n\n    // update the current timestamp\n    update_present_time(ticker);\n\n    // initialise our data\n    obj->timestamp = timestamp;\n    obj->id = id;\n\n    /* Go through the list until we either reach the end, or find\n       an element this should come before (which is possibly the\n       head). */\n    ticker_event_t *prev = NULL, *p = ticker->queue->head;\n    while (p != NULL) {\n        /* check if we come before p */\n        if (timestamp < p->timestamp) {\n            break;\n        }\n        /* go to the next element */\n        prev = p;\n        p = p->next;\n    }\n    \n    /* if we're at the end p will be NULL, which is correct */\n    obj->next = p;\n\n    /* if prev is NULL we're at the head */\n    if (prev == NULL) {\n        ticker->queue->head = obj;\n        schedule_interrupt(ticker);\n    } else {\n        prev->next = obj;\n    }\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_remove_event(const ticker_data_t *const ticker, ticker_event_t *obj)\n{\n    core_util_critical_section_enter();\n\n    // remove this object from the list\n    if (ticker->queue->head == obj) {\n        // first in the list, so just drop me\n        ticker->queue->head = obj->next;\n        schedule_interrupt(ticker);\n    } else {\n        // find the object before me, then drop me\n        ticker_event_t* p = ticker->queue->head;\n        while (p != NULL) {\n            if (p->next == obj) {\n                p->next = obj->next;\n                break;\n            }\n            p = p->next;\n        }\n    }\n\n    core_util_critical_section_exit();\n}\n\ntimestamp_t ticker_read(const ticker_data_t *const ticker)\n{\n    return ticker_read_us(ticker);\n}\n\nus_timestamp_t ticker_read_us(const ticker_data_t *const ticker)\n{\n    initialize(ticker);\n\n    core_util_critical_section_enter();\n    update_present_time(ticker);\n    core_util_critical_section_exit();\n\n    return ticker->queue->present_time;\n}\n\nint ticker_get_next_timestamp(const ticker_data_t *const data, timestamp_t *timestamp)\n{\n    int ret = 0;\n\n    /* if head is NULL, there are no pending events */\n    core_util_critical_section_enter();\n    if (data->queue->head != NULL) {\n        *timestamp = data->queue->head->timestamp;\n        ret = 1;\n    }\n    core_util_critical_section_exit();\n\n    return ret;\n}\n","/**\n * \\file cipher_wrap.c\n *\n * \\brief Generic cipher wrapper for mbed TLS\n *\n * \\author Adriaan de Jong <dejong@fox-it.com>\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CIPHER_C)\n\n#include \"mbedtls/cipher_internal.h\"\n\n#if defined(MBEDTLS_AES_C)\n#include \"mbedtls/aes.h\"\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n#include \"mbedtls/arc4.h\"\n#endif\n\n#if defined(MBEDTLS_CAMELLIA_C)\n#include \"mbedtls/camellia.h\"\n#endif\n\n#if defined(MBEDTLS_ARIA_C)\n#include \"mbedtls/aria.h\"\n#endif\n\n#if defined(MBEDTLS_DES_C)\n#include \"mbedtls/des.h\"\n#endif\n\n#if defined(MBEDTLS_BLOWFISH_C)\n#include \"mbedtls/blowfish.h\"\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n#include \"mbedtls/gcm.h\"\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n#include \"mbedtls/ccm.h\"\n#endif\n\n#if defined(MBEDTLS_CIPHER_NULL_CIPHER)\n#include <string.h>\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc    calloc\n#define mbedtls_free       free\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n/* shared by all GCM ciphers */\nstatic void *gcm_ctx_alloc( void )\n{\n    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_gcm_context ) );\n\n    if( ctx != NULL )\n        mbedtls_gcm_init( (mbedtls_gcm_context *) ctx );\n\n    return( ctx );\n}\n\nstatic void gcm_ctx_free( void *ctx )\n{\n    mbedtls_gcm_free( ctx );\n    mbedtls_free( ctx );\n}\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\n/* shared by all CCM ciphers */\nstatic void *ccm_ctx_alloc( void )\n{\n    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ccm_context ) );\n\n    if( ctx != NULL )\n        mbedtls_ccm_init( (mbedtls_ccm_context *) ctx );\n\n    return( ctx );\n}\n\nstatic void ccm_ctx_free( void *ctx )\n{\n    mbedtls_ccm_free( ctx );\n    mbedtls_free( ctx );\n}\n#endif /* MBEDTLS_CCM_C */\n\n#if defined(MBEDTLS_AES_C)\n\nstatic int aes_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_ecb( (mbedtls_aes_context *) ctx, operation, input, output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int aes_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,\n        unsigned char *iv, const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_cbc( (mbedtls_aes_context *) ctx, operation, length, iv, input,\n                          output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int aes_crypt_cfb128_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_cfb128( (mbedtls_aes_context *) ctx, operation, length, iv_off, iv,\n                             input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int aes_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_ctr( (mbedtls_aes_context *) ctx, length, nc_off, nonce_counter,\n                          stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int aes_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_aes_setkey_dec( (mbedtls_aes_context *) ctx, key, key_bitlen );\n}\n\nstatic int aes_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_aes_setkey_enc( (mbedtls_aes_context *) ctx, key, key_bitlen );\n}\n\nstatic void * aes_ctx_alloc( void )\n{\n    mbedtls_aes_context *aes = mbedtls_calloc( 1, sizeof( mbedtls_aes_context ) );\n\n    if( aes == NULL )\n        return( NULL );\n\n    mbedtls_aes_init( aes );\n\n    return( aes );\n}\n\nstatic void aes_ctx_free( void *ctx )\n{\n    mbedtls_aes_free( (mbedtls_aes_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t aes_info = {\n    MBEDTLS_CIPHER_ID_AES,\n    aes_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    aes_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    aes_crypt_cfb128_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    aes_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    aes_setkey_enc_wrap,\n    aes_setkey_dec_wrap,\n    aes_ctx_alloc,\n    aes_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t aes_128_ecb_info = {\n    MBEDTLS_CIPHER_AES_128_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"AES-128-ECB\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_ecb_info = {\n    MBEDTLS_CIPHER_AES_192_ECB,\n    MBEDTLS_MODE_ECB,\n    192,\n    \"AES-192-ECB\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_ecb_info = {\n    MBEDTLS_CIPHER_AES_256_ECB,\n    MBEDTLS_MODE_ECB,\n    256,\n    \"AES-256-ECB\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t aes_128_cbc_info = {\n    MBEDTLS_CIPHER_AES_128_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"AES-128-CBC\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_cbc_info = {\n    MBEDTLS_CIPHER_AES_192_CBC,\n    MBEDTLS_MODE_CBC,\n    192,\n    \"AES-192-CBC\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_cbc_info = {\n    MBEDTLS_CIPHER_AES_256_CBC,\n    MBEDTLS_MODE_CBC,\n    256,\n    \"AES-256-CBC\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t aes_128_cfb128_info = {\n    MBEDTLS_CIPHER_AES_128_CFB128,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"AES-128-CFB128\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_cfb128_info = {\n    MBEDTLS_CIPHER_AES_192_CFB128,\n    MBEDTLS_MODE_CFB,\n    192,\n    \"AES-192-CFB128\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_cfb128_info = {\n    MBEDTLS_CIPHER_AES_256_CFB128,\n    MBEDTLS_MODE_CFB,\n    256,\n    \"AES-256-CFB128\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t aes_128_ctr_info = {\n    MBEDTLS_CIPHER_AES_128_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"AES-128-CTR\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_ctr_info = {\n    MBEDTLS_CIPHER_AES_192_CTR,\n    MBEDTLS_MODE_CTR,\n    192,\n    \"AES-192-CTR\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_ctr_info = {\n    MBEDTLS_CIPHER_AES_256_CTR,\n    MBEDTLS_MODE_CTR,\n    256,\n    \"AES-256-CTR\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_GCM_C)\nstatic int gcm_aes_setkey_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_AES,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t gcm_aes_info = {\n    MBEDTLS_CIPHER_ID_AES,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    gcm_aes_setkey_wrap,\n    gcm_aes_setkey_wrap,\n    gcm_ctx_alloc,\n    gcm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t aes_128_gcm_info = {\n    MBEDTLS_CIPHER_AES_128_GCM,\n    MBEDTLS_MODE_GCM,\n    128,\n    \"AES-128-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_gcm_info = {\n    MBEDTLS_CIPHER_AES_192_GCM,\n    MBEDTLS_MODE_GCM,\n    192,\n    \"AES-192-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_gcm_info = {\n    MBEDTLS_CIPHER_AES_256_GCM,\n    MBEDTLS_MODE_GCM,\n    256,\n    \"AES-256-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aes_info\n};\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\nstatic int ccm_aes_setkey_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_AES,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t ccm_aes_info = {\n    MBEDTLS_CIPHER_ID_AES,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    ccm_aes_setkey_wrap,\n    ccm_aes_setkey_wrap,\n    ccm_ctx_alloc,\n    ccm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t aes_128_ccm_info = {\n    MBEDTLS_CIPHER_AES_128_CCM,\n    MBEDTLS_MODE_CCM,\n    128,\n    \"AES-128-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_ccm_info = {\n    MBEDTLS_CIPHER_AES_192_CCM,\n    MBEDTLS_MODE_CCM,\n    192,\n    \"AES-192-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_ccm_info = {\n    MBEDTLS_CIPHER_AES_256_CCM,\n    MBEDTLS_MODE_CCM,\n    256,\n    \"AES-256-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aes_info\n};\n#endif /* MBEDTLS_CCM_C */\n\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n\nstatic int camellia_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_ecb( (mbedtls_camellia_context *) ctx, operation, input,\n                               output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int camellia_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_cbc( (mbedtls_camellia_context *) ctx, operation, length, iv,\n                               input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int camellia_crypt_cfb128_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_cfb128( (mbedtls_camellia_context *) ctx, operation, length,\n                                  iv_off, iv, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int camellia_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_ctr( (mbedtls_camellia_context *) ctx, length, nc_off,\n                               nonce_counter, stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int camellia_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_camellia_setkey_dec( (mbedtls_camellia_context *) ctx, key, key_bitlen );\n}\n\nstatic int camellia_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_camellia_setkey_enc( (mbedtls_camellia_context *) ctx, key, key_bitlen );\n}\n\nstatic void * camellia_ctx_alloc( void )\n{\n    mbedtls_camellia_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_camellia_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_camellia_init( ctx );\n\n    return( ctx );\n}\n\nstatic void camellia_ctx_free( void *ctx )\n{\n    mbedtls_camellia_free( (mbedtls_camellia_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t camellia_info = {\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    camellia_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    camellia_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    camellia_crypt_cfb128_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    camellia_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    camellia_setkey_enc_wrap,\n    camellia_setkey_dec_wrap,\n    camellia_ctx_alloc,\n    camellia_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t camellia_128_ecb_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"CAMELLIA-128-ECB\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_ecb_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_ECB,\n    MBEDTLS_MODE_ECB,\n    192,\n    \"CAMELLIA-192-ECB\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_ecb_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_ECB,\n    MBEDTLS_MODE_ECB,\n    256,\n    \"CAMELLIA-256-ECB\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t camellia_128_cbc_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"CAMELLIA-128-CBC\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_cbc_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CBC,\n    MBEDTLS_MODE_CBC,\n    192,\n    \"CAMELLIA-192-CBC\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_cbc_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CBC,\n    MBEDTLS_MODE_CBC,\n    256,\n    \"CAMELLIA-256-CBC\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t camellia_128_cfb128_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CFB128,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"CAMELLIA-128-CFB128\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_cfb128_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CFB128,\n    MBEDTLS_MODE_CFB,\n    192,\n    \"CAMELLIA-192-CFB128\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_cfb128_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CFB128,\n    MBEDTLS_MODE_CFB,\n    256,\n    \"CAMELLIA-256-CFB128\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t camellia_128_ctr_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"CAMELLIA-128-CTR\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_ctr_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CTR,\n    MBEDTLS_MODE_CTR,\n    192,\n    \"CAMELLIA-192-CTR\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_ctr_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CTR,\n    MBEDTLS_MODE_CTR,\n    256,\n    \"CAMELLIA-256-CTR\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_GCM_C)\nstatic int gcm_camellia_setkey_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_CAMELLIA,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t gcm_camellia_info = {\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    gcm_camellia_setkey_wrap,\n    gcm_camellia_setkey_wrap,\n    gcm_ctx_alloc,\n    gcm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t camellia_128_gcm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_GCM,\n    MBEDTLS_MODE_GCM,\n    128,\n    \"CAMELLIA-128-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_gcm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_GCM,\n    MBEDTLS_MODE_GCM,\n    192,\n    \"CAMELLIA-192-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_gcm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_GCM,\n    MBEDTLS_MODE_GCM,\n    256,\n    \"CAMELLIA-256-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_camellia_info\n};\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\nstatic int ccm_camellia_setkey_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_CAMELLIA,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t ccm_camellia_info = {\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    ccm_camellia_setkey_wrap,\n    ccm_camellia_setkey_wrap,\n    ccm_ctx_alloc,\n    ccm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t camellia_128_ccm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CCM,\n    MBEDTLS_MODE_CCM,\n    128,\n    \"CAMELLIA-128-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_ccm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CCM,\n    MBEDTLS_MODE_CCM,\n    192,\n    \"CAMELLIA-192-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_ccm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CCM,\n    MBEDTLS_MODE_CCM,\n    256,\n    \"CAMELLIA-256-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_camellia_info\n};\n#endif /* MBEDTLS_CCM_C */\n\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_ARIA_C)\n\nstatic int aria_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    (void) operation;\n    return mbedtls_aria_crypt_ecb( (mbedtls_aria_context *) ctx, input,\n                               output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int aria_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aria_crypt_cbc( (mbedtls_aria_context *) ctx, operation, length, iv,\n                               input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int aria_crypt_cfb128_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aria_crypt_cfb128( (mbedtls_aria_context *) ctx, operation, length,\n                                  iv_off, iv, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int aria_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aria_crypt_ctr( (mbedtls_aria_context *) ctx, length, nc_off,\n                               nonce_counter, stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int aria_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_aria_setkey_dec( (mbedtls_aria_context *) ctx, key, key_bitlen );\n}\n\nstatic int aria_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_aria_setkey_enc( (mbedtls_aria_context *) ctx, key, key_bitlen );\n}\n\nstatic void * aria_ctx_alloc( void )\n{\n    mbedtls_aria_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_aria_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_aria_init( ctx );\n\n    return( ctx );\n}\n\nstatic void aria_ctx_free( void *ctx )\n{\n    mbedtls_aria_free( (mbedtls_aria_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t aria_info = {\n    MBEDTLS_CIPHER_ID_ARIA,\n    aria_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    aria_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    aria_crypt_cfb128_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    aria_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    aria_setkey_enc_wrap,\n    aria_setkey_dec_wrap,\n    aria_ctx_alloc,\n    aria_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t aria_128_ecb_info = {\n    MBEDTLS_CIPHER_ARIA_128_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"ARIA-128-ECB\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_192_ecb_info = {\n    MBEDTLS_CIPHER_ARIA_192_ECB,\n    MBEDTLS_MODE_ECB,\n    192,\n    \"ARIA-192-ECB\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_256_ecb_info = {\n    MBEDTLS_CIPHER_ARIA_256_ECB,\n    MBEDTLS_MODE_ECB,\n    256,\n    \"ARIA-256-ECB\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t aria_128_cbc_info = {\n    MBEDTLS_CIPHER_ARIA_128_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"ARIA-128-CBC\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_192_cbc_info = {\n    MBEDTLS_CIPHER_ARIA_192_CBC,\n    MBEDTLS_MODE_CBC,\n    192,\n    \"ARIA-192-CBC\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_256_cbc_info = {\n    MBEDTLS_CIPHER_ARIA_256_CBC,\n    MBEDTLS_MODE_CBC,\n    256,\n    \"ARIA-256-CBC\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t aria_128_cfb128_info = {\n    MBEDTLS_CIPHER_ARIA_128_CFB128,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"ARIA-128-CFB128\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_192_cfb128_info = {\n    MBEDTLS_CIPHER_ARIA_192_CFB128,\n    MBEDTLS_MODE_CFB,\n    192,\n    \"ARIA-192-CFB128\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_256_cfb128_info = {\n    MBEDTLS_CIPHER_ARIA_256_CFB128,\n    MBEDTLS_MODE_CFB,\n    256,\n    \"ARIA-256-CFB128\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t aria_128_ctr_info = {\n    MBEDTLS_CIPHER_ARIA_128_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"ARIA-128-CTR\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_192_ctr_info = {\n    MBEDTLS_CIPHER_ARIA_192_CTR,\n    MBEDTLS_MODE_CTR,\n    192,\n    \"ARIA-192-CTR\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_256_ctr_info = {\n    MBEDTLS_CIPHER_ARIA_256_CTR,\n    MBEDTLS_MODE_CTR,\n    256,\n    \"ARIA-256-CTR\",\n    16,\n    0,\n    16,\n    &aria_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_GCM_C)\nstatic int gcm_aria_setkey_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_ARIA,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t gcm_aria_info = {\n    MBEDTLS_CIPHER_ID_ARIA,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    gcm_aria_setkey_wrap,\n    gcm_aria_setkey_wrap,\n    gcm_ctx_alloc,\n    gcm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t aria_128_gcm_info = {\n    MBEDTLS_CIPHER_ARIA_128_GCM,\n    MBEDTLS_MODE_GCM,\n    128,\n    \"ARIA-128-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_192_gcm_info = {\n    MBEDTLS_CIPHER_ARIA_192_GCM,\n    MBEDTLS_MODE_GCM,\n    192,\n    \"ARIA-192-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_256_gcm_info = {\n    MBEDTLS_CIPHER_ARIA_256_GCM,\n    MBEDTLS_MODE_GCM,\n    256,\n    \"ARIA-256-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aria_info\n};\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\nstatic int ccm_aria_setkey_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_ARIA,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t ccm_aria_info = {\n    MBEDTLS_CIPHER_ID_ARIA,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    ccm_aria_setkey_wrap,\n    ccm_aria_setkey_wrap,\n    ccm_ctx_alloc,\n    ccm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t aria_128_ccm_info = {\n    MBEDTLS_CIPHER_ARIA_128_CCM,\n    MBEDTLS_MODE_CCM,\n    128,\n    \"ARIA-128-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_192_ccm_info = {\n    MBEDTLS_CIPHER_ARIA_192_CCM,\n    MBEDTLS_MODE_CCM,\n    192,\n    \"ARIA-192-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aria_info\n};\n\nstatic const mbedtls_cipher_info_t aria_256_ccm_info = {\n    MBEDTLS_CIPHER_ARIA_256_CCM,\n    MBEDTLS_MODE_CCM,\n    256,\n    \"ARIA-256-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aria_info\n};\n#endif /* MBEDTLS_CCM_C */\n\n#endif /* MBEDTLS_ARIA_C */\n\n#if defined(MBEDTLS_DES_C)\n\nstatic int des_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    ((void) operation);\n    return mbedtls_des_crypt_ecb( (mbedtls_des_context *) ctx, input, output );\n}\n\nstatic int des3_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    ((void) operation);\n    return mbedtls_des3_crypt_ecb( (mbedtls_des3_context *) ctx, input, output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int des_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,\n        unsigned char *iv, const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_des_crypt_cbc( (mbedtls_des_context *) ctx, operation, length, iv, input,\n                          output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int des3_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,\n        unsigned char *iv, const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_des3_crypt_cbc( (mbedtls_des3_context *) ctx, operation, length, iv, input,\n                           output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\nstatic int des_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des_setkey_dec( (mbedtls_des_context *) ctx, key );\n}\n\nstatic int des_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des_setkey_enc( (mbedtls_des_context *) ctx, key );\n}\n\nstatic int des3_set2key_dec_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set2key_dec( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic int des3_set2key_enc_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set2key_enc( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic int des3_set3key_dec_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set3key_dec( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic int des3_set3key_enc_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set3key_enc( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic void * des_ctx_alloc( void )\n{\n    mbedtls_des_context *des = mbedtls_calloc( 1, sizeof( mbedtls_des_context ) );\n\n    if( des == NULL )\n        return( NULL );\n\n    mbedtls_des_init( des );\n\n    return( des );\n}\n\nstatic void des_ctx_free( void *ctx )\n{\n    mbedtls_des_free( (mbedtls_des_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic void * des3_ctx_alloc( void )\n{\n    mbedtls_des3_context *des3;\n    des3 = mbedtls_calloc( 1, sizeof( mbedtls_des3_context ) );\n\n    if( des3 == NULL )\n        return( NULL );\n\n    mbedtls_des3_init( des3 );\n\n    return( des3 );\n}\n\nstatic void des3_ctx_free( void *ctx )\n{\n    mbedtls_des3_free( (mbedtls_des3_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t des_info = {\n    MBEDTLS_CIPHER_ID_DES,\n    des_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    des_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    des_setkey_enc_wrap,\n    des_setkey_dec_wrap,\n    des_ctx_alloc,\n    des_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t des_ecb_info = {\n    MBEDTLS_CIPHER_DES_ECB,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_KEY_LENGTH_DES,\n    \"DES-ECB\",\n    8,\n    0,\n    8,\n    &des_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t des_cbc_info = {\n    MBEDTLS_CIPHER_DES_CBC,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_KEY_LENGTH_DES,\n    \"DES-CBC\",\n    8,\n    0,\n    8,\n    &des_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\nstatic const mbedtls_cipher_base_t des_ede_info = {\n    MBEDTLS_CIPHER_ID_DES,\n    des3_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    des3_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    des3_set2key_enc_wrap,\n    des3_set2key_dec_wrap,\n    des3_ctx_alloc,\n    des3_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t des_ede_ecb_info = {\n    MBEDTLS_CIPHER_DES_EDE_ECB,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_KEY_LENGTH_DES_EDE,\n    \"DES-EDE-ECB\",\n    8,\n    0,\n    8,\n    &des_ede_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t des_ede_cbc_info = {\n    MBEDTLS_CIPHER_DES_EDE_CBC,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_KEY_LENGTH_DES_EDE,\n    \"DES-EDE-CBC\",\n    8,\n    0,\n    8,\n    &des_ede_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\nstatic const mbedtls_cipher_base_t des_ede3_info = {\n    MBEDTLS_CIPHER_ID_3DES,\n    des3_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    des3_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    des3_set3key_enc_wrap,\n    des3_set3key_dec_wrap,\n    des3_ctx_alloc,\n    des3_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t des_ede3_ecb_info = {\n    MBEDTLS_CIPHER_DES_EDE3_ECB,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_KEY_LENGTH_DES_EDE3,\n    \"DES-EDE3-ECB\",\n    8,\n    0,\n    8,\n    &des_ede3_info\n};\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t des_ede3_cbc_info = {\n    MBEDTLS_CIPHER_DES_EDE3_CBC,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_KEY_LENGTH_DES_EDE3,\n    \"DES-EDE3-CBC\",\n    8,\n    0,\n    8,\n    &des_ede3_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_BLOWFISH_C)\n\nstatic int blowfish_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_ecb( (mbedtls_blowfish_context *) ctx, operation, input,\n                               output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int blowfish_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, unsigned char *iv, const unsigned char *input,\n        unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_cbc( (mbedtls_blowfish_context *) ctx, operation, length, iv,\n                               input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int blowfish_crypt_cfb64_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_cfb64( (mbedtls_blowfish_context *) ctx, operation, length,\n                                 iv_off, iv, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int blowfish_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_ctr( (mbedtls_blowfish_context *) ctx, length, nc_off,\n                               nonce_counter, stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int blowfish_setkey_wrap( void *ctx, const unsigned char *key,\n                                 unsigned int key_bitlen )\n{\n    return mbedtls_blowfish_setkey( (mbedtls_blowfish_context *) ctx, key, key_bitlen );\n}\n\nstatic void * blowfish_ctx_alloc( void )\n{\n    mbedtls_blowfish_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_blowfish_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_blowfish_init( ctx );\n\n    return( ctx );\n}\n\nstatic void blowfish_ctx_free( void *ctx )\n{\n    mbedtls_blowfish_free( (mbedtls_blowfish_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t blowfish_info = {\n    MBEDTLS_CIPHER_ID_BLOWFISH,\n    blowfish_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    blowfish_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    blowfish_crypt_cfb64_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    blowfish_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    blowfish_setkey_wrap,\n    blowfish_setkey_wrap,\n    blowfish_ctx_alloc,\n    blowfish_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t blowfish_ecb_info = {\n    MBEDTLS_CIPHER_BLOWFISH_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"BLOWFISH-ECB\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t blowfish_cbc_info = {\n    MBEDTLS_CIPHER_BLOWFISH_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"BLOWFISH-CBC\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t blowfish_cfb64_info = {\n    MBEDTLS_CIPHER_BLOWFISH_CFB64,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"BLOWFISH-CFB64\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t blowfish_ctr_info = {\n    MBEDTLS_CIPHER_BLOWFISH_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"BLOWFISH-CTR\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_ARC4_C)\nstatic int arc4_crypt_stream_wrap( void *ctx, size_t length,\n                                   const unsigned char *input,\n                                   unsigned char *output )\n{\n    return( mbedtls_arc4_crypt( (mbedtls_arc4_context *) ctx, length, input, output ) );\n}\n\nstatic int arc4_setkey_wrap( void *ctx, const unsigned char *key,\n                             unsigned int key_bitlen )\n{\n    /* we get key_bitlen in bits, arc4 expects it in bytes */\n    if( key_bitlen % 8 != 0 )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    mbedtls_arc4_setup( (mbedtls_arc4_context *) ctx, key, key_bitlen / 8 );\n    return( 0 );\n}\n\nstatic void * arc4_ctx_alloc( void )\n{\n    mbedtls_arc4_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_arc4_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_arc4_init( ctx );\n\n    return( ctx );\n}\n\nstatic void arc4_ctx_free( void *ctx )\n{\n    mbedtls_arc4_free( (mbedtls_arc4_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t arc4_base_info = {\n    MBEDTLS_CIPHER_ID_ARC4,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    arc4_crypt_stream_wrap,\n#endif\n    arc4_setkey_wrap,\n    arc4_setkey_wrap,\n    arc4_ctx_alloc,\n    arc4_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t arc4_128_info = {\n    MBEDTLS_CIPHER_ARC4_128,\n    MBEDTLS_MODE_STREAM,\n    128,\n    \"ARC4-128\",\n    0,\n    0,\n    1,\n    &arc4_base_info\n};\n#endif /* MBEDTLS_ARC4_C */\n\n#if defined(MBEDTLS_CIPHER_NULL_CIPHER)\nstatic int null_crypt_stream( void *ctx, size_t length,\n                              const unsigned char *input,\n                              unsigned char *output )\n{\n    ((void) ctx);\n    memmove( output, input, length );\n    return( 0 );\n}\n\nstatic int null_setkey( void *ctx, const unsigned char *key,\n                        unsigned int key_bitlen )\n{\n    ((void) ctx);\n    ((void) key);\n    ((void) key_bitlen);\n\n    return( 0 );\n}\n\nstatic void * null_ctx_alloc( void )\n{\n    return( (void *) 1 );\n}\n\nstatic void null_ctx_free( void *ctx )\n{\n    ((void) ctx);\n}\n\nstatic const mbedtls_cipher_base_t null_base_info = {\n    MBEDTLS_CIPHER_ID_NULL,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    null_crypt_stream,\n#endif\n    null_setkey,\n    null_setkey,\n    null_ctx_alloc,\n    null_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t null_cipher_info = {\n    MBEDTLS_CIPHER_NULL,\n    MBEDTLS_MODE_STREAM,\n    0,\n    \"NULL\",\n    0,\n    0,\n    1,\n    &null_base_info\n};\n#endif /* defined(MBEDTLS_CIPHER_NULL_CIPHER) */\n\nconst mbedtls_cipher_definition_t mbedtls_cipher_definitions[] =\n{\n#if defined(MBEDTLS_AES_C)\n    { MBEDTLS_CIPHER_AES_128_ECB,          &aes_128_ecb_info },\n    { MBEDTLS_CIPHER_AES_192_ECB,          &aes_192_ecb_info },\n    { MBEDTLS_CIPHER_AES_256_ECB,          &aes_256_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_AES_128_CBC,          &aes_128_cbc_info },\n    { MBEDTLS_CIPHER_AES_192_CBC,          &aes_192_cbc_info },\n    { MBEDTLS_CIPHER_AES_256_CBC,          &aes_256_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_AES_128_CFB128,       &aes_128_cfb128_info },\n    { MBEDTLS_CIPHER_AES_192_CFB128,       &aes_192_cfb128_info },\n    { MBEDTLS_CIPHER_AES_256_CFB128,       &aes_256_cfb128_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_AES_128_CTR,          &aes_128_ctr_info },\n    { MBEDTLS_CIPHER_AES_192_CTR,          &aes_192_ctr_info },\n    { MBEDTLS_CIPHER_AES_256_CTR,          &aes_256_ctr_info },\n#endif\n#if defined(MBEDTLS_GCM_C)\n    { MBEDTLS_CIPHER_AES_128_GCM,          &aes_128_gcm_info },\n    { MBEDTLS_CIPHER_AES_192_GCM,          &aes_192_gcm_info },\n    { MBEDTLS_CIPHER_AES_256_GCM,          &aes_256_gcm_info },\n#endif\n#if defined(MBEDTLS_CCM_C)\n    { MBEDTLS_CIPHER_AES_128_CCM,          &aes_128_ccm_info },\n    { MBEDTLS_CIPHER_AES_192_CCM,          &aes_192_ccm_info },\n    { MBEDTLS_CIPHER_AES_256_CCM,          &aes_256_ccm_info },\n#endif\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_ARC4_C)\n    { MBEDTLS_CIPHER_ARC4_128,             &arc4_128_info },\n#endif\n\n#if defined(MBEDTLS_BLOWFISH_C)\n    { MBEDTLS_CIPHER_BLOWFISH_ECB,         &blowfish_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_BLOWFISH_CBC,         &blowfish_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_BLOWFISH_CFB64,       &blowfish_cfb64_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_BLOWFISH_CTR,         &blowfish_ctr_info },\n#endif\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n    { MBEDTLS_CIPHER_CAMELLIA_128_ECB,     &camellia_128_ecb_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_ECB,     &camellia_192_ecb_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_ECB,     &camellia_256_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CBC,     &camellia_128_cbc_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CBC,     &camellia_192_cbc_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CBC,     &camellia_256_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CFB128,  &camellia_128_cfb128_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CFB128,  &camellia_192_cfb128_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CFB128,  &camellia_256_cfb128_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CTR,     &camellia_128_ctr_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CTR,     &camellia_192_ctr_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CTR,     &camellia_256_ctr_info },\n#endif\n#if defined(MBEDTLS_GCM_C)\n    { MBEDTLS_CIPHER_CAMELLIA_128_GCM,     &camellia_128_gcm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_GCM,     &camellia_192_gcm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_GCM,     &camellia_256_gcm_info },\n#endif\n#if defined(MBEDTLS_CCM_C)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CCM,     &camellia_128_ccm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CCM,     &camellia_192_ccm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CCM,     &camellia_256_ccm_info },\n#endif\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_ARIA_C)\n    { MBEDTLS_CIPHER_ARIA_128_ECB,     &aria_128_ecb_info },\n    { MBEDTLS_CIPHER_ARIA_192_ECB,     &aria_192_ecb_info },\n    { MBEDTLS_CIPHER_ARIA_256_ECB,     &aria_256_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_ARIA_128_CBC,     &aria_128_cbc_info },\n    { MBEDTLS_CIPHER_ARIA_192_CBC,     &aria_192_cbc_info },\n    { MBEDTLS_CIPHER_ARIA_256_CBC,     &aria_256_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_ARIA_128_CFB128,  &aria_128_cfb128_info },\n    { MBEDTLS_CIPHER_ARIA_192_CFB128,  &aria_192_cfb128_info },\n    { MBEDTLS_CIPHER_ARIA_256_CFB128,  &aria_256_cfb128_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_ARIA_128_CTR,     &aria_128_ctr_info },\n    { MBEDTLS_CIPHER_ARIA_192_CTR,     &aria_192_ctr_info },\n    { MBEDTLS_CIPHER_ARIA_256_CTR,     &aria_256_ctr_info },\n#endif\n#if defined(MBEDTLS_GCM_C)\n    { MBEDTLS_CIPHER_ARIA_128_GCM,     &aria_128_gcm_info },\n    { MBEDTLS_CIPHER_ARIA_192_GCM,     &aria_192_gcm_info },\n    { MBEDTLS_CIPHER_ARIA_256_GCM,     &aria_256_gcm_info },\n#endif\n#if defined(MBEDTLS_CCM_C)\n    { MBEDTLS_CIPHER_ARIA_128_CCM,     &aria_128_ccm_info },\n    { MBEDTLS_CIPHER_ARIA_192_CCM,     &aria_192_ccm_info },\n    { MBEDTLS_CIPHER_ARIA_256_CCM,     &aria_256_ccm_info },\n#endif\n#endif /* MBEDTLS_ARIA_C */\n\n#if defined(MBEDTLS_DES_C)\n    { MBEDTLS_CIPHER_DES_ECB,              &des_ecb_info },\n    { MBEDTLS_CIPHER_DES_EDE_ECB,          &des_ede_ecb_info },\n    { MBEDTLS_CIPHER_DES_EDE3_ECB,         &des_ede3_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_DES_CBC,              &des_cbc_info },\n    { MBEDTLS_CIPHER_DES_EDE_CBC,          &des_ede_cbc_info },\n    { MBEDTLS_CIPHER_DES_EDE3_CBC,         &des_ede3_cbc_info },\n#endif\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_CIPHER_NULL_CIPHER)\n    { MBEDTLS_CIPHER_NULL,                 &null_cipher_info },\n#endif /* MBEDTLS_CIPHER_NULL_CIPHER */\n\n    { MBEDTLS_CIPHER_NONE, NULL }\n};\n\n#define NUM_CIPHERS sizeof mbedtls_cipher_definitions / sizeof mbedtls_cipher_definitions[0]\nint mbedtls_cipher_supported[NUM_CIPHERS];\n\n#endif /* MBEDTLS_CIPHER_C */\n","/*\n *  NIST SP800-38D compliant GCM implementation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n/*\n * http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf\n *\n * See also:\n * [MGV] http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-revised-spec.pdf\n *\n * We use the algorithm described as Shoup's method with 4-bit tables in\n * [MGV] 4.1, pp. 12-13, to enhance speed without using too much memory.\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n\n#include \"mbedtls/gcm.h\"\n#include \"mbedtls/platform_util.h\"\n\n#include <string.h>\n\n#if defined(MBEDTLS_AESNI_C)\n#include \"mbedtls/aesni.h\"\n#endif\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n#include \"mbedtls/aes.h\"\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdio.h>\n#define mbedtls_printf printf\n#endif /* MBEDTLS_PLATFORM_C */\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#if !defined(MBEDTLS_GCM_ALT)\n\n/*\n * 32-bit integer manipulation macros (big endian)\n */\n#ifndef GET_UINT32_BE\n#define GET_UINT32_BE(n,b,i)                            \\\n{                                                       \\\n    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \\\n        | ( (uint32_t) (b)[(i) + 1] << 16 )             \\\n        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \\\n        | ( (uint32_t) (b)[(i) + 3]       );            \\\n}\n#endif\n\n#ifndef PUT_UINT32_BE\n#define PUT_UINT32_BE(n,b,i)                            \\\n{                                                       \\\n    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \\\n    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \\\n    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \\\n    (b)[(i) + 3] = (unsigned char) ( (n)       );       \\\n}\n#endif\n\n/*\n * Initialize a context\n */\nvoid mbedtls_gcm_init( mbedtls_gcm_context *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );\n}\n\n/*\n * Precompute small multiples of H, that is set\n *      HH[i] || HL[i] = H times i,\n * where i is seen as a field element as in [MGV], ie high-order bits\n * correspond to low powers of P. The result is stored in the same way, that\n * is the high-order bit of HH corresponds to P^0 and the low-order bit of HL\n * corresponds to P^127.\n */\nstatic int gcm_gen_table( mbedtls_gcm_context *ctx )\n{\n    int ret, i, j;\n    uint64_t hi, lo;\n    uint64_t vl, vh;\n    unsigned char h[16];\n    size_t olen = 0;\n\n    memset( h, 0, 16 );\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, h, 16, h, &olen ) ) != 0 )\n        return( ret );\n\n    /* pack h as two 64-bits ints, big-endian */\n    GET_UINT32_BE( hi, h,  0  );\n    GET_UINT32_BE( lo, h,  4  );\n    vh = (uint64_t) hi << 32 | lo;\n\n    GET_UINT32_BE( hi, h,  8  );\n    GET_UINT32_BE( lo, h,  12 );\n    vl = (uint64_t) hi << 32 | lo;\n\n    /* 8 = 1000 corresponds to 1 in GF(2^128) */\n    ctx->HL[8] = vl;\n    ctx->HH[8] = vh;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    /* With CLMUL support, we need only h, not the rest of the table */\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_CLMUL ) )\n        return( 0 );\n#endif\n\n    /* 0 corresponds to 0 in GF(2^128) */\n    ctx->HH[0] = 0;\n    ctx->HL[0] = 0;\n\n    for( i = 4; i > 0; i >>= 1 )\n    {\n        uint32_t T = ( vl & 1 ) * 0xe1000000U;\n        vl  = ( vh << 63 ) | ( vl >> 1 );\n        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);\n\n        ctx->HL[i] = vl;\n        ctx->HH[i] = vh;\n    }\n\n    for( i = 2; i <= 8; i *= 2 )\n    {\n        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;\n        vh = *HiH;\n        vl = *HiL;\n        for( j = 1; j < i; j++ )\n        {\n            HiH[j] = vh ^ ctx->HH[j];\n            HiL[j] = vl ^ ctx->HL[j];\n        }\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_setkey( mbedtls_gcm_context *ctx,\n                        mbedtls_cipher_id_t cipher,\n                        const unsigned char *key,\n                        unsigned int keybits )\n{\n    int ret;\n    const mbedtls_cipher_info_t *cipher_info;\n\n    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );\n    if( cipher_info == NULL )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    if( cipher_info->block_size != 16 )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n\n    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,\n                               MBEDTLS_ENCRYPT ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = gcm_gen_table( ctx ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\n/*\n * Shoup's method for multiplication use this table with\n *      last4[x] = x times P^128\n * where x and last4[x] are seen as elements of GF(2^128) as in [MGV]\n */\nstatic const uint64_t last4[16] =\n{\n    0x0000, 0x1c20, 0x3840, 0x2460,\n    0x7080, 0x6ca0, 0x48c0, 0x54e0,\n    0xe100, 0xfd20, 0xd940, 0xc560,\n    0x9180, 0x8da0, 0xa9c0, 0xb5e0\n};\n\n/*\n * Sets output to x times H using the precomputed tables.\n * x and output are seen as elements of GF(2^128) as in [MGV].\n */\nstatic void gcm_mult( mbedtls_gcm_context *ctx, const unsigned char x[16],\n                      unsigned char output[16] )\n{\n    int i = 0;\n    unsigned char lo, hi, rem;\n    uint64_t zh, zl;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_CLMUL ) ) {\n        unsigned char h[16];\n\n        PUT_UINT32_BE( ctx->HH[8] >> 32, h,  0 );\n        PUT_UINT32_BE( ctx->HH[8],       h,  4 );\n        PUT_UINT32_BE( ctx->HL[8] >> 32, h,  8 );\n        PUT_UINT32_BE( ctx->HL[8],       h, 12 );\n\n        mbedtls_aesni_gcm_mult( output, x, h );\n        return;\n    }\n#endif /* MBEDTLS_AESNI_C && MBEDTLS_HAVE_X86_64 */\n\n    lo = x[15] & 0xf;\n\n    zh = ctx->HH[lo];\n    zl = ctx->HL[lo];\n\n    for( i = 15; i >= 0; i-- )\n    {\n        lo = x[i] & 0xf;\n        hi = x[i] >> 4;\n\n        if( i != 15 )\n        {\n            rem = (unsigned char) zl & 0xf;\n            zl = ( zh << 60 ) | ( zl >> 4 );\n            zh = ( zh >> 4 );\n            zh ^= (uint64_t) last4[rem] << 48;\n            zh ^= ctx->HH[lo];\n            zl ^= ctx->HL[lo];\n\n        }\n\n        rem = (unsigned char) zl & 0xf;\n        zl = ( zh << 60 ) | ( zl >> 4 );\n        zh = ( zh >> 4 );\n        zh ^= (uint64_t) last4[rem] << 48;\n        zh ^= ctx->HH[hi];\n        zl ^= ctx->HL[hi];\n    }\n\n    PUT_UINT32_BE( zh >> 32, output, 0 );\n    PUT_UINT32_BE( zh, output, 4 );\n    PUT_UINT32_BE( zl >> 32, output, 8 );\n    PUT_UINT32_BE( zl, output, 12 );\n}\n\nint mbedtls_gcm_starts( mbedtls_gcm_context *ctx,\n                int mode,\n                const unsigned char *iv,\n                size_t iv_len,\n                const unsigned char *add,\n                size_t add_len )\n{\n    int ret;\n    unsigned char work_buf[16];\n    size_t i;\n    const unsigned char *p;\n    size_t use_len, olen = 0;\n\n    /* IV and AD are limited to 2^64 bits, so 2^61 bytes */\n    /* IV is not allowed to be zero length */\n    if( iv_len == 0 ||\n      ( (uint64_t) iv_len  ) >> 61 != 0 ||\n      ( (uint64_t) add_len ) >> 61 != 0 )\n    {\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n    }\n\n    memset( ctx->y, 0x00, sizeof(ctx->y) );\n    memset( ctx->buf, 0x00, sizeof(ctx->buf) );\n\n    ctx->mode = mode;\n    ctx->len = 0;\n    ctx->add_len = 0;\n\n    if( iv_len == 12 )\n    {\n        memcpy( ctx->y, iv, iv_len );\n        ctx->y[15] = 1;\n    }\n    else\n    {\n        memset( work_buf, 0x00, 16 );\n        PUT_UINT32_BE( iv_len * 8, work_buf, 12 );\n\n        p = iv;\n        while( iv_len > 0 )\n        {\n            use_len = ( iv_len < 16 ) ? iv_len : 16;\n\n            for( i = 0; i < use_len; i++ )\n                ctx->y[i] ^= p[i];\n\n            gcm_mult( ctx, ctx->y, ctx->y );\n\n            iv_len -= use_len;\n            p += use_len;\n        }\n\n        for( i = 0; i < 16; i++ )\n            ctx->y[i] ^= work_buf[i];\n\n        gcm_mult( ctx, ctx->y, ctx->y );\n    }\n\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ctx->base_ectr,\n                             &olen ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    ctx->add_len = add_len;\n    p = add;\n    while( add_len > 0 )\n    {\n        use_len = ( add_len < 16 ) ? add_len : 16;\n\n        for( i = 0; i < use_len; i++ )\n            ctx->buf[i] ^= p[i];\n\n        gcm_mult( ctx, ctx->buf, ctx->buf );\n\n        add_len -= use_len;\n        p += use_len;\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_update( mbedtls_gcm_context *ctx,\n                size_t length,\n                const unsigned char *input,\n                unsigned char *output )\n{\n    int ret;\n    unsigned char ectr[16];\n    size_t i;\n    const unsigned char *p;\n    unsigned char *out_p = output;\n    size_t use_len, olen = 0;\n\n    if( output > input && (size_t) ( output - input ) < length )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes\n     * Also check for possible overflow */\n    if( ctx->len + length < ctx->len ||\n        (uint64_t) ctx->len + length > 0xFFFFFFFE0ull )\n    {\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n    }\n\n    ctx->len += length;\n\n    p = input;\n    while( length > 0 )\n    {\n        use_len = ( length < 16 ) ? length : 16;\n\n        for( i = 16; i > 12; i-- )\n            if( ++ctx->y[i - 1] != 0 )\n                break;\n\n        if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,\n                                   &olen ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        for( i = 0; i < use_len; i++ )\n        {\n            if( ctx->mode == MBEDTLS_GCM_DECRYPT )\n                ctx->buf[i] ^= p[i];\n            out_p[i] = ectr[i] ^ p[i];\n            if( ctx->mode == MBEDTLS_GCM_ENCRYPT )\n                ctx->buf[i] ^= out_p[i];\n        }\n\n        gcm_mult( ctx, ctx->buf, ctx->buf );\n\n        length -= use_len;\n        p += use_len;\n        out_p += use_len;\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_finish( mbedtls_gcm_context *ctx,\n                unsigned char *tag,\n                size_t tag_len )\n{\n    unsigned char work_buf[16];\n    size_t i;\n    uint64_t orig_len = ctx->len * 8;\n    uint64_t orig_add_len = ctx->add_len * 8;\n\n    if( tag_len > 16 || tag_len < 4 )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    memcpy( tag, ctx->base_ectr, tag_len );\n\n    if( orig_len || orig_add_len )\n    {\n        memset( work_buf, 0x00, 16 );\n\n        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );\n        PUT_UINT32_BE( ( orig_add_len       ), work_buf, 4  );\n        PUT_UINT32_BE( ( orig_len     >> 32 ), work_buf, 8  );\n        PUT_UINT32_BE( ( orig_len           ), work_buf, 12 );\n\n        for( i = 0; i < 16; i++ )\n            ctx->buf[i] ^= work_buf[i];\n\n        gcm_mult( ctx, ctx->buf, ctx->buf );\n\n        for( i = 0; i < tag_len; i++ )\n            tag[i] ^= ctx->buf[i];\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_crypt_and_tag( mbedtls_gcm_context *ctx,\n                       int mode,\n                       size_t length,\n                       const unsigned char *iv,\n                       size_t iv_len,\n                       const unsigned char *add,\n                       size_t add_len,\n                       const unsigned char *input,\n                       unsigned char *output,\n                       size_t tag_len,\n                       unsigned char *tag )\n{\n    int ret;\n\n    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len, add, add_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_gcm_update( ctx, length, input, output ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_gcm_finish( ctx, tag, tag_len ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\nint mbedtls_gcm_auth_decrypt( mbedtls_gcm_context *ctx,\n                      size_t length,\n                      const unsigned char *iv,\n                      size_t iv_len,\n                      const unsigned char *add,\n                      size_t add_len,\n                      const unsigned char *tag,\n                      size_t tag_len,\n                      const unsigned char *input,\n                      unsigned char *output )\n{\n    int ret;\n    unsigned char check_tag[16];\n    size_t i;\n    int diff;\n\n    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,\n                                   iv, iv_len, add, add_len,\n                                   input, output, tag_len, check_tag ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* Check tag in \"constant-time\" */\n    for( diff = 0, i = 0; i < tag_len; i++ )\n        diff |= tag[i] ^ check_tag[i];\n\n    if( diff != 0 )\n    {\n        mbedtls_platform_zeroize( output, length );\n        return( MBEDTLS_ERR_GCM_AUTH_FAILED );\n    }\n\n    return( 0 );\n}\n\nvoid mbedtls_gcm_free( mbedtls_gcm_context *ctx )\n{\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_gcm_context ) );\n}\n\n#endif /* !MBEDTLS_GCM_ALT */\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n/*\n * AES-GCM test vectors from:\n *\n * http://csrc.nist.gov/groups/STM/cavp/documents/mac/gcmtestvectors.zip\n */\n#define MAX_TESTS   6\n\nstatic const int key_index[MAX_TESTS] =\n    { 0, 0, 1, 1, 1, 1 };\n\nstatic const unsigned char key[MAX_TESTS][32] =\n{\n    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n    { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,\n      0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,\n      0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,\n      0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 },\n};\n\nstatic const size_t iv_len[MAX_TESTS] =\n    { 12, 12, 12, 12, 8, 60 };\n\nstatic const int iv_index[MAX_TESTS] =\n    { 0, 0, 1, 1, 1, 2 };\n\nstatic const unsigned char iv[MAX_TESTS][64] =\n{\n    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00 },\n    { 0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,\n      0xde, 0xca, 0xf8, 0x88 },\n    { 0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5,\n      0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,\n      0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1,\n      0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,\n      0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39,\n      0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,\n      0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57,\n      0xa6, 0x37, 0xb3, 0x9b },\n};\n\nstatic const size_t add_len[MAX_TESTS] =\n    { 0, 0, 0, 20, 20, 20 };\n\nstatic const int add_index[MAX_TESTS] =\n    { 0, 0, 0, 1, 1, 1 };\n\nstatic const unsigned char additional[MAX_TESTS][64] =\n{\n    { 0x00 },\n    { 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,\n      0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,\n      0xab, 0xad, 0xda, 0xd2 },\n};\n\nstatic const size_t pt_len[MAX_TESTS] =\n    { 0, 16, 64, 60, 60, 60 };\n\nstatic const int pt_index[MAX_TESTS] =\n    { 0, 0, 1, 1, 1, 1 };\n\nstatic const unsigned char pt[MAX_TESTS][64] =\n{\n    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n    { 0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,\n      0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,\n      0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,\n      0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,\n      0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,\n      0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,\n      0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,\n      0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55 },\n};\n\nstatic const unsigned char ct[MAX_TESTS * 3][64] =\n{\n    { 0x00 },\n    { 0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92,\n      0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78 },\n    { 0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,\n      0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,\n      0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,\n      0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,\n      0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,\n      0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,\n      0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,\n      0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85 },\n    { 0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,\n      0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,\n      0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,\n      0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,\n      0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,\n      0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,\n      0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,\n      0x3d, 0x58, 0xe0, 0x91 },\n    { 0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a,\n      0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55,\n      0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8,\n      0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23,\n      0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2,\n      0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42,\n      0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07,\n      0xc2, 0x3f, 0x45, 0x98 },\n    { 0x8c, 0xe2, 0x49, 0x98, 0x62, 0x56, 0x15, 0xb6,\n      0x03, 0xa0, 0x33, 0xac, 0xa1, 0x3f, 0xb8, 0x94,\n      0xbe, 0x91, 0x12, 0xa5, 0xc3, 0xa2, 0x11, 0xa8,\n      0xba, 0x26, 0x2a, 0x3c, 0xca, 0x7e, 0x2c, 0xa7,\n      0x01, 0xe4, 0xa9, 0xa4, 0xfb, 0xa4, 0x3c, 0x90,\n      0xcc, 0xdc, 0xb2, 0x81, 0xd4, 0x8c, 0x7c, 0x6f,\n      0xd6, 0x28, 0x75, 0xd2, 0xac, 0xa4, 0x17, 0x03,\n      0x4c, 0x34, 0xae, 0xe5 },\n    { 0x00 },\n    { 0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41,\n      0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00 },\n    { 0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41,\n      0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,\n      0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84,\n      0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,\n      0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,\n      0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,\n      0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9,\n      0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56 },\n    { 0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41,\n      0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,\n      0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84,\n      0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,\n      0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,\n      0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,\n      0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9,\n      0xcc, 0xda, 0x27, 0x10 },\n    { 0x0f, 0x10, 0xf5, 0x99, 0xae, 0x14, 0xa1, 0x54,\n      0xed, 0x24, 0xb3, 0x6e, 0x25, 0x32, 0x4d, 0xb8,\n      0xc5, 0x66, 0x63, 0x2e, 0xf2, 0xbb, 0xb3, 0x4f,\n      0x83, 0x47, 0x28, 0x0f, 0xc4, 0x50, 0x70, 0x57,\n      0xfd, 0xdc, 0x29, 0xdf, 0x9a, 0x47, 0x1f, 0x75,\n      0xc6, 0x65, 0x41, 0xd4, 0xd4, 0xda, 0xd1, 0xc9,\n      0xe9, 0x3a, 0x19, 0xa5, 0x8e, 0x8b, 0x47, 0x3f,\n      0xa0, 0xf0, 0x62, 0xf7 },\n    { 0xd2, 0x7e, 0x88, 0x68, 0x1c, 0xe3, 0x24, 0x3c,\n      0x48, 0x30, 0x16, 0x5a, 0x8f, 0xdc, 0xf9, 0xff,\n      0x1d, 0xe9, 0xa1, 0xd8, 0xe6, 0xb4, 0x47, 0xef,\n      0x6e, 0xf7, 0xb7, 0x98, 0x28, 0x66, 0x6e, 0x45,\n      0x81, 0xe7, 0x90, 0x12, 0xaf, 0x34, 0xdd, 0xd9,\n      0xe2, 0xf0, 0x37, 0x58, 0x9b, 0x29, 0x2d, 0xb3,\n      0xe6, 0x7c, 0x03, 0x67, 0x45, 0xfa, 0x22, 0xe7,\n      0xe9, 0xb7, 0x37, 0x3b },\n    { 0x00 },\n    { 0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e,\n      0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18 },\n    { 0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07,\n      0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,\n      0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9,\n      0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,\n      0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,\n      0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,\n      0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a,\n      0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad },\n    { 0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07,\n      0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,\n      0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9,\n      0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,\n      0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,\n      0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,\n      0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a,\n      0xbc, 0xc9, 0xf6, 0x62 },\n    { 0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32,\n      0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb,\n      0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa,\n      0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0,\n      0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0,\n      0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78,\n      0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99,\n      0xf4, 0x7c, 0x9b, 0x1f },\n    { 0x5a, 0x8d, 0xef, 0x2f, 0x0c, 0x9e, 0x53, 0xf1,\n      0xf7, 0x5d, 0x78, 0x53, 0x65, 0x9e, 0x2a, 0x20,\n      0xee, 0xb2, 0xb2, 0x2a, 0xaf, 0xde, 0x64, 0x19,\n      0xa0, 0x58, 0xab, 0x4f, 0x6f, 0x74, 0x6b, 0xf4,\n      0x0f, 0xc0, 0xc3, 0xb7, 0x80, 0xf2, 0x44, 0x45,\n      0x2d, 0xa3, 0xeb, 0xf1, 0xc5, 0xd8, 0x2c, 0xde,\n      0xa2, 0x41, 0x89, 0x97, 0x20, 0x0e, 0xf8, 0x2e,\n      0x44, 0xae, 0x7e, 0x3f },\n};\n\nstatic const unsigned char tag[MAX_TESTS * 3][16] =\n{\n    { 0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61,\n      0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a },\n    { 0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd,\n      0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf },\n    { 0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6,\n      0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4 },\n    { 0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,\n      0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47 },\n    { 0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85,\n      0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb },\n    { 0x61, 0x9c, 0xc5, 0xae, 0xff, 0xfe, 0x0b, 0xfa,\n      0x46, 0x2a, 0xf4, 0x3c, 0x16, 0x99, 0xd0, 0x50 },\n    { 0xcd, 0x33, 0xb2, 0x8a, 0xc7, 0x73, 0xf7, 0x4b,\n      0xa0, 0x0e, 0xd1, 0xf3, 0x12, 0x57, 0x24, 0x35 },\n    { 0x2f, 0xf5, 0x8d, 0x80, 0x03, 0x39, 0x27, 0xab,\n      0x8e, 0xf4, 0xd4, 0x58, 0x75, 0x14, 0xf0, 0xfb },\n    { 0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf,\n      0xb1, 0x18, 0x02, 0x4d, 0xb8, 0x67, 0x4a, 0x14 },\n    { 0x25, 0x19, 0x49, 0x8e, 0x80, 0xf1, 0x47, 0x8f,\n      0x37, 0xba, 0x55, 0xbd, 0x6d, 0x27, 0x61, 0x8c },\n    { 0x65, 0xdc, 0xc5, 0x7f, 0xcf, 0x62, 0x3a, 0x24,\n      0x09, 0x4f, 0xcc, 0xa4, 0x0d, 0x35, 0x33, 0xf8 },\n    { 0xdc, 0xf5, 0x66, 0xff, 0x29, 0x1c, 0x25, 0xbb,\n      0xb8, 0x56, 0x8f, 0xc3, 0xd3, 0x76, 0xa6, 0xd9 },\n    { 0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9,\n      0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b },\n    { 0xd0, 0xd1, 0xc8, 0xa7, 0x99, 0x99, 0x6b, 0xf0,\n      0x26, 0x5b, 0x98, 0xb5, 0xd4, 0x8a, 0xb9, 0x19 },\n    { 0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd,\n      0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c },\n    { 0x76, 0xfc, 0x6e, 0xce, 0x0f, 0x4e, 0x17, 0x68,\n      0xcd, 0xdf, 0x88, 0x53, 0xbb, 0x2d, 0x55, 0x1b },\n    { 0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4,\n      0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2 },\n    { 0xa4, 0x4a, 0x82, 0x66, 0xee, 0x1c, 0x8e, 0xb0,\n      0xc8, 0xb5, 0xd4, 0xcf, 0x5a, 0xe9, 0xf1, 0x9a },\n};\n\nint mbedtls_gcm_self_test( int verbose )\n{\n    mbedtls_gcm_context ctx;\n    unsigned char buf[64];\n    unsigned char tag_buf[16];\n    int i, j, ret;\n    mbedtls_cipher_id_t cipher = MBEDTLS_CIPHER_ID_AES;\n\n    for( j = 0; j < 3; j++ )\n    {\n        int key_len = 128 + 64 * j;\n\n        for( i = 0; i < MAX_TESTS; i++ )\n        {\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d (%s): \",\n                                key_len, i, \"enc\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            /*\n             * AES-192 is an optional feature that may be unavailable when\n             * there is an alternative underlying implementation i.e. when\n             * MBEDTLS_AES_ALT is defined.\n             */\n            if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && key_len == 192 )\n            {\n                mbedtls_printf( \"skipped\\n\" );\n                break;\n            }\n            else if( ret != 0 )\n            {\n                goto exit;\n            }\n\n            ret = mbedtls_gcm_crypt_and_tag( &ctx, MBEDTLS_GCM_ENCRYPT,\n                                        pt_len[i],\n                                        iv[iv_index[i]], iv_len[i],\n                                        additional[add_index[i]], add_len[i],\n                                        pt[pt_index[i]], buf, 16, tag_buf );\n            if( ret != 0 )\n                goto exit;\n\n            if ( memcmp( buf, ct[j * 6 + i], pt_len[i] ) != 0 ||\n                 memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d (%s): \",\n                                key_len, i, \"dec\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            if( ret != 0 )\n                goto exit;\n\n            ret = mbedtls_gcm_crypt_and_tag( &ctx, MBEDTLS_GCM_DECRYPT,\n                                        pt_len[i],\n                                        iv[iv_index[i]], iv_len[i],\n                                        additional[add_index[i]], add_len[i],\n                                        ct[j * 6 + i], buf, 16, tag_buf );\n\n            if( ret != 0 )\n                goto exit;\n\n            if( memcmp( buf, pt[pt_index[i]], pt_len[i] ) != 0 ||\n                memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d split (%s): \",\n                                key_len, i, \"enc\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            if( ret != 0 )\n                goto exit;\n\n            ret = mbedtls_gcm_starts( &ctx, MBEDTLS_GCM_ENCRYPT,\n                                      iv[iv_index[i]], iv_len[i],\n                                      additional[add_index[i]], add_len[i] );\n            if( ret != 0 )\n                goto exit;\n\n            if( pt_len[i] > 32 )\n            {\n                size_t rest_len = pt_len[i] - 32;\n                ret = mbedtls_gcm_update( &ctx, 32, pt[pt_index[i]], buf );\n                if( ret != 0 )\n                    goto exit;\n\n                ret = mbedtls_gcm_update( &ctx, rest_len, pt[pt_index[i]] + 32,\n                                  buf + 32 );\n                if( ret != 0 )\n                    goto exit;\n            }\n            else\n            {\n                ret = mbedtls_gcm_update( &ctx, pt_len[i], pt[pt_index[i]], buf );\n                if( ret != 0 )\n                    goto exit;\n            }\n\n            ret = mbedtls_gcm_finish( &ctx, tag_buf, 16 );\n            if( ret != 0 )\n                goto exit;\n\n            if( memcmp( buf, ct[j * 6 + i], pt_len[i] ) != 0 ||\n                memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d split (%s): \",\n                                key_len, i, \"dec\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            if( ret != 0 )\n                goto exit;\n\n            ret = mbedtls_gcm_starts( &ctx, MBEDTLS_GCM_DECRYPT,\n                              iv[iv_index[i]], iv_len[i],\n                              additional[add_index[i]], add_len[i] );\n            if( ret != 0 )\n                goto exit;\n\n            if( pt_len[i] > 32 )\n            {\n                size_t rest_len = pt_len[i] - 32;\n                ret = mbedtls_gcm_update( &ctx, 32, ct[j * 6 + i], buf );\n                if( ret != 0 )\n                    goto exit;\n\n                ret = mbedtls_gcm_update( &ctx, rest_len, ct[j * 6 + i] + 32,\n                                          buf + 32 );\n                if( ret != 0 )\n                    goto exit;\n            }\n            else\n            {\n                ret = mbedtls_gcm_update( &ctx, pt_len[i], ct[j * 6 + i],\n                                          buf );\n                if( ret != 0 )\n                    goto exit;\n            }\n\n            ret = mbedtls_gcm_finish( &ctx, tag_buf, 16 );\n            if( ret != 0 )\n                goto exit;\n\n            if( memcmp( buf, pt[pt_index[i]], pt_len[i] ) != 0 ||\n                memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n        }\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    ret = 0;\n\nexit:\n    if( ret != 0 )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"failed\\n\" );\n        mbedtls_gcm_free( &ctx );\n    }\n\n    return( ret );\n}\n\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#endif /* MBEDTLS_GCM_C */\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","/**\n * \\file cipher.h\n *\n * \\brief This file contains an abstraction interface for use with the cipher\n * primitives provided by the library. It provides a common interface to all of\n * the available cipher operations.\n *\n * \\author Adriaan de Jong <dejong@fox-it.com>\n */\n/*\n *  Copyright (C) 2006-2018, Arm Limited (or its affiliates), All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of Mbed TLS (https://tls.mbed.org)\n */\n\n#ifndef MBEDTLS_CIPHER_H\n#define MBEDTLS_CIPHER_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include <stddef.h>\n\n#if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CCM_C)\n#define MBEDTLS_CIPHER_MODE_AEAD\n#endif\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n#define MBEDTLS_CIPHER_MODE_WITH_PADDING\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n#define MBEDTLS_CIPHER_MODE_STREAM\n#endif\n\n#if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) && \\\n    !defined(inline) && !defined(__cplusplus)\n#define inline __inline\n#endif\n\n#define MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE  -0x6080  /**< The selected feature is not available. */\n#define MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA       -0x6100  /**< Bad input parameters. */\n#define MBEDTLS_ERR_CIPHER_ALLOC_FAILED         -0x6180  /**< Failed to allocate memory. */\n#define MBEDTLS_ERR_CIPHER_INVALID_PADDING      -0x6200  /**< Input data contains invalid padding and is rejected. */\n#define MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED  -0x6280  /**< Decryption of block requires a full block. */\n#define MBEDTLS_ERR_CIPHER_AUTH_FAILED          -0x6300  /**< Authentication failed (for AEAD modes). */\n#define MBEDTLS_ERR_CIPHER_INVALID_CONTEXT      -0x6380  /**< The context is invalid. For example, because it was freed. */\n#define MBEDTLS_ERR_CIPHER_HW_ACCEL_FAILED      -0x6400  /**< Cipher hardware accelerator failed. */\n\n#define MBEDTLS_CIPHER_VARIABLE_IV_LEN     0x01    /**< Cipher accepts IVs of variable length. */\n#define MBEDTLS_CIPHER_VARIABLE_KEY_LEN    0x02    /**< Cipher accepts keys of variable length. */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\brief     Supported cipher types.\n *\n * \\warning   RC4 and DES are considered weak ciphers and their use\n *            constitutes a security risk. Arm recommends considering stronger\n *            ciphers instead.\n */\ntypedef enum {\n    MBEDTLS_CIPHER_ID_NONE = 0,  /**< Placeholder to mark the end of cipher ID lists. */\n    MBEDTLS_CIPHER_ID_NULL,      /**< The identity cipher, treated as a stream cipher. */\n    MBEDTLS_CIPHER_ID_AES,       /**< The AES cipher. */\n    MBEDTLS_CIPHER_ID_DES,       /**< The DES cipher. */\n    MBEDTLS_CIPHER_ID_3DES,      /**< The Triple DES cipher. */\n    MBEDTLS_CIPHER_ID_CAMELLIA,  /**< The Camellia cipher. */\n    MBEDTLS_CIPHER_ID_BLOWFISH,  /**< The Blowfish cipher. */\n    MBEDTLS_CIPHER_ID_ARC4,      /**< The RC4 cipher. */\n    MBEDTLS_CIPHER_ID_ARIA,      /**< The Aria cipher. */\n} mbedtls_cipher_id_t;\n\n/**\n * \\brief     Supported {cipher type, cipher mode} pairs.\n *\n * \\warning   RC4 and DES are considered weak ciphers and their use\n *            constitutes a security risk. Arm recommends considering stronger\n *            ciphers instead.\n */\ntypedef enum {\n    MBEDTLS_CIPHER_NONE = 0,             /**< Placeholder to mark the end of cipher-pair lists. */\n    MBEDTLS_CIPHER_NULL,                 /**< The identity stream cipher. */\n    MBEDTLS_CIPHER_AES_128_ECB,          /**< AES cipher with 128-bit ECB mode. */\n    MBEDTLS_CIPHER_AES_192_ECB,          /**< AES cipher with 192-bit ECB mode. */\n    MBEDTLS_CIPHER_AES_256_ECB,          /**< AES cipher with 256-bit ECB mode. */\n    MBEDTLS_CIPHER_AES_128_CBC,          /**< AES cipher with 128-bit CBC mode. */\n    MBEDTLS_CIPHER_AES_192_CBC,          /**< AES cipher with 192-bit CBC mode. */\n    MBEDTLS_CIPHER_AES_256_CBC,          /**< AES cipher with 256-bit CBC mode. */\n    MBEDTLS_CIPHER_AES_128_CFB128,       /**< AES cipher with 128-bit CFB128 mode. */\n    MBEDTLS_CIPHER_AES_192_CFB128,       /**< AES cipher with 192-bit CFB128 mode. */\n    MBEDTLS_CIPHER_AES_256_CFB128,       /**< AES cipher with 256-bit CFB128 mode. */\n    MBEDTLS_CIPHER_AES_128_CTR,          /**< AES cipher with 128-bit CTR mode. */\n    MBEDTLS_CIPHER_AES_192_CTR,          /**< AES cipher with 192-bit CTR mode. */\n    MBEDTLS_CIPHER_AES_256_CTR,          /**< AES cipher with 256-bit CTR mode. */\n    MBEDTLS_CIPHER_AES_128_GCM,          /**< AES cipher with 128-bit GCM mode. */\n    MBEDTLS_CIPHER_AES_192_GCM,          /**< AES cipher with 192-bit GCM mode. */\n    MBEDTLS_CIPHER_AES_256_GCM,          /**< AES cipher with 256-bit GCM mode. */\n    MBEDTLS_CIPHER_CAMELLIA_128_ECB,     /**< Camellia cipher with 128-bit ECB mode. */\n    MBEDTLS_CIPHER_CAMELLIA_192_ECB,     /**< Camellia cipher with 192-bit ECB mode. */\n    MBEDTLS_CIPHER_CAMELLIA_256_ECB,     /**< Camellia cipher with 256-bit ECB mode. */\n    MBEDTLS_CIPHER_CAMELLIA_128_CBC,     /**< Camellia cipher with 128-bit CBC mode. */\n    MBEDTLS_CIPHER_CAMELLIA_192_CBC,     /**< Camellia cipher with 192-bit CBC mode. */\n    MBEDTLS_CIPHER_CAMELLIA_256_CBC,     /**< Camellia cipher with 256-bit CBC mode. */\n    MBEDTLS_CIPHER_CAMELLIA_128_CFB128,  /**< Camellia cipher with 128-bit CFB128 mode. */\n    MBEDTLS_CIPHER_CAMELLIA_192_CFB128,  /**< Camellia cipher with 192-bit CFB128 mode. */\n    MBEDTLS_CIPHER_CAMELLIA_256_CFB128,  /**< Camellia cipher with 256-bit CFB128 mode. */\n    MBEDTLS_CIPHER_CAMELLIA_128_CTR,     /**< Camellia cipher with 128-bit CTR mode. */\n    MBEDTLS_CIPHER_CAMELLIA_192_CTR,     /**< Camellia cipher with 192-bit CTR mode. */\n    MBEDTLS_CIPHER_CAMELLIA_256_CTR,     /**< Camellia cipher with 256-bit CTR mode. */\n    MBEDTLS_CIPHER_CAMELLIA_128_GCM,     /**< Camellia cipher with 128-bit GCM mode. */\n    MBEDTLS_CIPHER_CAMELLIA_192_GCM,     /**< Camellia cipher with 192-bit GCM mode. */\n    MBEDTLS_CIPHER_CAMELLIA_256_GCM,     /**< Camellia cipher with 256-bit GCM mode. */\n    MBEDTLS_CIPHER_DES_ECB,              /**< DES cipher with ECB mode. */\n    MBEDTLS_CIPHER_DES_CBC,              /**< DES cipher with CBC mode. */\n    MBEDTLS_CIPHER_DES_EDE_ECB,          /**< DES cipher with EDE ECB mode. */\n    MBEDTLS_CIPHER_DES_EDE_CBC,          /**< DES cipher with EDE CBC mode. */\n    MBEDTLS_CIPHER_DES_EDE3_ECB,         /**< DES cipher with EDE3 ECB mode. */\n    MBEDTLS_CIPHER_DES_EDE3_CBC,         /**< DES cipher with EDE3 CBC mode. */\n    MBEDTLS_CIPHER_BLOWFISH_ECB,         /**< Blowfish cipher with ECB mode. */\n    MBEDTLS_CIPHER_BLOWFISH_CBC,         /**< Blowfish cipher with CBC mode. */\n    MBEDTLS_CIPHER_BLOWFISH_CFB64,       /**< Blowfish cipher with CFB64 mode. */\n    MBEDTLS_CIPHER_BLOWFISH_CTR,         /**< Blowfish cipher with CTR mode. */\n    MBEDTLS_CIPHER_ARC4_128,             /**< RC4 cipher with 128-bit mode. */\n    MBEDTLS_CIPHER_AES_128_CCM,          /**< AES cipher with 128-bit CCM mode. */\n    MBEDTLS_CIPHER_AES_192_CCM,          /**< AES cipher with 192-bit CCM mode. */\n    MBEDTLS_CIPHER_AES_256_CCM,          /**< AES cipher with 256-bit CCM mode. */\n    MBEDTLS_CIPHER_CAMELLIA_128_CCM,     /**< Camellia cipher with 128-bit CCM mode. */\n    MBEDTLS_CIPHER_CAMELLIA_192_CCM,     /**< Camellia cipher with 192-bit CCM mode. */\n    MBEDTLS_CIPHER_CAMELLIA_256_CCM,     /**< Camellia cipher with 256-bit CCM mode. */\n    MBEDTLS_CIPHER_ARIA_128_ECB,         /**< Aria cipher with 128-bit key and ECB mode. */\n    MBEDTLS_CIPHER_ARIA_192_ECB,         /**< Aria cipher with 192-bit key and ECB mode. */\n    MBEDTLS_CIPHER_ARIA_256_ECB,         /**< Aria cipher with 256-bit key and ECB mode. */\n    MBEDTLS_CIPHER_ARIA_128_CBC,         /**< Aria cipher with 128-bit key and CBC mode. */\n    MBEDTLS_CIPHER_ARIA_192_CBC,         /**< Aria cipher with 192-bit key and CBC mode. */\n    MBEDTLS_CIPHER_ARIA_256_CBC,         /**< Aria cipher with 256-bit key and CBC mode. */\n    MBEDTLS_CIPHER_ARIA_128_CFB128,      /**< Aria cipher with 128-bit key and CFB-128 mode. */\n    MBEDTLS_CIPHER_ARIA_192_CFB128,      /**< Aria cipher with 192-bit key and CFB-128 mode. */\n    MBEDTLS_CIPHER_ARIA_256_CFB128,      /**< Aria cipher with 256-bit key and CFB-128 mode. */\n    MBEDTLS_CIPHER_ARIA_128_CTR,         /**< Aria cipher with 128-bit key and CTR mode. */\n    MBEDTLS_CIPHER_ARIA_192_CTR,         /**< Aria cipher with 192-bit key and CTR mode. */\n    MBEDTLS_CIPHER_ARIA_256_CTR,         /**< Aria cipher with 256-bit key and CTR mode. */\n    MBEDTLS_CIPHER_ARIA_128_GCM,         /**< Aria cipher with 128-bit key and GCM mode. */\n    MBEDTLS_CIPHER_ARIA_192_GCM,         /**< Aria cipher with 192-bit key and GCM mode. */\n    MBEDTLS_CIPHER_ARIA_256_GCM,         /**< Aria cipher with 256-bit key and GCM mode. */\n    MBEDTLS_CIPHER_ARIA_128_CCM,         /**< Aria cipher with 128-bit key and CCM mode. */\n    MBEDTLS_CIPHER_ARIA_192_CCM,         /**< Aria cipher with 192-bit key and CCM mode. */\n    MBEDTLS_CIPHER_ARIA_256_CCM,         /**< Aria cipher with 256-bit key and CCM mode. */\n} mbedtls_cipher_type_t;\n\n/** Supported cipher modes. */\ntypedef enum {\n    MBEDTLS_MODE_NONE = 0,               /**< None. */\n    MBEDTLS_MODE_ECB,                    /**< The ECB cipher mode. */\n    MBEDTLS_MODE_CBC,                    /**< The CBC cipher mode. */\n    MBEDTLS_MODE_CFB,                    /**< The CFB cipher mode. */\n    MBEDTLS_MODE_OFB,                    /**< The OFB cipher mode - unsupported. */\n    MBEDTLS_MODE_CTR,                    /**< The CTR cipher mode. */\n    MBEDTLS_MODE_GCM,                    /**< The GCM cipher mode. */\n    MBEDTLS_MODE_STREAM,                 /**< The stream cipher mode. */\n    MBEDTLS_MODE_CCM,                    /**< The CCM cipher mode. */\n} mbedtls_cipher_mode_t;\n\n/** Supported cipher padding types. */\ntypedef enum {\n    MBEDTLS_PADDING_PKCS7 = 0,     /**< PKCS7 padding (default).        */\n    MBEDTLS_PADDING_ONE_AND_ZEROS, /**< ISO/IEC 7816-4 padding.         */\n    MBEDTLS_PADDING_ZEROS_AND_LEN, /**< ANSI X.923 padding.             */\n    MBEDTLS_PADDING_ZEROS,         /**< Zero padding (not reversible). */\n    MBEDTLS_PADDING_NONE,          /**< Never pad (full blocks only).   */\n} mbedtls_cipher_padding_t;\n\n/** Type of operation. */\ntypedef enum {\n    MBEDTLS_OPERATION_NONE = -1,\n    MBEDTLS_DECRYPT = 0,\n    MBEDTLS_ENCRYPT,\n} mbedtls_operation_t;\n\nenum {\n    /** Undefined key length. */\n    MBEDTLS_KEY_LENGTH_NONE = 0,\n    /** Key length, in bits (including parity), for DES keys. */\n    MBEDTLS_KEY_LENGTH_DES  = 64,\n    /** Key length in bits, including parity, for DES in two-key EDE. */\n    MBEDTLS_KEY_LENGTH_DES_EDE = 128,\n    /** Key length in bits, including parity, for DES in three-key EDE. */\n    MBEDTLS_KEY_LENGTH_DES_EDE3 = 192,\n};\n\n/** Maximum length of any IV, in Bytes. */\n#define MBEDTLS_MAX_IV_LENGTH      16\n/** Maximum block size of any cipher, in Bytes. */\n#define MBEDTLS_MAX_BLOCK_LENGTH   16\n\n/**\n * Base cipher information (opaque struct).\n */\ntypedef struct mbedtls_cipher_base_t mbedtls_cipher_base_t;\n\n/**\n * CMAC context (opaque struct).\n */\ntypedef struct mbedtls_cmac_context_t mbedtls_cmac_context_t;\n\n/**\n * Cipher information. Allows calling cipher functions\n * in a generic way.\n */\ntypedef struct {\n    /** Full cipher identifier. For example,\n     * MBEDTLS_CIPHER_AES_256_CBC.\n     */\n    mbedtls_cipher_type_t type;\n\n    /** The cipher mode. For example, MBEDTLS_MODE_CBC. */\n    mbedtls_cipher_mode_t mode;\n\n    /** The cipher key length, in bits. This is the\n     * default length for variable sized ciphers.\n     * Includes parity bits for ciphers like DES.\n     */\n    unsigned int key_bitlen;\n\n    /** Name of the cipher. */\n    const char * name;\n\n    /** IV or nonce size, in Bytes.\n     * For ciphers that accept variable IV sizes,\n     * this is the recommended size.\n     */\n    unsigned int iv_size;\n\n    /** Bitflag comprised of MBEDTLS_CIPHER_VARIABLE_IV_LEN and\n     *  MBEDTLS_CIPHER_VARIABLE_KEY_LEN indicating whether the\n     *  cipher supports variable IV or variable key sizes, respectively.\n     */\n    int flags;\n\n    /** The block size, in Bytes. */\n    unsigned int block_size;\n\n    /** Struct for base cipher information and functions. */\n    const mbedtls_cipher_base_t *base;\n\n} mbedtls_cipher_info_t;\n\n/**\n * Generic cipher context.\n */\ntypedef struct {\n    /** Information about the associated cipher. */\n    const mbedtls_cipher_info_t *cipher_info;\n\n    /** Key length to use. */\n    int key_bitlen;\n\n    /** Operation that the key of the context has been\n     * initialized for.\n     */\n    mbedtls_operation_t operation;\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n    /** Padding functions to use, if relevant for\n     * the specific cipher mode.\n     */\n    void (*add_padding)( unsigned char *output, size_t olen, size_t data_len );\n    int (*get_padding)( unsigned char *input, size_t ilen, size_t *data_len );\n#endif\n\n    /** Buffer for input that has not been processed yet. */\n    unsigned char unprocessed_data[MBEDTLS_MAX_BLOCK_LENGTH];\n\n    /** Number of Bytes that have not been processed yet. */\n    size_t unprocessed_len;\n\n    /** Current IV or NONCE_COUNTER for CTR-mode. */\n    unsigned char iv[MBEDTLS_MAX_IV_LENGTH];\n\n    /** IV size in Bytes, for ciphers with variable-length IVs. */\n    size_t iv_size;\n\n    /** The cipher-specific context. */\n    void *cipher_ctx;\n\n#if defined(MBEDTLS_CMAC_C)\n    /** CMAC-specific context. */\n    mbedtls_cmac_context_t *cmac_ctx;\n#endif\n} mbedtls_cipher_context_t;\n\n/**\n * \\brief This function retrieves the list of ciphers supported by the generic\n * cipher module.\n *\n * \\return      A statically-allocated array of ciphers. The last entry\n *              is zero.\n */\nconst int *mbedtls_cipher_list( void );\n\n/**\n * \\brief               This function retrieves the cipher-information\n *                      structure associated with the given cipher name.\n *\n * \\param cipher_name   Name of the cipher to search for.\n *\n * \\return              The cipher information structure associated with the\n *                      given \\p cipher_name.\n * \\return              NULL if the associated cipher information is not found.\n */\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name );\n\n/**\n * \\brief               This function retrieves the cipher-information\n *                      structure associated with the given cipher type.\n *\n * \\param cipher_type   Type of the cipher to search for.\n *\n * \\return              The cipher information structure associated with the\n *                      given \\p cipher_type.\n * \\return              NULL if the associated cipher information is not found.\n */\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type );\n\n/**\n * \\brief               This function retrieves the cipher-information\n *                      structure associated with the given cipher ID,\n *                      key size and mode.\n *\n * \\param cipher_id     The ID of the cipher to search for. For example,\n *                      #MBEDTLS_CIPHER_ID_AES.\n * \\param key_bitlen    The length of the key in bits.\n * \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.\n *\n * \\return              The cipher information structure associated with the\n *                      given \\p cipher_id.\n * \\return              NULL if the associated cipher information is not found.\n */\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,\n                                              int key_bitlen,\n                                              const mbedtls_cipher_mode_t mode );\n\n/**\n * \\brief               This function initializes a \\p cipher_context as NONE.\n */\nvoid mbedtls_cipher_init( mbedtls_cipher_context_t *ctx );\n\n/**\n * \\brief               This function frees and clears the cipher-specific\n *                      context of \\p ctx. Freeing \\p ctx itself remains the\n *                      responsibility of the caller.\n */\nvoid mbedtls_cipher_free( mbedtls_cipher_context_t *ctx );\n\n\n/**\n * \\brief               This function initializes and fills the cipher-context\n *                      structure with the appropriate values. It also clears\n *                      the structure.\n *\n * \\param ctx           The context to initialize. May not be NULL.\n * \\param cipher_info   The cipher to use.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the\n *                      cipher-specific context fails.\n *\n * \\internal Currently, the function also clears the structure.\n * In future versions, the caller will be required to call\n * mbedtls_cipher_init() on the structure first.\n */\nint mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info );\n\n/**\n * \\brief        This function returns the block size of the given cipher.\n *\n * \\param ctx    The context of the cipher. Must be initialized.\n *\n * \\return       The size of the blocks of the cipher.\n * \\return       0 if \\p ctx has not been initialized.\n */\nstatic inline unsigned int mbedtls_cipher_get_block_size( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return 0;\n\n    return ctx->cipher_info->block_size;\n}\n\n/**\n * \\brief        This function returns the mode of operation for\n *               the cipher. For example, MBEDTLS_MODE_CBC.\n *\n * \\param ctx    The context of the cipher. Must be initialized.\n *\n * \\return       The mode of operation.\n * \\return       #MBEDTLS_MODE_NONE if \\p ctx has not been initialized.\n */\nstatic inline mbedtls_cipher_mode_t mbedtls_cipher_get_cipher_mode( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_MODE_NONE;\n\n    return ctx->cipher_info->mode;\n}\n\n/**\n * \\brief       This function returns the size of the IV or nonce\n *              of the cipher, in Bytes.\n *\n * \\param ctx   The context of the cipher. Must be initialized.\n *\n * \\return      The recommended IV size if no IV has been set.\n * \\return      \\c 0 for ciphers not using an IV or a nonce.\n * \\return      The actual size if an IV has been set.\n */\nstatic inline int mbedtls_cipher_get_iv_size( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return 0;\n\n    if( ctx->iv_size != 0 )\n        return (int) ctx->iv_size;\n\n    return (int) ctx->cipher_info->iv_size;\n}\n\n/**\n * \\brief               This function returns the type of the given cipher.\n *\n * \\param ctx           The context of the cipher. Must be initialized.\n *\n * \\return              The type of the cipher.\n * \\return              #MBEDTLS_CIPHER_NONE if \\p ctx has not been initialized.\n */\nstatic inline mbedtls_cipher_type_t mbedtls_cipher_get_type( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_CIPHER_NONE;\n\n    return ctx->cipher_info->type;\n}\n\n/**\n * \\brief               This function returns the name of the given cipher\n *                      as a string.\n *\n * \\param ctx           The context of the cipher. Must be initialized.\n *\n * \\return              The name of the cipher.\n * \\return              NULL if \\p ctx has not been not initialized.\n */\nstatic inline const char *mbedtls_cipher_get_name( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return 0;\n\n    return ctx->cipher_info->name;\n}\n\n/**\n * \\brief               This function returns the key length of the cipher.\n *\n * \\param ctx           The context of the cipher. Must be initialized.\n *\n * \\return              The key length of the cipher in bits.\n * \\return              #MBEDTLS_KEY_LENGTH_NONE if ctx \\p has not been\n *                      initialized.\n */\nstatic inline int mbedtls_cipher_get_key_bitlen( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_KEY_LENGTH_NONE;\n\n    return (int) ctx->cipher_info->key_bitlen;\n}\n\n/**\n * \\brief          This function returns the operation of the given cipher.\n *\n * \\param ctx      The context of the cipher. Must be initialized.\n *\n * \\return         The type of operation: #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.\n * \\return         #MBEDTLS_OPERATION_NONE if \\p ctx has not been initialized.\n */\nstatic inline mbedtls_operation_t mbedtls_cipher_get_operation( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_OPERATION_NONE;\n\n    return ctx->operation;\n}\n\n/**\n * \\brief               This function sets the key to use with the given context.\n *\n * \\param ctx           The generic cipher context. May not be NULL. Must have\n *                      been initialized using mbedtls_cipher_info_from_type()\n *                      or mbedtls_cipher_info_from_string().\n * \\param key           The key to use.\n * \\param key_bitlen    The key length to use, in bits.\n * \\param operation     The operation that the key will be used for:\n *                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              A cipher-specific error code on failure.\n */\nint mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx, const unsigned char *key,\n                   int key_bitlen, const mbedtls_operation_t operation );\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n/**\n * \\brief               This function sets the padding mode, for cipher modes\n *                      that use padding.\n *\n *                      The default passing mode is PKCS7 padding.\n *\n * \\param ctx           The generic cipher context.\n * \\param mode          The padding mode.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE\n *                      if the selected padding mode is not supported.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode\n *                      does not support padding.\n */\nint mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode );\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n/**\n * \\brief           This function sets the initialization vector (IV)\n *                  or nonce.\n *\n * \\note            Some ciphers do not use IVs nor nonce. For these\n *                  ciphers, this function has no effect.\n *\n * \\param ctx       The generic cipher context.\n * \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len    The IV length for ciphers with variable-size IV.\n *                  This parameter is discarded by ciphers with fixed-size IV.\n *\n * \\return          \\c 0 on success.\n * \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                  parameter-verification failure.\n */\nint mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,\n                   const unsigned char *iv, size_t iv_len );\n\n/**\n * \\brief         This function resets the cipher state.\n *\n * \\param ctx     The generic cipher context.\n *\n * \\return        \\c 0 on success.\n * \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                parameter-verification failure.\n */\nint mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx );\n\n#if defined(MBEDTLS_GCM_C)\n/**\n * \\brief               This function adds additional data for AEAD ciphers.\n *                      Only supported with GCM. Must be called\n *                      exactly once, after mbedtls_cipher_reset().\n *\n * \\param ctx           The generic cipher context.\n * \\param ad            The additional data to use.\n * \\param ad_len        the Length of \\p ad.\n *\n * \\return              \\c 0 on success.\n * \\return              A specific error code on failure.\n */\nint mbedtls_cipher_update_ad( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *ad, size_t ad_len );\n#endif /* MBEDTLS_GCM_C */\n\n/**\n * \\brief               The generic cipher update function. It encrypts or\n *                      decrypts using the given cipher context. Writes as\n *                      many block-sized blocks of data as possible to output.\n *                      Any data that cannot be written immediately is either\n *                      added to the next block, or flushed when\n *                      mbedtls_cipher_finish() is called.\n *                      Exception: For MBEDTLS_MODE_ECB, expects a single block\n *                      in size. For example, 16 Bytes for AES.\n *\n * \\note                If the underlying cipher is used in GCM mode, all calls\n *                      to this function, except for the last one before\n *                      mbedtls_cipher_finish(), must have \\p ilen as a\n *                      multiple of the block size of the cipher.\n *\n * \\param ctx           The generic cipher context.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data. Must be able to hold at\n *                      least \\p ilen + block_size. Must not be the same buffer\n *                      as input.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an\n *                      unsupported mode for a cipher.\n * \\return              A cipher-specific error code on failure.\n */\nint mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen );\n\n/**\n * \\brief               The generic cipher finalization function. If data still\n *                      needs to be flushed from an incomplete block, the data\n *                      contained in it is padded to the size of\n *                      the last block, and written to the \\p output buffer.\n *\n * \\param ctx           The generic cipher context.\n * \\param output        The buffer to write data to. Needs block_size available.\n * \\param olen          The length of the data written to the \\p output buffer.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n *                      expecting a full block but not receiving one.\n * \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n *                      while decrypting.\n * \\return              A cipher-specific error code on failure.\n */\nint mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,\n                   unsigned char *output, size_t *olen );\n\n#if defined(MBEDTLS_GCM_C)\n/**\n * \\brief               This function writes a tag for AEAD ciphers.\n *                      Only supported with GCM.\n *                      Must be called after mbedtls_cipher_finish().\n *\n * \\param ctx           The generic cipher context.\n * \\param tag           The buffer to write the tag to.\n * \\param tag_len       The length of the tag to write.\n *\n * \\return              \\c 0 on success.\n * \\return              A specific error code on failure.\n */\nint mbedtls_cipher_write_tag( mbedtls_cipher_context_t *ctx,\n                      unsigned char *tag, size_t tag_len );\n\n/**\n * \\brief               This function checks the tag for AEAD ciphers.\n *                      Only supported with GCM.\n *                      Must be called after mbedtls_cipher_finish().\n *\n * \\param ctx           The generic cipher context.\n * \\param tag           The buffer holding the tag.\n * \\param tag_len       The length of the tag to check.\n *\n * \\return              \\c 0 on success.\n * \\return              A specific error code on failure.\n */\nint mbedtls_cipher_check_tag( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *tag, size_t tag_len );\n#endif /* MBEDTLS_GCM_C */\n\n/**\n * \\brief               The generic all-in-one encryption/decryption function,\n *                      for all ciphers except AEAD constructs.\n *\n * \\param ctx           The generic cipher context.\n * \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len        The IV length for ciphers with variable-size IV.\n *                      This parameter is discarded by ciphers with fixed-size\n *                      IV.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data. Must be able to hold at\n *                      least \\p ilen + block_size. Must not be the same buffer\n *                      as input.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n *\n * \\note                Some ciphers do not use IVs nor nonce. For these\n *                      ciphers, use \\p iv = NULL and \\p iv_len = 0.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n *                      expecting a full block but not receiving one.\n * \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n *                      while decrypting.\n * \\return              A cipher-specific error code on failure.\n */\nint mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen );\n\n#if defined(MBEDTLS_CIPHER_MODE_AEAD)\n/**\n * \\brief               The generic autenticated encryption (AEAD) function.\n *\n * \\param ctx           The generic cipher context.\n * \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len        The IV length for ciphers with variable-size IV.\n *                      This parameter is discarded by ciphers with fixed-size IV.\n * \\param ad            The additional data to authenticate.\n * \\param ad_len        The length of \\p ad.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data.\n *                      Must be able to hold at least \\p ilen.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n * \\param tag           The buffer for the authentication tag.\n * \\param tag_len       The desired length of the authentication tag.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              A cipher-specific error code on failure.\n */\nint mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         unsigned char *tag, size_t tag_len );\n\n/**\n * \\brief               The generic autenticated decryption (AEAD) function.\n *\n * \\note                If the data is not authentic, then the output buffer\n *                      is zeroed out to prevent the unauthentic plaintext being\n *                      used, making this interface safer.\n *\n * \\param ctx           The generic cipher context.\n * \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len        The IV length for ciphers with variable-size IV.\n *                      This parameter is discarded by ciphers with fixed-size IV.\n * \\param ad            The additional data to be authenticated.\n * \\param ad_len        The length of \\p ad.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data.\n *                      Must be able to hold at least \\p ilen.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n * \\param tag           The buffer holding the authentication tag.\n * \\param tag_len       The length of the authentication tag.\n *\n * \\return              \\c 0 on success.\n * \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n *                      parameter-verification failure.\n * \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic.\n * \\return              A cipher-specific error code on failure.\n */\nint mbedtls_cipher_auth_decrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         const unsigned char *tag, size_t tag_len );\n#endif /* MBEDTLS_CIPHER_MODE_AEAD */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* MBEDTLS_CIPHER_H */\n","/**\n *  @file LoRaPHYEU868.cpp\n *\n *  @brief Implements LoRaPHY for European 868 MHz band\n *\n *  \\code\n *   ______                              _\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *   (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n */\n\n#include \"LoRaPHYEU868.h\"\n#include \"lora_phy_ds.h\"\n\n/*!\n * Number of default channels\n */\n#define EU868_NUMB_DEFAULT_CHANNELS                 3\n\n/*!\n * Number of channels to apply for the CF list\n */\n#define EU868_NUMB_CHANNELS_CF_LIST                 5\n\n/*!\n * Minimal datarate that can be used by the node\n */\n#define EU868_TX_MIN_DATARATE                       DR_0\n\n/*!\n * Maximal datarate that can be used by the node\n */\n#define EU868_TX_MAX_DATARATE                       DR_7\n\n/*!\n * Minimal datarate that can be used by the node\n */\n#define EU868_RX_MIN_DATARATE                       DR_0\n\n/*!\n * Maximal datarate that can be used by the node\n */\n#define EU868_RX_MAX_DATARATE                       DR_7\n\n/*!\n * Default datarate used by the node\n */\n#define EU868_DEFAULT_DATARATE                      DR_0\n\n#define EU868_DEFAULT_MAX_DATARATE                  DR_5\n\n/*!\n * Minimal Rx1 receive datarate offset\n */\n#define EU868_MIN_RX1_DR_OFFSET                     0\n\n/*!\n * Maximal Rx1 receive datarate offset\n */\n#define EU868_MAX_RX1_DR_OFFSET                     5\n\n/*!\n * Default Rx1 receive datarate offset\n */\n#define EU868_DEFAULT_RX1_DR_OFFSET                 0\n\n/*!\n * Minimal Tx output power that can be used by the node\n */\n#define EU868_MIN_TX_POWER                          TX_POWER_7\n\n/*!\n * Maximal Tx output power that can be used by the node\n */\n#define EU868_MAX_TX_POWER                          TX_POWER_0\n\n/*!\n * Default Tx output power used by the node\n */\n#define EU868_DEFAULT_TX_POWER                      TX_POWER_0\n\n/*!\n * Default Max EIRP\n */\n#define EU868_DEFAULT_MAX_EIRP                      16.0f\n\n/*!\n * Default antenna gain\n */\n#define EU868_DEFAULT_ANTENNA_GAIN                  2.15f\n\n/*!\n * ADR Ack limit\n */\n#define EU868_ADR_ACK_LIMIT                         64\n\n/*!\n * ADR Ack delay\n */\n#define EU868_ADR_ACK_DELAY                         32\n\n/*!\n * Enabled or disabled the duty cycle\n */\n#define EU868_DUTY_CYCLE_ENABLED                    1\n\n/*!\n * Maximum RX window duration\n */\n#define EU868_MAX_RX_WINDOW                         3000\n\n/*!\n * Receive delay 1\n */\n#define EU868_RECEIVE_DELAY1                        1000\n\n/*!\n * Receive delay 2\n */\n#define EU868_RECEIVE_DELAY2                        2000\n\n/*!\n * Join accept delay 1\n */\n#define EU868_JOIN_ACCEPT_DELAY1                    5000\n\n/*!\n * Join accept delay 2\n */\n#define EU868_JOIN_ACCEPT_DELAY2                    6000\n\n/*!\n * Maximum frame counter gap\n */\n#define EU868_MAX_FCNT_GAP                          16384\n\n/*!\n * Ack timeout\n */\n#define EU868_ACKTIMEOUT                            2000\n\n/*!\n * Random ack timeout limits\n */\n#define EU868_ACK_TIMEOUT_RND     1000\n\n#if ( EU868_DEFAULT_DATARATE > DR_5 )\n#error \"A default DR higher than DR_5 may lead to connectivity loss.\"\n#endif\n\n/*!\n * Second reception window channel frequency definition.\n */\n#define EU868_RX_WND_2_FREQ       869525000\n\n/*!\n * Second reception window channel datarate definition.\n */\n#define EU868_RX_WND_2_DR          DR_0\n\n/*!\n * Band 0 definition\n * { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND0 = {100 , EU868_MAX_TX_POWER, 0, 0, 0,865000000, 868000000}; //  1.0 %\n/*!\n * Band 1 definition\n * { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND1 = {100 , EU868_MAX_TX_POWER, 0, 0, 0, 868100000, 868600000}; //  1.0 %\n\n/*!\n * Band 2 definition\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND2 = {1000, EU868_MAX_TX_POWER, 0, 0, 0, 868700000, 869200000}; //  0.1 %\n\n/*!\n * Band 3 definition\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND3 = {10  , EU868_MAX_TX_POWER, 0, 0, 0, 869400000, 869650000}; // 10.0 %\n\n/*!\n * Band 4 definition\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND4 = {100 , EU868_MAX_TX_POWER, 0, 0, 0, 869700000, 870000000}; //  1.0 %\n\n/*!\n * Band 5 definition - It's actually a sub part of Band 2\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND5 = {1000, EU868_MAX_TX_POWER, 0, 0, 0, 863000000, 865000000}; //  0.1 %\n\n/*!\n * LoRaMac default channel 1\n * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }\n */\nstatic const channel_params_t EU868_LC1 = {868100000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1};\n\n/*!\n * LoRaMac default channel 2\n * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }\n */\nstatic const channel_params_t EU868_LC2 = {868300000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1};\n\n/*!\n * LoRaMac default channel 3\n * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }\n */\nstatic const channel_params_t EU868_LC3 = {868500000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1};\n\n/*!\n * LoRaMac channels which are allowed for the join procedure\n */\n#define EU868_JOIN_CHANNELS        (uint16_t)(LC(1) | LC(2) | LC(3))\n\n/*!\n * Data rates table definition\n */\nstatic const uint8_t datarates_EU868[]  = {12, 11, 10,  9,  8,  7,  7, 50};\n\n/*!\n * Bandwidths table definition in Hz\n */\nstatic const uint32_t bandwidths_EU868[] = {125000, 125000, 125000, 125000, 125000, 125000, 250000, 0};\n\n/*!\n * Maximum payload with respect to the datarate index. Cannot operate with repeater.\n */\nstatic const uint8_t max_payloads_EU868[] = {51, 51, 51, 115, 242, 242, 242, 242};\n\n/*!\n * Maximum payload with respect to the datarate index. Can operate with repeater.\n */\nstatic const uint8_t max_payloads_repeater_EU868[] = {51, 51, 51, 115, 222, 222, 222, 222};\n\nLoRaPHYEU868::LoRaPHYEU868(LoRaWANTimeHandler &lora_time)\n    : LoRaPHY(lora_time)\n{\n    bands[0] = EU868_BAND0;\n    bands[1] = EU868_BAND1;\n    bands[2] = EU868_BAND2;\n    bands[3] = EU868_BAND3;\n    bands[4] = EU868_BAND4;\n    bands[5] = EU868_BAND5;\n\n    // Default Channels are always enabled, rest will be added later\n    channels[0] = EU868_LC1;\n    channels[0].band = 1;\n    channels[1] = EU868_LC2;\n    channels[1].band = 1;\n    channels[2] = EU868_LC3;\n    channels[2].band = 1;\n\n    // Initialize the channels default mask\n    default_channel_mask[0] = LC(1) + LC(2) + LC(3);\n    // Update the channels mask\n    copy_channel_mask(channel_mask, default_channel_mask, 1);\n\n    // set default channels\n    phy_params.channels.channel_list = channels;\n    phy_params.channels.channel_list_size = EU868_MAX_NB_CHANNELS;\n    phy_params.channels.mask = channel_mask;\n    phy_params.channels.default_mask = default_channel_mask;\n    phy_params.channels.mask_size = EU868_CHANNEL_MASK_SIZE;\n\n    // set bands for EU868 spectrum\n    phy_params.bands.table = (void *) bands;\n    phy_params.bands.size = EU868_MAX_NB_BANDS;\n\n    // set bandwidths available in EU868 spectrum\n    phy_params.bandwidths.table = (void *) bandwidths_EU868;\n    phy_params.bandwidths.size = 8;\n\n    // set data rates available in EU868 spectrum\n    phy_params.datarates.table = (void *) datarates_EU868;\n    phy_params.datarates.size = 8;\n\n    // set payload sizes with respect to data rates\n    phy_params.payloads.table = (void *) max_payloads_EU868;\n    phy_params.payloads.size = 8;\n    phy_params.payloads_with_repeater.table = (void *) max_payloads_repeater_EU868;\n    phy_params.payloads_with_repeater.size = 8;\n\n    // dwell time setting\n    phy_params.ul_dwell_time_setting = 0;\n    phy_params.dl_dwell_time_setting = 0;\n\n    // set initial and default parameters\n    phy_params.duty_cycle_enabled = EU868_DUTY_CYCLE_ENABLED;\n    phy_params.accept_tx_param_setup_req = true;\n    phy_params.fsk_supported = true;\n    phy_params.cflist_supported = true;\n    phy_params.dl_channel_req_supported = true;\n    phy_params.custom_channelplans_supported = true;\n    phy_params.default_channel_cnt = EU868_NUMB_DEFAULT_CHANNELS;\n    phy_params.max_channel_cnt = EU868_MAX_NB_CHANNELS;\n    phy_params.cflist_channel_cnt = EU868_NUMB_CHANNELS_CF_LIST;\n    phy_params.min_tx_datarate = EU868_TX_MIN_DATARATE;\n    phy_params.max_tx_datarate = EU868_TX_MAX_DATARATE;\n    phy_params.min_rx_datarate = EU868_RX_MIN_DATARATE;\n    phy_params.max_rx_datarate = EU868_RX_MAX_DATARATE;\n    phy_params.default_datarate = EU868_DEFAULT_DATARATE;\n    phy_params.default_max_datarate = EU868_DEFAULT_MAX_DATARATE;\n    phy_params.min_rx1_dr_offset = EU868_MIN_RX1_DR_OFFSET;\n    phy_params.max_rx1_dr_offset = EU868_MAX_RX1_DR_OFFSET;\n    phy_params.default_rx1_dr_offset = EU868_DEFAULT_RX1_DR_OFFSET;\n    phy_params.min_tx_power = EU868_MIN_TX_POWER;\n    phy_params.max_tx_power = EU868_MAX_TX_POWER;\n    phy_params.default_tx_power = EU868_DEFAULT_TX_POWER;\n    phy_params.default_max_eirp = EU868_DEFAULT_MAX_EIRP;\n    phy_params.default_antenna_gain = EU868_DEFAULT_ANTENNA_GAIN;\n    phy_params.adr_ack_limit = EU868_ADR_ACK_LIMIT;\n    phy_params.adr_ack_delay = EU868_ADR_ACK_DELAY;\n    phy_params.max_rx_window = EU868_MAX_RX_WINDOW;\n    phy_params.recv_delay1 = EU868_RECEIVE_DELAY1;\n    phy_params.recv_delay2 = EU868_RECEIVE_DELAY2;\n    phy_params.join_channel_mask = EU868_JOIN_CHANNELS;\n    phy_params.join_accept_delay1 = EU868_JOIN_ACCEPT_DELAY1;\n    phy_params.join_accept_delay2 = EU868_JOIN_ACCEPT_DELAY2;\n    phy_params.max_fcnt_gap = EU868_MAX_FCNT_GAP;\n    phy_params.ack_timeout = EU868_ACKTIMEOUT;\n    phy_params.ack_timeout_rnd = EU868_ACK_TIMEOUT_RND;\n    phy_params.rx_window2_datarate = EU868_RX_WND_2_DR;\n    phy_params.rx_window2_frequency = EU868_RX_WND_2_FREQ;\n}\n\nLoRaPHYEU868::~LoRaPHYEU868()\n{\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","#include \"mbed.h\"\n#include \"mbed_trace.h\"\n#include \"mbed_events.h\"\n#include \"LoRaWANInterface.h\"\n#include \"Sht31.h\"\n#include \"SX1276_LoRaRadio.h\"\n\n// ABP Credentials - please copy them from the TTN Console\nstatic uint32_t devaddr = 0x0;\nstatic uint8_t nwk_s_key[] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };\nstatic uint8_t app_s_key[] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };\n\n\n// The port we're sending and receiving on\n#define MBED_CONF_LORA_APP_PORT     15\n\n// Peripherals (LoRa radio, temperature sensor and button)\nSX1276_LoRaRadio radio(D11, D12, D13, D10, A0, D2, D3, D4, D5, D8, D9, NC, NC, NC, NC, A4, NC, NC);\nSht31 sht31(I2C_SDA, I2C_SCL);\nInterruptIn btn(BUTTON1);\n\n// EventQueue is required to dispatch events around\nstatic EventQueue ev_queue;\n\n// Constructing Mbed LoRaWANInterface and passing it down the radio object.\nstatic LoRaWANInterface lorawan(radio);\n\n// Application specific callbacks\nstatic lorawan_app_callbacks_t callbacks;\n\n// LoRaWAN stack event handler\nstatic void lora_event_handler(lorawan_event_t event);\n\n// Send a message over LoRaWAN\nstatic void send_message() {\n    uint8_t tx_buffer[50] = { 0 };\n\n    // Sending strings over LoRaWAN is not recommended\n    sprintf((char*) tx_buffer, \"Temperature = %3.1f\",\n                                   sht31.readTemperature());\n\n    int packet_len = strlen((char*) tx_buffer);\n\n    printf(\"Sending %d bytes: \\\"%s\\\"\\n\", packet_len, tx_buffer);\n\n    // for some reason send() returns -1... I cannot find out why, the stack returns the right number. I feel that this is some weird Emscripten quirk\n    int16_t retcode = lorawan.send(MBED_CONF_LORA_APP_PORT, tx_buffer, packet_len, MSG_UNCONFIRMED_FLAG);\n\n    if (retcode < 0) {\n        retcode == LORAWAN_STATUS_WOULD_BLOCK ? printf(\"send - duty cycle violation\\n\")\n                : printf(\"send() - Error code %d\\n\", retcode);\n        return;\n    }\n\n    printf(\"%d bytes scheduled for transmission\\n\", retcode);\n}\n\nint main() {\n    if (devaddr == 0x0) {\n        printf(\"Set your LoRaWAN credentials first!\\n\");\n        return -1;\n    }\n\n    printf(\"Press BUTTON1 to send the current value of the temperature sensor!\\n\");\n\n    if (lorawan.initialize(&ev_queue) != LORAWAN_STATUS_OK) {\n        printf(\"LoRa initialization failed!\\n\");\n        return -1;\n    }\n\n    // Enable trace output for this demo, so we can see what the LoRaWAN stack does\n    mbed_trace_init();\n\n    // Fire a message when the button is pressed\n    btn.fall(ev_queue.event(&send_message));\n\n    // prepare application callbacks\n    callbacks.events = mbed::callback(lora_event_handler);\n    lorawan.add_app_callbacks(&callbacks);\n\n    // Disable adaptive data rating\n    if (lorawan.disable_adaptive_datarate() != LORAWAN_STATUS_OK) {\n        printf(\"disable_adaptive_datarate failed!\\n\");\n        return -1;\n    }\n\n    lorawan.set_datarate(5); // SF7BW125\n\n    lorawan_connect_t connect_params;\n    connect_params.connect_type = LORAWAN_CONNECTION_ABP;\n    connect_params.connection_u.abp.dev_addr = devaddr;\n    connect_params.connection_u.abp.nwk_skey = nwk_s_key;\n    connect_params.connection_u.abp.app_skey = app_s_key;\n\n    lorawan_status_t retcode = lorawan.connect(connect_params);\n\n    if (retcode == LORAWAN_STATUS_OK ||\n        retcode == LORAWAN_STATUS_CONNECT_IN_PROGRESS) {\n    } else {\n        printf(\"Connection error, code = %d\\n\", retcode);\n        return -1;\n    }\n\n    printf(\"Connection - In Progress ...\\r\\n\");\n\n    // make your event queue dispatching events forever\n    ev_queue.dispatch_forever();\n\n    return 0;\n}\n\n// This is called from RX_DONE, so whenever a message came in\nstatic void receive_message()\n{\n    uint8_t rx_buffer[50] = { 0 };\n    int16_t retcode;\n    retcode = lorawan.receive(MBED_CONF_LORA_APP_PORT, rx_buffer,\n                              sizeof(rx_buffer),\n                              MSG_CONFIRMED_FLAG|MSG_UNCONFIRMED_FLAG);\n\n    if (retcode < 0) {\n        printf(\"receive() - Error code %d\\n\", retcode);\n        return;\n    }\n\n    printf(\"Data received on port %d (length %d): \", MBED_CONF_LORA_APP_PORT, retcode);\n\n    for (uint8_t i = 0; i < retcode; i++) {\n        printf(\"%02x \", rx_buffer[i]);\n    }\n    printf(\"\\n\");\n}\n\n// Event handler\nstatic void lora_event_handler(lorawan_event_t event) {\n    switch (event) {\n        case CONNECTED:\n            printf(\"Connection - Successful\\n\");\n            break;\n        case DISCONNECTED:\n            ev_queue.break_dispatch();\n            printf(\"Disconnected Successfully\\n\");\n            break;\n        case TX_DONE:\n            printf(\"Message Sent to Network Server\\n\");\n            break;\n        case TX_TIMEOUT:\n        case TX_ERROR:\n        case TX_CRYPTO_ERROR:\n        case TX_SCHEDULING_ERROR:\n            printf(\"Transmission Error - EventCode = %d\\n\", event);\n            break;\n        case RX_DONE:\n            printf(\"Received message from Network Server\\n\");\n            receive_message();\n            break;\n        case RX_TIMEOUT:\n        case RX_ERROR:\n            printf(\"Error in reception - Code = %d\\n\", event);\n            break;\n        case JOIN_FAILURE:\n            printf(\"OTAA Failed - Check Keys\\n\");\n            break;\n        default:\n            MBED_ASSERT(\"Unknown Event\");\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n#include \"us_ticker_api.h\"\n\nvoid us_ticker_init(void)\n{\n\n}\n\n\nuint32_t us_ticker_read()\n{\n    return 0;\n}\n\nvoid us_ticker_disable_interrupt(void)\n{\n\n}\n\nvoid us_ticker_clear_interrupt(void)\n{\n\n}\n\nvoid us_ticker_set_interrupt(timestamp_t timestamp)\n{\n}\n\nvoid us_ticker_fire_interrupt(void)\n{\n}\n","/*\n * Common and shared functions used by multiple modules in the Mbed TLS\n * library.\n *\n *  Copyright (C) 2018, Arm Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of Mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include \"mbedtls/platform_util.h\"\n\n#include <stddef.h>\n#include <string.h>\n\n#if !defined(MBEDTLS_PLATFORM_ZEROIZE_ALT)\n/*\n * This implementation should never be optimized out by the compiler\n *\n * This implementation for mbedtls_platform_zeroize() was inspired from Colin\n * Percival's blog article at:\n *\n * http://www.daemonology.net/blog/2014-09-04-how-to-zero-a-buffer.html\n *\n * It uses a volatile function pointer to the standard memset(). Because the\n * pointer is volatile the compiler expects it to change at\n * any time and will not optimize out the call that could potentially perform\n * other operations on the input buffer instead of just setting it to 0.\n * Nevertheless, as pointed out by davidtgoldblatt on Hacker News\n * (refer to http://www.daemonology.net/blog/2014-09-05-erratum.html for\n * details), optimizations of the following form are still possible:\n *\n * if( memset_func != memset )\n *     memset_func( buf, 0, len );\n *\n * Note that it is extremely difficult to guarantee that\n * mbedtls_platform_zeroize() will not be optimized out by aggressive compilers\n * in a portable way. For this reason, Mbed TLS also provides the configuration\n * option MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure\n * mbedtls_platform_zeroize() to use a suitable implementation for their\n * platform and needs.\n */\nstatic void * (* const volatile memset_func)( void *, int, size_t ) = memset;\n\nvoid mbedtls_platform_zeroize( void *buf, size_t len )\n{\n    memset_func( buf, 0, len );\n}\n#endif /* MBEDTLS_PLATFORM_ZEROIZE_ALT */\n","#include \"mbed_critical.h\"\n\nbool core_util_are_interrupts_enabled(void) {\n    return true;\n}\n\nbool core_util_is_isr_active(void) {\n    return false;\n}\n\nvoid core_util_critical_section_enter(void) {}\n\nvoid core_util_critical_section_exit(void) {}\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/***************************************************\r\n  This is a library for the SHT31 Digital Humidity & Temp Sht31\r\n\r\n  Designed specifically to work with the SHT31 Digital Sht31 from Adafruit\r\n  ----> https://www.adafruit.com/products/2857\r\n\r\n  These displays use I2C to communicate, 2 pins are required to\r\n  interface\r\n  Adafruit invests time and resources providing this open source code,\r\n  please support Adafruit and open-source hardware by purchasing\r\n  products from Adafruit!\r\n\r\n  Written by Limor Fried/Ladyada for Adafruit Industries.\r\n  BSD license, all text above must be included in any redistribution\r\n ****************************************************/\r\n\r\n#include \"Sht31.h\"\r\n#include \"mbed.h\"\r\n#include \"emscripten.h\"\r\n\r\nSht31::Sht31(PinName sda, PinName scl) {\r\n    EM_ASM_({\r\n        window.MbedJSHal.sht31.init($0, $1, $2);\r\n    }, this, sda, scl);\r\n}\r\n\r\nfloat Sht31::readTemperature(void) {\r\n    int temp = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_temperature($0);\r\n    }, this);\r\n    return ((float)temp) / 100.0f;\r\n}\r\n\r\nfloat Sht31::readHumidity(void) {\r\n    int humidity = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_humidity($0);\r\n    }, this);\r\n    return ((float)humidity) / 100.0f;\r\n}\r\n"]}