{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaWANStack.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMac.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/system/lorawan_data_structures.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaRadio.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/aes.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/phy/LoRaPHY.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/phy/LoRaPHYEU868.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/system/LoRaWANTimer.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/cipher.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/inc/mbedtls/cipher.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/cipher_wrap.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/cmac.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/ccm.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacCommand.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Ticker.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/lora-radio-drv/SX1276_LoRaRadio.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timeout.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/InterruptIn.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacMib.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacMlme.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalInOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_critical.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_retarget.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/Sht31/Sht31.cpp","/Users/janjon01/repos/mbed-simulator/demos/lorawan/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timeout.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_irq_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/us_ticker.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue_posix.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/LoRaWANInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/hal/mbed_ticker_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacChannelPlan.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/mbedtls/src/gcm.c","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/math.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacCrypto.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/lorawan/lorastack/mac/LoRaMacMcps.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timer.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/TimerEvent.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/hal/mbed_sleep_manager.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/hal/mbed_us_ticker_api.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;AAMA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;;;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;AAEA;AAEA;;AACA;;AAAA;AADA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;;AAEA;AAAA;;;AACA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AADA;;AAEA;AAAA;AAAA;AAAA;AA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;AwB9cA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkBtLA;;;;;AjCgGA;AACA;;;;;;;;;;;;;;;;;;;;;;;AH2SA;AACA;AADA;;;;;;;;;;;;;;APvOA;;;AAJA;;AACA;;;;;;;;;AsChJA;;;;;;;;;;;AAPA;;;;;;ADnIA;AACA;AACA;AACA;;;;;;ACoFA;;;;;;;;;;;;;;;;;;;;;;;;;;ArCy7BA;AAAA;;;;;;AqC97BA;;;;;;;;;;;;AA/BA;AACA;;;;;;;;;;;;;ArCosBA;;;;;;;;;;;;;;AehrBA;;;;;;;;;;;;;;;Ad2iCA;AAAA;;AAHA;;;;;AoC7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AALA;;;;;;;;;;;;AAeA;;;;;AAeA;;;;;;A/B6ZA;;;;A+BjbA;;;;;A/BugBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALjGA;;AAGA;;AAAA;;;;;;;;;;;AKrgBA;;;;;;;;;;;;;;;;;;;;;;;;;;A+BqHA;;;;;;;;;;;;;;;;;;;;;;;AvB1DA;;;;;AA8OA;;;;;;;;;;AA5BA;;;;;;;;;;;;;;;;;;;;;;;;;;ANvRA;;;;AMmRA;;;;;;;;;;;;;;;;;AftOA;;;;;;;;;;;;;;;;;AsBmFA;;;;;;;;;;;;;;;;;;AtB4lBA;;;;;AuCjpBA;;;;;;;;;;;;;AnBrEA;;;;;;;;;;;;;;;AbwfA;;;;;APoJA;;;;;;;;AC1bA;;;;;;;;;;;;ACu2BA;;;;;AoCn/BA;;;;;;;;;;;;;ArC6IA;;;;AC6nBA;AAAA;;;;;;AAxuBA;AAEA;AAFA;;;;;;AOzHA;;;;;;;;;;;;;;;AIsCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXkHA;;;;;;;;;;;AK/EA;;;;;;;;ALySA;;;;;;AIiaA;;;;;;;;;;;;;;;;;;;;;;;AO7uBA;;;;;;;;;;;;A2BlCA;;;;;AlC8uBA;;;;;AmB1rBA;;;;;;;;;;;;;;AlBgBA;;;;;;;;;;;;;;;;;;;;;;AsChEA;;;;;;;A3CgzBA;;;;AFsBA;;;;;AM3DA;;;;;;AClNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE3jBA;;;;ATgDA;;;;;AewRA;;;;;;;;;;AwB5TA;;;;;;;;;;;;;;;AAkGA;;;;;;;;;AjBhFA;;;;;;;;;;;;;ArB+LA;;;;AcCA;;;;;;;;;;;;;;;;;;;;AyBzMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Af+JA;;;;;;;;;;;;;;;;AFnKA;;;;;AoBqKA;;;;;;;;;;;;;;;;;;;;A9BtJA;;;;;;;;;;AShCA;;;;;;;;;;;;;;;;;;Af4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQ+WA;;;;AF3WA;;;;;;;;;;;;;;;;;;ANyiBA;;;;AL3FA;;;;AQlFA;;;;;;;;;;;;;;;;;;;;;;;;;;;AG5XA;;;;;A4BkMA;;;;;A1B1BA;;;;AR9LA;AACA;;;;;;;;;;;;;;;;;;;AD+pBA;;;;;;;;;ASxdA;;;;;;;;;;;;;;;;;;;;;;;;;;;ARkbA;;;;A+BxiBA;;;;;;;;;;;;AvBkGA;;;;;;;;;AAKA;;;;;AA5HA;;;;AP8OA;AADA;;;;;AP+TA;;;;;;;;;;;;;;;;;;;;;;;;;;;AMlFA;;;;;;;;;;;;;;;;;;;;;;AQpVA;;;;;AAxFA;;;;;AA8DA;;;;;;;;AEgLA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;AFzOA;;;;ARmbA;;;;;;;;;;;;;;;;;;;;;AkB/HA;;;;;;;;;;;;;;;;;;;;;AlBoIA;;;;;;;;;AkB1HA;;;;;AlB+EA;;;;;AUvRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AV4RA;;;;AwC7gBA;;;;;A9ByPA;;;;AVuUA;;;;;;;;AAKA;;;;;;;;AQrcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF8JA;;;;;A8B5OA;;;;;;;;;;;;;;;;;;;;AjC0FA;;;;;;;;;;A2BlIA;;;;;;;;;;AAZA;;;;;;;;AtBSA;;;;;;;;;AsBDA;;;;;;;;;;;;;A5BrBA;;;;;A+BIA;;;;;;;;;AIkBA;;;;;;;;;;;;A3BuVA;;;;;;;;;;;;AADA;;;;A8BzVA;;;;AxBIA;;;;AjBsaA;;;;;;;;;;;;;AUhZA;;;;;;;;;;;;;AOjBA;;;;;;;;AfySA;;;;;;;;;;;;;;;;;Ae/TA;;;;;;;;;AqBqBA;;;;AtBrBA;;;;;;;;;;;;;;;;;;;;;;;;;AgBiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArCuNA;AAAA;;;;;;;;;;;;;;;;;;;;;AgB8HA;;;;;AAJA;;;;;AAJA;;;;;AAFA;;;;;AADA;;;;;AAFA;;;;AVrUA;;;;;;;;;;;;;;;;;AuCZA;;;;;;;;;;;;;;;;;;;;;A7BgVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;;AADA;;;;AAHA;;;;;;;;;;;;AAiCA;;;;;;;;;;;;;;;;AApDA;;;;AACA;;;;AAAA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;AAFA;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBwUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiBiZA;;;;AAAA;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtYA;;;;;;;;;;;;;;;;;;;;AAqlBA;;;;;;;;;;;;;;;;;;;;;;;;AA9NA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAHA;;;;AAvXA;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwXA;;;;AAAA;;;;AArYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AARA;;;;;;;;;;;;;;;;;;;;AAwyBA;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5yBA;;;;AAHA","file":"/Users/janjon01/repos/mbed-simulator/out/lorawan.js","sourcesContent":["/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <string.h>\n#include <stdlib.h>\n#include \"platform/Callback.h\"\n#include \"events/EventQueue.h\"\n#include \"lorawan/LoRaWANStack.h\"\n#if defined(FEATURE_COMMON_PAL)\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LSTK\"\n#else\n#define tr_debug(...) void(0) //dummies if feature common pal is not added\n#define tr_info(...)  printf(\"[LSTK][INF] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_error(...) printf(\"[LSTK][ERR] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_warn(...) printf(\"[LSTK][WRN] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#endif //defined(FEATURE_COMMON_PAL)\n\n#define INVALID_PORT                0xFF\n#define MAX_CONFIRMED_MSG_RETRIES   255\n\nusing namespace mbed;\nusing namespace events;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    /**\n     *\n     * User application data buffer size if compliance test is used\n     */\n    #if (MBED_CONF_LORA_PHY == 0 || MBED_CONF_LORA_PHY == 4 || MBED_CONF_LORA_PHY == 6 || MBED_CONF_LORA_PHY == 7)\n        #define LORAWAN_COMPLIANCE_TEST_DATA_SIZE                  16\n    #elif (MBED_CONF_LORA_PHY == 1 || MBED_CONF_LORA_PHY == 2 || MBED_CONF_LORA_PHY == 8 || MBED_CONF_LORA_PHY == 9)\n        #define LORAWAN_COMPLIANCE_TEST_DATA_SIZE                  11\n    #else\n        #error \"Must set LoRa PHY layer parameters.\"\n    #endif\n#endif\n\n/*****************************************************************************\n * Private Member Functions                                                  *\n ****************************************************************************/\nbool LoRaWANStack::is_port_valid(uint8_t port)\n{\n    //Application should not use reserved and illegal port numbers.\n    if (port >= 224 || port == 0) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nlorawan_status_t LoRaWANStack::set_application_port(uint8_t port)\n{\n    if (is_port_valid(port)) {\n        _app_port = port;\n        return LORAWAN_STATUS_OK;\n    }\n\n    return LORAWAN_STATUS_PORT_INVALID;\n}\n\n/*****************************************************************************\n * Constructor and destructor                                                *\n ****************************************************************************/\nLoRaWANStack::LoRaWANStack()\n: _loramac(_lora_time), _lora_phy(_lora_time),\n  _device_current_state(DEVICE_STATE_NOT_INITIALIZED), _mac_handlers(NULL),\n  _num_retry(1), _app_port(INVALID_PORT), _duty_cycle_on(MBED_CONF_LORA_DUTY_CYCLE_ON),\n  _queue(NULL)\n{\n#ifdef MBED_CONF_LORA_APP_PORT\n    if (is_port_valid(MBED_CONF_LORA_APP_PORT)) {\n        _app_port = MBED_CONF_LORA_APP_PORT;\n    } else {\n        tr_error(\"User defined port in .json is illegal.\");\n    }\n#endif\n\n     memset(&_lw_session, 0, sizeof(_lw_session));\n     memset(&_tx_msg, 0, sizeof(_tx_msg));\n     memset(&_rx_msg, 0, sizeof(_rx_msg));\n\n     LoRaMacPrimitives.mcps_confirm     = callback(this, &LoRaWANStack::mcps_confirm_handler);\n     LoRaMacPrimitives.mcps_indication  = callback(this, &LoRaWANStack::mcps_indication_handler);\n     LoRaMacPrimitives.mlme_confirm     = callback(this, &LoRaWANStack::mlme_confirm_handler);\n     LoRaMacPrimitives.mlme_indication  = callback(this, &LoRaWANStack::mlme_indication_handler);\n}\n\nLoRaWANStack::~LoRaWANStack()\n{\n}\n\n/*****************************************************************************\n * Public member functions                                                   *\n ****************************************************************************/\nLoRaWANStack& LoRaWANStack::get_lorawan_stack()\n{\n    static LoRaWANStack _lw_stack;\n    return _lw_stack;\n}\n\nradio_events_t *LoRaWANStack::bind_radio_driver(LoRaRadio& radio)\n{\n    // Store pointer to callback routines inside MAC layer (non-IRQ safe)\n    _mac_handlers = _loramac.get_phy_event_handlers();\n    //  passes the reference to radio driver down to PHY layer\n    _lora_phy.set_radio_instance(radio);\n    return _mac_handlers;\n}\n\nlorawan_status_t LoRaWANStack::initialize_mac_layer(EventQueue *queue)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED != _device_current_state)\n    {\n        tr_debug(\"Initialized already\");\n        return LORAWAN_STATUS_OK;\n    }\n\n    tr_debug(\"Initializing MAC layer\");\n\n    //store a pointer to Event Queue\n    _queue = queue;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    _compliance_test.app_data_buffer = compliance_test_buffer;\n#endif\n\n    _lora_time.activate_timer_subsystem(queue);\n    _loramac.initialize(&LoRaMacPrimitives, &_lora_phy, queue);\n\n    loramac_mib_req_confirm_t mib_req;\n\n    mib_req.type = MIB_ADR;\n    mib_req.param.is_adr_enable = MBED_CONF_LORA_ADR_ON;\n    mib_set_request(&mib_req);\n\n    mib_req.type = MIB_PUBLIC_NETWORK;\n    mib_req.param.enable_public_nwk = MBED_CONF_LORA_PUBLIC_NETWORK;\n    mib_set_request(&mib_req);\n\n    // Reset counters to zero. Will change in future with 1.1 support.\n    _lw_session.downlink_counter = 0;\n    _lw_session.uplink_counter = 0;\n\n    // Start loRaWAN state machine.\n    set_device_state(DEVICE_STATE_INIT);\n    return lora_state_machine();\n}\n\nuint16_t LoRaWANStack::check_possible_tx_size(uint16_t size)\n{\n    loramac_tx_info_t tx_info;\n    if (_loramac.query_tx_possible(size, &tx_info) == LORAWAN_STATUS_LENGTH_ERROR) {\n        // Cannot transmit this much. Return how much data can be sent\n        // at the moment\n        return tx_info.max_possible_payload_size;\n    }\n\n    return tx_info.current_payload_size;\n}\n\n/** Hands over the frame to MAC layer\n *\n * \\return          returns the state of the LoRa MAC\n */\nlorawan_status_t LoRaWANStack::send_frame_to_mac()\n{\n    loramac_mcps_req_t mcps_req;\n    lorawan_status_t status;\n    loramac_mib_req_confirm_t mib_get_params;\n\n    mcps_req.type = _tx_msg.type;\n\n    if (MCPS_UNCONFIRMED == mcps_req.type) {\n        mcps_req.f_buffer = _tx_msg.f_buffer;\n        mcps_req.f_buffer_size = _tx_msg.f_buffer_size;\n\n        mcps_req.fport = _tx_msg.fport;\n        mcps_req.nb_trials = 1;\n        mib_get_params.type = MIB_CHANNELS_DATARATE;\n        if(mib_get_request(&mib_get_params) != LORAWAN_STATUS_OK) {\n            tr_debug(\"Couldn't get MIB parameters: Using default data rate\");\n            mcps_req.data_rate = _lora_phy.get_default_tx_datarate();\n        } else {\n            mcps_req.data_rate = mib_get_params.param.channel_data_rate;\n        }\n\n    } else if (mcps_req.type == MCPS_CONFIRMED) {\n        mcps_req.f_buffer = _tx_msg.f_buffer;\n        mcps_req.f_buffer_size = _tx_msg.f_buffer_size;\n        mcps_req.fport = _tx_msg.fport;\n        mcps_req.nb_trials = _tx_msg.nb_trials;\n\n        mib_get_params.type = MIB_CHANNELS_DATARATE;\n        if(mib_get_request(&mib_get_params) != LORAWAN_STATUS_OK) {\n            tr_debug(\"Couldn't get MIB parameters: Using default data rate\");\n            mcps_req.data_rate = _lora_phy.get_default_tx_datarate();\n        } else {\n            mcps_req.data_rate = mib_get_params.param.channel_data_rate;\n        }\n\n    } else if ( mcps_req.type == MCPS_PROPRIETARY) {\n        mcps_req.f_buffer = _tx_msg.f_buffer;\n        mcps_req.f_buffer_size = _tx_msg.f_buffer_size;\n        mcps_req.fport = 0;\n        mcps_req.nb_trials = 1;\n\n        mib_get_params.type = MIB_CHANNELS_DATARATE;\n        if(mib_get_request(&mib_get_params) != LORAWAN_STATUS_OK) {\n            tr_debug(\"Couldn't get MIB parameters: Using default data rate\");\n            mcps_req.data_rate = _lora_phy.get_default_tx_datarate();\n        } else {\n            mcps_req.data_rate = mib_get_params.param.channel_data_rate;\n        }\n\n    } else {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    status = mcps_request_handler(&mcps_req);\n\n    return status;\n}\n\nlorawan_status_t LoRaWANStack::set_confirmed_msg_retry(uint8_t count)\n{\n    if (count >= MAX_CONFIRMED_MSG_RETRIES) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _num_retry = count;\n\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaWANStack::set_device_state(device_states_t new_state)\n{\n    _device_current_state = new_state;\n}\n\n/*!\n * \\brief   MLME-Indication event function\n *\n * \\param   [IN] mlmeIndication - Pointer to the indication structure.\n */\nvoid LoRaWANStack::mlme_indication_handler(loramac_mlme_indication_t *mlmeIndication)\n{\n    switch( mlmeIndication->indication_type )\n    {\n        case MLME_SCHEDULE_UPLINK:\n        {// The MAC signals that we shall provide an uplink as soon as possible\n            // TODO: Sending implementation missing and will be implemented using\n            //       another task.\n            //OnTxNextPacketTimerEvent( );\n            break;\n        }\n        default:\n            break;\n    }\n}\n\nvoid LoRaWANStack::set_lora_callbacks(lorawan_app_callbacks_t *cbs)\n{\n    if (cbs) {\n        if (cbs->events) {\n            _callbacks.events = cbs->events;\n        }\n\n        if (cbs->link_check_resp) {\n            _callbacks.link_check_resp = cbs->link_check_resp;\n        }\n\n        if (cbs->battery_level) {\n            _callbacks.battery_level = cbs->battery_level;\n        }\n    }\n}\n\nlorawan_status_t LoRaWANStack::add_channels(const lorawan_channelplan_t &channel_plan)\n{\n    // If device is not initialized, stop right away\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.add_channel_plan(channel_plan);\n}\n\nlorawan_status_t LoRaWANStack::drop_channel_list()\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED) {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.remove_channel_plan();\n}\n\nlorawan_status_t LoRaWANStack::remove_a_channel(uint8_t channel_id)\n{\n    if (_device_current_state == DEVICE_STATE_NOT_INITIALIZED )\n    {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    return _loramac.remove_single_channel(channel_id);\n}\n\nlorawan_status_t LoRaWANStack::get_enabled_channels(lorawan_channelplan_t& channel_plan)\n{\n    if (_device_current_state == DEVICE_STATE_JOINING\n            || _device_current_state == DEVICE_STATE_NOT_INITIALIZED\n            || _device_current_state == DEVICE_STATE_INIT)\n    {\n        tr_error(\"Cannot get channel plan until Joined!\");\n        return LORAWAN_STATUS_BUSY;\n    }\n\n  return _loramac.get_channel_plan(channel_plan);\n}\n\nlorawan_status_t LoRaWANStack::enable_adaptive_datarate(bool adr_enabled)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state)\n    {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    loramac_mib_req_confirm_t adr_mib_params;\n\n    adr_mib_params.type = MIB_ADR;\n    adr_mib_params.param.is_adr_enable = adr_enabled;\n\n    return mib_set_request(&adr_mib_params);\n}\n\nlorawan_status_t LoRaWANStack::set_channel_data_rate(uint8_t data_rate)\n{\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state)\n    {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    loramac_mib_req_confirm_t mib_params;\n    mib_params.type = MIB_ADR;\n    if (mib_get_request(&mib_params) != LORAWAN_STATUS_OK) {\n        tr_error(\"Cannot set data rate. Please turn off ADR first.\");\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    mib_params.type = MIB_CHANNELS_DATARATE;\n    mib_params.param.channel_data_rate = data_rate;\n\n    return mib_set_request(&mib_params);\n}\n\nvoid LoRaWANStack::commission_device(const lorawan_dev_commission_t &commission_data)\n{\n    _lw_session.connection.connect_type = commission_data.connection.connect_type;\n    _lw_session.downlink_counter = commission_data.downlink_counter;\n    _lw_session.uplink_counter = commission_data.uplink_counter;\n\n    if (commission_data.connection.connect_type == LORAWAN_CONNECTION_OTAA) {\n        _lw_session.connection.connection_u.otaa.app_eui =\n                commission_data.connection.connection_u.otaa.app_eui;\n        _lw_session.connection.connection_u.otaa.app_key =\n                commission_data.connection.connection_u.otaa.app_key;\n        _lw_session.connection.connection_u.otaa.dev_eui =\n                commission_data.connection.connection_u.otaa.dev_eui;\n        _lw_session.connection.connection_u.otaa.nb_trials =\n                commission_data.connection.connection_u.otaa.nb_trials;\n    } else {\n        _lw_session.connection.connection_u.abp.dev_addr =\n                commission_data.connection.connection_u.abp.dev_addr;\n        _lw_session.connection.connection_u.abp.nwk_skey =\n                commission_data.connection.connection_u.abp.nwk_skey;\n        _lw_session.connection.connection_u.abp.app_skey =\n                commission_data.connection.connection_u.abp.app_skey;\n    }\n}\n\n/**\n *\n * Join OTAA\n */\nlorawan_status_t LoRaWANStack::join_request_by_otaa(const lorawan_connect_t &params)\n{\n    lorawan_dev_commission_t commission;\n\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state)\n    {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    tr_debug(\"Initiating OTAA\");\n\n    commission.connection.connect_type = LORAWAN_CONNECTION_OTAA;\n    commission.connection.connection_u.otaa.dev_eui = params.connection_u.otaa.dev_eui;\n    commission.connection.connection_u.otaa.app_eui = params.connection_u.otaa.app_eui;\n    commission.connection.connection_u.otaa.app_key = params.connection_u.otaa.app_key;\n    commission.connection.connection_u.otaa.nb_trials = params.connection_u.otaa.nb_trials;\n\n    // As mentioned in the comment above, in 1.0.2 spec, counters are always set\n    // to zero for new connection. This section is common for both normal and\n    // connection restore at this moment. Will change in future with 1.1 support.\n    commission.downlink_counter = 0;\n    commission.uplink_counter = 0;\n\n    commission_device(commission);\n    set_device_state(DEVICE_STATE_JOINING);\n    return lora_state_machine();\n}\n\n/**\n *\n * Connect ABP\n */\nlorawan_status_t LoRaWANStack::activation_by_personalization(const lorawan_connect_t &params)\n{\n    lorawan_status_t status;\n    lorawan_dev_commission_t commission;\n\n    if (DEVICE_STATE_NOT_INITIALIZED == _device_current_state) {\n        tr_error(\"Stack not initialized!\");\n        return LORAWAN_STATUS_NOT_INITIALIZED;\n    }\n\n    tr_debug(\"Initiating ABP\");\n\n    commission.connection.connect_type = LORAWAN_CONNECTION_ABP;\n    commission.connection.connection_u.abp.dev_addr = params.connection_u.abp.dev_addr;\n    commission.connection.connection_u.abp.nwk_skey = params.connection_u.abp.nwk_skey;\n    commission.connection.connection_u.abp.app_skey = params.connection_u.abp.app_skey;\n\n    // If current state is SHUTDOWN, device may be trying to re-establish\n    // communication. In case of ABP specification is meddled about frame counters.\n    // It says to reset counters to zero but there is no mechanism to tell the\n    // network server that the device was disconnected or restarted.\n    // At the moment, this implementation does not support a non-volatile\n    // memory storage, so we try a last ditch effort here to restore correct\n    // frame counters. If that doesn't work, user must manually reset frame\n    // counters on their network server.\n    commission.downlink_counter = _lw_session.downlink_counter;\n    commission.uplink_counter = _lw_session.uplink_counter;\n\n    tr_debug(\"Frame Counters. UpCnt=%lu, DownCnt=%lu\",\n             commission.uplink_counter, commission.downlink_counter);\n\n    commission_device(commission);\n\n    set_device_state(DEVICE_STATE_ABP_CONNECTING);\n    status = lora_state_machine();\n\n    return status;\n}\n\nint16_t LoRaWANStack::handle_tx(uint8_t port, const uint8_t* data,\n                                uint16_t length, uint8_t flags)\n{\n    tr_info(\"handle_tx, lw_session.active=%d tx_msg.tx_ongoing=%d\", _lw_session.active, _tx_msg.tx_ongoing);\n\n    if (!_lw_session.active) {\n        return LORAWAN_STATUS_NO_ACTIVE_SESSIONS;\n    }\n\n    if (_tx_msg.tx_ongoing) {\n        return LORAWAN_STATUS_WOULD_BLOCK;\n    }\n\n    if (!data && length > 0) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    if (_compliance_test.running) {\n        return LORAWAN_STATUS_COMPLIANCE_TEST_ON;\n    }\n#endif\n\n    loramac_mib_req_confirm_t mib_req;\n    lorawan_status_t status;\n    mib_req.type = MIB_NETWORK_JOINED;\n    status = mib_get_request(&mib_req);\n\n    tr_info(\"mib status is %d\", status);\n\n    if (status == LORAWAN_STATUS_OK) {\n        if (mib_req.param.is_nwk_joined == false) {\n            return LORAWAN_STATUS_NO_NETWORK_JOINED;\n        }\n    }\n\n    status = set_application_port(port);\n\n    if (status != LORAWAN_STATUS_OK) {\n        tr_error(\"Illegal application port definition.\");\n        return status;\n    }\n\n    if (flags == 0\n            || (flags & MSG_FLAG_MASK) == (MSG_CONFIRMED_FLAG|MSG_UNCONFIRMED_FLAG)) {\n        tr_error(\"CONFIRMED and UNCONFIRMED are mutually exclusive for send()\");\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _tx_msg.port = port;\n\n    uint16_t max_possible_size = check_possible_tx_size(length);\n\n    if (max_possible_size > MBED_CONF_LORA_TX_MAX_SIZE) {\n        // LORAWAN_APP_DATA_MAX_SIZE should at least be\n        // either equal to or bigger than maximum possible\n        // tx size because our tx message buffer takes its\n        // length from that macro. Force maximum possible tx unit\n        // to be equal to the buffer size user chose.\n        max_possible_size = MBED_CONF_LORA_TX_MAX_SIZE;\n    }\n\n    if (max_possible_size < length) {\n        tr_info(\"Cannot transmit %d bytes. Possible TX Size is %d bytes\",\n                length, max_possible_size);\n\n        _tx_msg.pending_size = length - max_possible_size;\n        _tx_msg.f_buffer_size = max_possible_size;\n        // copy user buffer upto the max_possible_size\n        memcpy(_tx_msg.f_buffer, data, _tx_msg.f_buffer_size);\n    } else {\n        // Whole message can be sent at one time\n        _tx_msg.f_buffer_size = length;\n        _tx_msg.pending_size = 0;\n        // copy user buffer upto the max_possible_size\n        if (length > 0) {\n            memcpy(_tx_msg.f_buffer, data, length);\n        }\n    }\n\n    // Handles all unconfirmed messages, including proprietary and multicast\n    if ((flags & MSG_FLAG_MASK) == MSG_UNCONFIRMED_FLAG\n            || (flags & MSG_FLAG_MASK) == MSG_UNCONFIRMED_MULTICAST\n            || (flags & MSG_FLAG_MASK) == MSG_UNCONFIRMED_PROPRIETARY) {\n\n         _tx_msg.type = MCPS_UNCONFIRMED;\n         _tx_msg.fport = _app_port;\n    }\n\n    // Handles all confirmed messages, including proprietary and multicast\n    if ((flags & MSG_FLAG_MASK) == MSG_CONFIRMED_FLAG\n            || (flags & MSG_FLAG_MASK) == MSG_CONFIRMED_MULTICAST\n            || (flags & MSG_FLAG_MASK) == MSG_CONFIRMED_PROPRIETARY) {\n\n        _tx_msg.type = MCPS_CONFIRMED;\n        _tx_msg.fport = _app_port;\n        _tx_msg.nb_trials = _num_retry;\n    }\n\n    tr_info(\"RTS = %u bytes, PEND = %u\", _tx_msg.f_buffer_size, _tx_msg.pending_size);\n    set_device_state(DEVICE_STATE_SEND);\n    status = lora_state_machine();\n\n    tr_info(\"lora_state_machine is %d\", status);\n\n    // send user the length of data which is scheduled now.\n    // user should take care of the pending data.\n    return (status == LORAWAN_STATUS_OK) ? _tx_msg.f_buffer_size : (int16_t) status;\n}\n\nint16_t LoRaWANStack::handle_rx(const uint8_t port, uint8_t* data,\n                                uint16_t length, uint8_t flags)\n{\n    if (!_lw_session.active) {\n        return LORAWAN_STATUS_NO_ACTIVE_SESSIONS;\n    }\n\n    // No messages to read.\n    if (!_rx_msg.receive_ready) {\n        return LORAWAN_STATUS_WOULD_BLOCK;\n    }\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    if (_compliance_test.running) {\n        return LORAWAN_STATUS_COMPLIANCE_TEST_ON;\n    }\n#endif\n\n    if (data == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    uint8_t *base_ptr = _rx_msg.msg.mcps_indication.buffer;\n    uint16_t base_size = _rx_msg.msg.mcps_indication.buffer_size;\n    bool read_complete = false;\n\n    if (_rx_msg.msg.mcps_indication.port != port) {\n        // Nothing yet received for this particular port\n        return LORAWAN_STATUS_WOULD_BLOCK;\n    }\n\n    // check if message received is a Confirmed message and user subscribed to it or not\n    if (_rx_msg.msg.mcps_indication.type == MCPS_CONFIRMED\n            && ((flags & MSG_FLAG_MASK) == MSG_CONFIRMED_FLAG\n                    || (flags & MSG_FLAG_MASK) == MSG_CONFIRMED_MULTICAST\n                    || (flags & MSG_FLAG_MASK) == MSG_CONFIRMED_PROPRIETARY)) {\n\n        tr_debug(\"RX - Confirmed Message, flags=%d\", flags);\n    }\n\n    // check if message received is a Unconfirmed message and user subscribed to it or not\n    if (_rx_msg.msg.mcps_indication.type == MCPS_UNCONFIRMED\n            && ((flags & MSG_FLAG_MASK) == MSG_UNCONFIRMED_FLAG\n                    || (flags & MSG_FLAG_MASK) == MSG_UNCONFIRMED_MULTICAST\n                    || (flags & MSG_FLAG_MASK) == MSG_UNCONFIRMED_PROPRIETARY)) {\n        tr_debug(\"RX - Unconfirmed Message - flags=%d\", flags);\n    }\n\n    // check the length of received message whether we can fit into user\n    // buffer completely or not\n    if (_rx_msg.msg.mcps_indication.buffer_size > length &&\n            _rx_msg.prev_read_size == 0) {\n        // we can't fit into user buffer. Invoke counter measures\n        _rx_msg.pending_size = _rx_msg.msg.mcps_indication.buffer_size - length;\n        base_size = length;\n        _rx_msg.prev_read_size = base_size;\n        memcpy(data, base_ptr, base_size);\n    } else if (_rx_msg.prev_read_size == 0) {\n        _rx_msg.pending_size = 0;\n        _rx_msg.prev_read_size = 0;\n        memcpy(data, base_ptr, base_size);\n        read_complete = true;\n    }\n\n    // If its the pending read then we should copy only the remaining part of\n    // the buffer. Due to checks above, in case of a pending read, this block\n    // will be the only one to get invoked\n    if (_rx_msg.pending_size > 0 && _rx_msg.prev_read_size > 0) {\n        memcpy(data, base_ptr+_rx_msg.prev_read_size, base_size);\n    }\n\n    // we are done handing over received buffer to user. check if there is\n    // anything pending. If not, memset the buffer to zero and indicate\n    // that no read is in progress\n    if (read_complete) {\n        memset(_rx_msg.msg.mcps_indication.buffer, 0, LORAMAC_PHY_MAXPAYLOAD);\n        _rx_msg.receive_ready = false;\n    }\n\n    return base_size;\n}\n\nlorawan_status_t LoRaWANStack::mlme_request_handler(loramac_mlme_req_t *mlme_request)\n{\n    if (mlme_request == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    return _loramac.mlme_request(mlme_request);\n}\n\n/** MLME-Confirm event function\n *\n * \\param mlme_confirm      Pointer to the confirm structure,\n *                          containing confirm attributes.\n */\nvoid LoRaWANStack::mlme_confirm_handler(loramac_mlme_confirm_t *mlme_confirm)\n{\n    if (NULL == mlme_confirm) {\n        tr_error(\"mlme_confirm: struct [in] is null!\");\n        MBED_ASSERT(0);\n        return;\n    }\n\n    switch (mlme_confirm->req_type) {\n        case MLME_JOIN:\n            if (mlme_confirm->status == LORAMAC_EVENT_INFO_STATUS_OK) {\n                // Status is OK, node has joined the network\n                set_device_state(DEVICE_STATE_JOINED);\n                if (lora_state_machine() != LORAWAN_STATUS_OK) {\n                    tr_error(\"Lora state machine did not return LORAWAN_STATUS_OK\");\n                }\n            } else {\n                // Join attempt failed.\n                set_device_state(DEVICE_STATE_IDLE);\n                if (lora_state_machine() != LORAWAN_STATUS_IDLE) {\n                    tr_error(\"Lora state machine did not return DEVICE_STATE_IDLE !\");\n                }\n\n                if (_callbacks.events) {\n                    const int ret = _queue->call(_callbacks.events, JOIN_FAILURE);\n                    MBED_ASSERT(ret != 0);\n                    (void)ret;\n                }\n            }\n            break;\n        case MLME_LINK_CHECK:\n            if (mlme_confirm->status == LORAMAC_EVENT_INFO_STATUS_OK) {\n                // Check DemodMargin\n                // Check NbGateways\n#if defined(LORAWAN_COMPLIANCE_TEST)\n                if (_compliance_test.running == true) {\n                    _compliance_test.link_check = true;\n                    _compliance_test.demod_margin = mlme_confirm->demod_margin;\n                    _compliance_test.nb_gateways = mlme_confirm->nb_gateways;\n                } else\n#endif\n                {\n                    // normal operation as oppose to compliance testing\n                    if (_callbacks.link_check_resp) {\n                        const int ret = _queue->call(_callbacks.link_check_resp,\n                                                     mlme_confirm->demod_margin,\n                                                     mlme_confirm->nb_gateways);\n                        MBED_ASSERT(ret != 0);\n                        (void)ret;\n                    }\n                }\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nlorawan_status_t LoRaWANStack::mcps_request_handler(loramac_mcps_req_t *mcps_request)\n{\n    if (mcps_request == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    return _loramac.mcps_request(mcps_request);\n}\n\n/** MCPS-Confirm event function\n *\n * \\param mcps_confirm      Pointer to the confirm structure,\n *                          containing confirm attributes.\n */\nvoid LoRaWANStack::mcps_confirm_handler(loramac_mcps_confirm_t *mcps_confirm)\n{\n    if (mcps_confirm == NULL) {\n        tr_error(\"mcps_confirm: struct [in] is null!\");\n        MBED_ASSERT(0);\n        return;\n    }\n\n    tr_info(\"mcps_confirm_handler, status=%d\", mcps_confirm->status);\n\n    if (mcps_confirm->status != LORAMAC_EVENT_INFO_STATUS_OK) {\n        // Couldn't schedule packet, ack not recieved in CONFIRMED case\n        // or some other error happened. Discard buffer, unset the tx-ongoing\n        // flag and let the application know\n        _tx_msg.tx_ongoing = false;\n        memset(_tx_msg.f_buffer, 0, MBED_CONF_LORA_TX_MAX_SIZE);\n        _tx_msg.f_buffer_size = MBED_CONF_LORA_TX_MAX_SIZE;\n\n        tr_error(\"mcps_confirm_handler: Error code = %d\", mcps_confirm->status);\n\n        // If sending timed out, we have a special event for that\n        if (mcps_confirm->status == LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT) {\n            if (_callbacks.events) {\n                const int ret = _queue->call(_callbacks.events, TX_TIMEOUT);\n                MBED_ASSERT(ret != 0);\n                (void)ret;\n            }\n            return;\n        } if (mcps_confirm->status == LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT) {\n            tr_debug(\"Did not receive Ack\");\n        }\n\n        // Otherwise send a general TX_ERROR event\n        if (_callbacks.events) {\n            const int ret = _queue->call(_callbacks.events, TX_ERROR);\n            MBED_ASSERT(ret != 0);\n            (void)ret;\n        }\n        return;\n    }\n\n    // If No errors encountered, let's proceed with the status.\n    // CONFIRMED needs special handling because of acks\n    if (mcps_confirm->req_type == MCPS_CONFIRMED) {\n        // In confirmed case, we need to check if we have received the Ack or not.\n        // This is actually just being paranoid about ack because LoRaMac.cpp doesn't\n        // call this callback until an ack is received.\n        if (mcps_confirm->ack_received) {\n            tr_debug(\"Ack received.\");\n        }\n    }\n\n    // This part is common to both CONFIRMED and UNCONFIRMED.\n    // Tell the application about successful transmission and store\n    // data rate plus frame counter.\n    _lw_session.uplink_counter = mcps_confirm->ul_frame_counter;\n    _tx_msg.tx_ongoing = false;\n     if (_callbacks.events) {\n         const int ret = _queue->call(_callbacks.events, TX_DONE);\n         MBED_ASSERT(ret != 0);\n         (void)ret;\n     }\n}\n\n/** MCPS-Indication event function\n *\n * \\param mcps_indication   Pointer to the indication structure,\n *                          containing indication attributes.\n */\nvoid LoRaWANStack::mcps_indication_handler(loramac_mcps_indication_t *mcps_indication)\n{\n    if (mcps_indication == NULL) {\n        tr_error(\"mcps_indication: struct [in] is null.\");\n        return;\n    }\n\n    tr_info(\"mcps_indication_handler, status=%d\", mcps_indication->status);\n\n    if (mcps_indication->status != LORAMAC_EVENT_INFO_STATUS_OK) {\n        if (_callbacks.events) {\n            const int ret = _queue->call(_callbacks.events, RX_ERROR);\n            MBED_ASSERT(ret != 0);\n            (void)ret;\n        }\n        return;\n    }\n\n    switch (mcps_indication->type) {\n        case MCPS_UNCONFIRMED:\n            break;\n        case MCPS_CONFIRMED:\n            break;\n        case MCPS_PROPRIETARY:\n            break;\n        case MCPS_MULTICAST:\n            break;\n        default:\n            break;\n    }\n\n    // Check Multicast\n    // Check Port\n    // Check Datarate\n    // Check FramePending\n    // Check Buffer\n    // Check BufferSize\n    // Check Rssi\n    // Check Snr\n    // Check RxSlot\n\n    _lw_session.downlink_counter++;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    if (_compliance_test.running == true) {\n        _compliance_test.downlink_counter++;\n    }\n#endif\n\n    if (mcps_indication->is_data_recvd == true) {\n        switch (mcps_indication->port) {\n        case 224:\n#if defined(LORAWAN_COMPLIANCE_TEST)\n            tr_debug(\"Compliance test command received.\");\n            compliance_test_handler(mcps_indication);\n#else\n            tr_debug(\"Compliance test disabled.\");\n#endif\n            break;\n        default:\n            if (is_port_valid(mcps_indication->port) == true ||\n                mcps_indication->type == MCPS_PROPRIETARY) {\n\n                // Valid message arrived.\n                _rx_msg.type = LORAMAC_RX_MCPS_INDICATION;\n                _rx_msg.msg.mcps_indication.buffer_size = mcps_indication->buffer_size;\n                _rx_msg.msg.mcps_indication.port = mcps_indication->port;\n\n                // no copy, just set the pointer for the user\n                _rx_msg.msg.mcps_indication.buffer =\n                mcps_indication->buffer;\n\n                // Notify application about received frame..\n                tr_debug(\"Received %d bytes\", _rx_msg.msg.mcps_indication.buffer_size);\n                _rx_msg.receive_ready = true;\n\n                if (_callbacks.events) {\n                    const int ret = _queue->call(_callbacks.events, RX_DONE);\n                    MBED_ASSERT(ret != 0);\n                    (void)ret;\n                }\n\n                // If fPending bit is set we try to generate an empty packet\n                // with CONFIRMED flag set. We always set a CONFIRMED flag so\n                // that we could retry a certain number of times if the uplink\n                // failed for some reason\n                if (mcps_indication->fpending_status) {\n                    handle_tx(mcps_indication->port, NULL, 0, MSG_CONFIRMED_FLAG);\n                }\n            } else {\n                // Invalid port, ports 0, 224 and 225-255 are reserved.\n            }\n            break;\n        }\n    }\n}\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n/** Compliance testing function\n *\n * \\param mcps_indication   Pointer to the indication structure,\n *                          containing indication attributes.\n */\nvoid LoRaWANStack::compliance_test_handler(loramac_mcps_indication_t *mcps_indication)\n{\n    if (_compliance_test.running == false) {\n        // Check compliance test enable command (i)\n        if ((mcps_indication->buffer_size == 4) &&\n            (mcps_indication->buffer[0] == 0x01) &&\n            (mcps_indication->buffer[1] == 0x01) &&\n            (mcps_indication->buffer[2] == 0x01) &&\n            (mcps_indication->buffer[3] == 0x01)) {\n            _compliance_test.is_tx_confirmed = false;\n            _compliance_test.app_port = 224;\n            _compliance_test.app_data_size = 2;\n            _compliance_test.downlink_counter = 0;\n            _compliance_test.link_check = false;\n            _compliance_test.demod_margin = 0;\n            _compliance_test.nb_gateways = 0;\n            _compliance_test.running = true;\n            _compliance_test.state = 1;\n\n            loramac_mib_req_confirm_t mib_req;\n            mib_req.type = MIB_ADR;\n            mib_req.param.is_adr_enable = true;\n            mib_set_request(&mib_req);\n\n#if MBED_CONF_LORA_PHY      == 0\n            _loramac.LoRaMacTestSetDutyCycleOn(false);\n#endif\n            //5000ms\n            _loramac.LoRaMacSetTxTimer(5000);\n            set_device_state(DEVICE_STATE_COMPLIANCE_TEST);\n            tr_debug(\"Compliance test activated.\");\n        }\n    } else {\n        _compliance_test.state = mcps_indication->buffer[0];\n        switch (_compliance_test.state) {\n        case 0: // Check compliance test disable command (ii)\n            _compliance_test.is_tx_confirmed = true;\n            _compliance_test.app_port = MBED_CONF_LORA_APP_PORT;\n            _compliance_test.app_data_size = LORAWAN_COMPLIANCE_TEST_DATA_SIZE;\n            _compliance_test.downlink_counter = 0;\n            _compliance_test.running = false;\n\n            loramac_mib_req_confirm_t mib_req;\n            mib_req.type = MIB_ADR;\n            mib_req.param.is_adr_enable = MBED_CONF_LORA_ADR_ON;\n            mib_set_request(&mib_req);\n#if MBED_CONF_LORA_PHY      == 0\n            _loramac.LoRaMacTestSetDutyCycleOn(MBED_CONF_LORA_DUTY_CYCLE_ON);\n#endif\n            // Go to idle state after compliance test mode.\n            tr_debug(\"Compliance test disabled.\");\n            _loramac.LoRaMacStopTxTimer();\n\n            // Clear any compliance test message stuff before going back to normal operation.\n            memset(&_tx_msg, 0, sizeof(_tx_msg));\n            set_device_state(DEVICE_STATE_IDLE);\n            lora_state_machine();\n            break;\n        case 1: // (iii, iv)\n            _compliance_test.app_data_size = 2;\n            break;\n        case 2: // Enable confirmed messages (v)\n            _compliance_test.is_tx_confirmed = true;\n            _compliance_test.state = 1;\n            break;\n        case 3:  // Disable confirmed messages (vi)\n            _compliance_test.is_tx_confirmed = false;\n            _compliance_test.state = 1;\n            break;\n        case 4: // (vii)\n            _compliance_test.app_data_size = mcps_indication->buffer_size;\n\n            _compliance_test.app_data_buffer[0] = 4;\n            for(uint8_t i = 1; i < MIN(_compliance_test.app_data_size, LORAMAC_PHY_MAXPAYLOAD); ++i) {\n                _compliance_test.app_data_buffer[i] = mcps_indication->buffer[i] + 1;\n            }\n\n            send_compliance_test_frame_to_mac();\n            break;\n        case 5: // (viii)\n            loramac_mlme_req_t mlme_req;\n            mlme_req.type = MLME_LINK_CHECK;\n            mlme_request_handler(&mlme_req);\n            break;\n        case 6: // (ix)\n            loramac_mlme_req_t mlme_request;\n            loramac_mib_req_confirm_t mib_request;\n\n            // Disable TestMode and revert back to normal operation\n            _compliance_test.is_tx_confirmed = true;\n            _compliance_test.app_port = MBED_CONF_LORA_APP_PORT;\n            _compliance_test.app_data_size = LORAWAN_COMPLIANCE_TEST_DATA_SIZE;\n            _compliance_test.downlink_counter = 0;\n            _compliance_test.running = false;\n\n            mib_request.type = MIB_ADR;\n            mib_request.param.is_adr_enable = MBED_CONF_LORA_ADR_ON;\n            mib_set_request(&mib_request);\n#if MBED_CONF_LORA_PHY      == 0\n            _loramac.LoRaMacTestSetDutyCycleOn(MBED_CONF_LORA_DUTY_CYCLE_ON);\n#endif\n            mlme_request.type = MLME_JOIN;\n            mlme_request.req.join.dev_eui = _lw_session.connection.connection_u.otaa.dev_eui;\n            mlme_request.req.join.app_eui = _lw_session.connection.connection_u.otaa.app_eui;\n            mlme_request.req.join.app_key = _lw_session.connection.connection_u.otaa.app_key;\n            mlme_request.req.join.nb_trials = _lw_session.connection.connection_u.otaa.nb_trials;\n            mlme_request_handler(&mlme_request);\n            break;\n        case 7: // (x)\n            if (mcps_indication->buffer_size == 3) {\n                loramac_mlme_req_t mlme_req;\n                mlme_req.type = MLME_TXCW;\n                mlme_req.req.cw_tx_mode.timeout = (uint16_t)((mcps_indication->buffer[1] << 8) | mcps_indication->buffer[2]);\n                mlme_request_handler(&mlme_req);\n            } else if (mcps_indication->buffer_size == 7) {\n                loramac_mlme_req_t mlme_req;\n                mlme_req.type = MLME_TXCW_1;\n                mlme_req.req.cw_tx_mode.timeout = (uint16_t)((mcps_indication->buffer[1] << 8) | mcps_indication->buffer[2]);\n                mlme_req.req.cw_tx_mode.frequency = (uint32_t)((mcps_indication->buffer[3] << 16) | (mcps_indication->buffer[4] << 8)\n                        | mcps_indication->buffer[5]) * 100;\n                mlme_req.req.cw_tx_mode.power = mcps_indication->buffer[6];\n                mlme_request_handler(&mlme_req);\n            }\n            _compliance_test.state = 1;\n            break;\n        }\n    }\n}\n#endif\n\nlorawan_status_t LoRaWANStack::mib_set_request(loramac_mib_req_confirm_t *mib_set_params)\n{\n    if (NULL == mib_set_params) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n    return _loramac.mib_set_request_confirm(mib_set_params);\n}\n\nlorawan_status_t LoRaWANStack::mib_get_request(loramac_mib_req_confirm_t *mib_get_params)\n{\n    if(NULL == mib_get_params) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n    return _loramac.mib_get_request_confirm(mib_get_params);\n}\n\nlorawan_status_t LoRaWANStack::set_link_check_request()\n{\n    if (!_callbacks.link_check_resp) {\n        tr_error(\"Must assign a callback function for link check request. \");\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    loramac_mlme_req_t mlme_req;\n\n    mlme_req.type = MLME_LINK_CHECK;\n    return mlme_request_handler(&mlme_req);\n}\n\nlorawan_status_t LoRaWANStack::shutdown()\n{\n    set_device_state(DEVICE_STATE_SHUTDOWN);\n    return lora_state_machine();\n}\n\nlorawan_status_t LoRaWANStack::lora_state_machine()\n{\n    loramac_mib_req_confirm_t mib_req;\n    lorawan_status_t status = LORAWAN_STATUS_DEVICE_OFF;\n\n    tr_info(\"lora_state_machine %d\", _device_current_state);\n\n    switch (_device_current_state) {\n        case DEVICE_STATE_SHUTDOWN:\n            /*\n             * Remove channels\n             * Radio will be put to sleep by the APIs underneath\n             */\n            drop_channel_list();\n\n            // Shutdown LoRaMac\n            _loramac.disconnect();\n\n            // Stop sending messages and set joined status to false.\n#if defined(LORAWAN_COMPLIANCE_TEST)\n            _loramac.LoRaMacStopTxTimer();\n#endif\n            mib_req.type = MIB_NETWORK_JOINED;\n            mib_req.param.is_nwk_joined = false;\n            mib_set_request(&mib_req);\n\n            // reset buffers to original state\n            memset(_tx_msg.f_buffer, 0, MBED_CONF_LORA_TX_MAX_SIZE);\n            _tx_msg.pending_size = 0;\n            _tx_msg.f_buffer_size = 0;\n            _tx_msg.tx_ongoing = false;\n            _rx_msg.msg.mcps_indication.buffer = NULL;\n            _rx_msg.receive_ready = false;\n            _rx_msg.prev_read_size = 0;\n            _rx_msg.msg.mcps_indication.buffer_size = 0;\n\n            // disable the session\n            _lw_session.active = false;\n\n            tr_debug(\"LoRaWAN protocol has been shut down.\");\n            if (_callbacks.events) {\n                const int ret = _queue->call(_callbacks.events, DISCONNECTED);\n                MBED_ASSERT(ret != 0);\n                (void)ret;\n            }\n            status = LORAWAN_STATUS_DEVICE_OFF;\n            break;\n        case DEVICE_STATE_NOT_INITIALIZED:\n            // Device is disconnected.\n            status = LORAWAN_STATUS_DEVICE_OFF;\n            break;\n        case DEVICE_STATE_INIT:\n            status = LORAWAN_STATUS_OK;\n            break;\n        case DEVICE_STATE_JOINING:\n            if (_lw_session.connection.connect_type == LORAWAN_CONNECTION_OTAA) {\n                /*\n                 * OTAA join\n                 */\n                tr_debug(\"Send Join-request..\");\n                loramac_mlme_req_t mlme_req;\n                mlme_req.type = MLME_JOIN;\n\n                mlme_req.req.join.dev_eui = _lw_session.connection.connection_u.otaa.dev_eui;\n                mlme_req.req.join.app_eui = _lw_session.connection.connection_u.otaa.app_eui;\n                mlme_req.req.join.app_key = _lw_session.connection.connection_u.otaa.app_key;\n                mlme_req.req.join.nb_trials = _lw_session.connection.connection_u.otaa.nb_trials;\n\n                // Send join request to server.\n                status = mlme_request_handler(&mlme_req);\n                if (status != LORAWAN_STATUS_OK) {\n                    return status;\n                }\n                // Otherwise request was successful and OTAA connect is in\n                //progress\n                return LORAWAN_STATUS_CONNECT_IN_PROGRESS;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        case DEVICE_STATE_JOINED:\n            tr_debug(\"Join OK!\");\n            // Session is now active\n            _lw_session.active = true;\n            // Tell the application that we are connected\n            if (_callbacks.events) {\n                const int ret = _queue->call(_callbacks.events, CONNECTED);\n                MBED_ASSERT(ret != 0);\n                (void)ret;\n            }\n            status = LORAWAN_STATUS_OK;\n            break;\n        case DEVICE_STATE_ABP_CONNECTING:\n            /*\n             * ABP connection\n             */\n            mib_req.type = MIB_NET_ID;\n            mib_req.param.net_id = _lw_session.connection.connection_u.abp.nwk_id;\n            mib_set_request(&mib_req);\n\n            mib_req.type = MIB_DEV_ADDR;\n            mib_req.param.dev_addr = _lw_session.connection.connection_u.abp.dev_addr;\n            mib_set_request(&mib_req);\n\n            mib_req.type = MIB_NWK_SKEY;\n            mib_req.param.nwk_skey = _lw_session.connection.connection_u.abp.nwk_skey;\n            mib_set_request(&mib_req);\n\n            mib_req.type = MIB_APP_SKEY;\n            mib_req.param.app_skey = _lw_session.connection.connection_u.abp.app_skey;\n            mib_set_request(&mib_req);\n\n            mib_req.type = MIB_NETWORK_JOINED;\n            mib_req.param.is_nwk_joined = true;\n            mib_set_request(&mib_req);\n            tr_debug(\"ABP Connection OK!\");\n            // tell the application we are okay\n            // if users provide wrong keys, it's their responsibility\n            // there is no way to test ABP authentication success\n            status = LORAWAN_STATUS_OK;\n            // Session is now active\n            _lw_session.active = true;\n            if (_callbacks.events) {\n                const int ret = _queue->call(_callbacks.events, CONNECTED);\n                MBED_ASSERT(ret != 0);\n                (void)ret;\n            }\n            break;\n        case DEVICE_STATE_SEND:\n            // If a transmission is ongoing, don't interrupt\n            if (_tx_msg.tx_ongoing) {\n                status = LORAWAN_STATUS_OK;\n            } else {\n                _tx_msg.tx_ongoing = true;\n                status = send_frame_to_mac();\n\n                switch (status) {\n                    case LORAWAN_STATUS_OK:\n                        tr_debug(\"Frame scheduled to TX..\");\n                        break;\n                    case LORAWAN_STATUS_CRYPTO_FAIL:\n                        tr_error(\"Crypto failed. Clearing TX buffers\");\n                        if (_callbacks.events) {\n                            const int ret = _queue->call(_callbacks.events, TX_CRYPTO_ERROR);\n                            MBED_ASSERT(ret != 0);\n                            (void)ret;\n                        }\n                        break;\n                    default:\n                        tr_error(\"Failure to schedule TX!\");\n                        if (_callbacks.events) {\n                            const int ret = _queue->call(_callbacks.events, TX_SCHEDULING_ERROR);\n                            MBED_ASSERT(ret != 0);\n                            (void)ret;\n                        }\n                        break;\n                }\n            }\n            // otherwise all done, put device in idle state\n            set_device_state(DEVICE_STATE_IDLE);\n            break;\n        case DEVICE_STATE_IDLE:\n            //Do nothing\n            status = LORAWAN_STATUS_IDLE;\n            break;\n#if defined(LORAWAN_COMPLIANCE_TEST)\n        case DEVICE_STATE_COMPLIANCE_TEST:\n            //Device is in compliance test mode\n            tr_debug(\"Device is in compliance test mode.\");\n\n            //5000ms\n            _loramac.LoRaMacSetTxTimer(5000);\n            if (_compliance_test.running == true) {\n                send_compliance_test_frame_to_mac();\n            }\n            status = LORAWAN_STATUS_COMPLIANCE_TEST_ON;\n            break;\n#endif\n        default:\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n            break;\n    }\n\n    return status;\n}\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n/**\n *\n * Prepares the upload message to reserved ports\n *\n * \\param port              Application port\n */\nvoid LoRaWANStack::prepare_special_tx_frame(uint8_t port)\n{\n    if (port == 224) {\n        // Clear any normal message stuff before compliance test.\n        memset(&_tx_msg, 0, sizeof(_tx_msg));\n\n        if (_compliance_test.link_check == true) {\n            _compliance_test.link_check = false;\n            _compliance_test.state = 1;\n            _tx_msg.f_buffer_size = 3;\n            _tx_msg.f_buffer[0] = 5;\n            _tx_msg.f_buffer[1] = _compliance_test.demod_margin;\n            _tx_msg.f_buffer[2] = _compliance_test.nb_gateways;\n        } else {\n            switch (_compliance_test.state) {\n            case 4:\n                _compliance_test.state = 1;\n                _tx_msg.f_buffer_size = _compliance_test.app_data_size;\n\n                _tx_msg.f_buffer[0] = _compliance_test.app_data_buffer[0];\n                for(uint8_t i = 1; i < MIN(_compliance_test.app_data_size, MBED_CONF_LORA_TX_MAX_SIZE); ++i) {\n                    _tx_msg.f_buffer[i] = _compliance_test.app_data_buffer[i];\n                }\n                break;\n            case 1:\n                _tx_msg.f_buffer_size = 2;\n                _tx_msg.f_buffer[0] = _compliance_test.downlink_counter >> 8;\n                _tx_msg.f_buffer[1] = _compliance_test.downlink_counter;\n                break;\n            }\n        }\n    }\n}\n\n/** Hands over the compliance test frame to MAC layer\n *\n * \\return          returns the state of the LoRa MAC\n */\nlorawan_status_t LoRaWANStack::send_compliance_test_frame_to_mac()\n{\n    loramac_mcps_req_t mcps_req;\n\n    prepare_special_tx_frame(_compliance_test.app_port);\n\n    if (!_compliance_test.is_tx_confirmed) {\n        mcps_req.type = MCPS_UNCONFIRMED;\n        mcps_req.f_buffer = _tx_msg.f_buffer;\n        mcps_req.f_buffer_size = _tx_msg.f_buffer_size;\n        mcps_req.fport = _compliance_test.app_port;\n        mcps_req.nb_trials = 1;\n        mcps_req.data_rate = _lora_phy.get_default_tx_datarate();\n\n        tr_info(\"Transmit unconfirmed compliance test frame %d bytes.\", mcps_req.f_buffer_size);\n\n        for (uint8_t i = 0; i < mcps_req.f_buffer_size; ++i) {\n            tr_info(\"Byte %d, data is 0x%x\", i+1, ((uint8_t*)mcps_req.f_buffer)[i]);\n        }\n    } else if (_compliance_test.is_tx_confirmed) {\n        mcps_req.type = MCPS_CONFIRMED;\n        mcps_req.f_buffer = _tx_msg.f_buffer;\n        mcps_req.f_buffer_size = _tx_msg.f_buffer_size;\n        mcps_req.fport = _compliance_test.app_port;\n        mcps_req.nb_trials = _num_retry;\n        mcps_req.data_rate = _lora_phy.get_default_tx_datarate();\n\n        tr_info(\"Transmit confirmed compliance test frame %d bytes.\", mcps_req.f_buffer_size);\n\n        for (uint8_t i = 0; i < mcps_req.f_buffer_size; ++i) {\n            tr_info(\"Byte %d, data is 0x%x\", i+1, ((uint8_t*)mcps_req.f_buffer)[i]);\n        }\n    } else {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    return mcps_request_handler(&mcps_req);\n}\n#endif\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRa MAC layer implementation\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n#include <stdlib.h>\n#include \"LoRaMac.h\"\n#include \"LoRaMacCrypto.h\"\n\n#if defined(FEATURE_COMMON_PAL)\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LMAC\"\n#else\n#define tr_debug(...) printf(\"[LMAC][DBG] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_info(...)  printf(\"[LMAC][INF] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_error(...) printf(\"[LMAC][ERR] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_warn(...) printf(\"[LMAC][WRN] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#endif //defined(FEATURE_COMMON_PAL)\n\nusing namespace events;\n\n/*!\n * Maximum length of the fOpts field\n */\n#define LORA_MAC_COMMAND_MAX_FOPTS_LENGTH           15\n\n/*!\n * LoRaMac duty cycle for the back-off procedure during the first hour.\n */\n#define BACKOFF_DC_1_HOUR                           100\n\n/*!\n * LoRaMac duty cycle for the back-off procedure during the next 10 hours.\n */\n#define BACKOFF_DC_10_HOURS                         1000\n\n/*!\n * LoRaMac duty cycle for the back-off procedure during the next 24 hours.\n */\n#define BACKOFF_DC_24_HOURS                         10000\n\n/*!\n * Check the MAC layer state every MAC_STATE_CHECK_TIMEOUT in ms.\n */\n#define MAC_STATE_CHECK_TIMEOUT                     1000\n\n/*!\n * The maximum number of times the MAC layer tries to get an acknowledge.\n */\n#define MAX_ACK_RETRIES                             8\n\n/*!\n * The frame direction definition for uplink communications.\n */\n#define UP_LINK                                     0\n\n/*!\n * The frame direction definition for downlink communications.\n */\n#define DOWN_LINK                                   1\n\n\nLoRaMac::LoRaMac(LoRaWANTimeHandler &lora_time)\n    : mac_commands(), _lora_time(lora_time)\n{\n    lora_phy = NULL;\n    //radio_events_t RadioEvents;\n    _params.keys.dev_eui = NULL;\n    _params.keys.app_eui = NULL;\n    _params.keys.app_key = NULL;\n\n    memset(_params.keys.nwk_skey, 0, sizeof(_params.keys.nwk_skey));\n    memset(_params.keys.app_skey, 0, sizeof(_params.keys.app_skey));\n\n    _params.dev_nonce = 0;\n    _params.net_id = 0;\n    _params.dev_addr = 0;\n    _params.buffer_pkt_len = 0;\n    _params.payload_length = 0;\n    _params.ul_frame_counter = 0;\n    _params.dl_frame_counter = 0;\n    _params.is_ul_frame_counter_fixed = false;\n    _params.is_rx_window_enabled = true;\n    _params.is_nwk_joined = false;\n    _params.adr_ack_counter = 0;\n    _params.is_node_ack_requested = false;\n    _params.is_srv_ack_requested = false;\n    _params.ul_nb_rep_counter = 0;\n    _params.timers.mac_init_time = 0;\n    _params.mac_state = LORAMAC_IDLE;\n    _params.max_ack_timeout_retries = 1;\n    _params.ack_timeout_retry_counter = 1;\n    _params.is_ack_retry_timeout_expired = false;\n    _params.timers.tx_toa = 0;\n\n    _params.multicast_channels = NULL;\n\n    _params.sys_params.adr_on = false;\n    _params.sys_params.max_duty_cycle = 0;\n\n    mac_primitives = NULL;\n    ev_queue = NULL;\n}\n\nLoRaMac::~LoRaMac()\n{\n}\n\n\n/***************************************************************************\n * ISRs - Handlers                                                         *\n **************************************************************************/\nvoid LoRaMac::handle_tx_done(void)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_radio_tx_done);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_rx_done(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_radio_rx_done, payload, size, rssi, snr);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_rx_error(void)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_radio_rx_error);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_rx_timeout(void)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_radio_rx_timeout);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_tx_timeout(void)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_radio_tx_timeout);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_cad_done(bool cad)\n{\n    //TODO Not implemented yet\n    //const int ret = 1;\n    // this->OnRadioCadDone(cad);\n    //MBED_ASSERT(ret != 0);\n    //(void)ret;\n}\n\nvoid LoRaMac::handle_fhss_change_channel(uint8_t cur_channel)\n{\n    // TODO Not implemented yet\n    //const int ret = 1;\n    // this->OnRadioFHSSChangeChannel(cur_channel);\n    //MBED_ASSERT(ret != 0);\n    //(void)ret;\n}\n\nvoid LoRaMac::handle_mac_state_check_timer_event(void)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_mac_state_check_timer_event);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_delayed_tx_timer_event(void)\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_tx_delayed_timer_event);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_ack_timeout()\n{\n    const int ret = ev_queue->call(this, &LoRaMac::on_ack_timeout_timer_event);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_rx1_timer_event(void)\n{\n    tr_info(\"handle_rx1_timer_event\");\n    const int ret = ev_queue->call(this, &LoRaMac::on_rx_window1_timer_event);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\nvoid LoRaMac::handle_rx2_timer_event(void)\n{\n    tr_info(\"handle_rx2_timer_event\");\n    const int ret = ev_queue->call(this, &LoRaMac::on_rx_window2_timer_event);\n    MBED_ASSERT(ret != 0);\n    (void)ret;\n}\n\n/***************************************************************************\n * Radio event callbacks - delegated to Radio driver                       *\n **************************************************************************/\nvoid LoRaMac::on_radio_tx_done( void )\n{\n    tr_info(\"radio_tx_done\");\n\n    set_band_txdone_params_t tx_done_params;\n    lorawan_time_t cur_time = _lora_time.get_current_time( );\n    loramac_mlme_confirm_t mlme_confirm = mlme.get_confirmation();\n\n    if (_params.dev_class != CLASS_C) {\n        lora_phy->put_radio_to_sleep();\n    } else {\n        open_continuous_rx2_window();\n    }\n\n    // Setup timers\n    if(_params.is_rx_window_enabled == true) {\n        _lora_time.start(_params.timers.rx_window1_timer, _params.rx_window1_delay);\n\n        if (_params.dev_class != CLASS_C) {\n            _lora_time.start(_params.timers.rx_window2_timer, _params.rx_window2_delay);\n        }\n\n        if ((_params.dev_class == CLASS_C ) ||\n            (_params.is_node_ack_requested == true)) {\n            _lora_time.start(_params.timers.ack_timeout_timer,\n                             _params.rx_window2_delay + lora_phy->get_ack_timeout());\n        }\n    } else {\n        mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_OK;\n        mlme_confirm.status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;\n\n        if (_params.flags.value == 0) {\n            _params.flags.bits.mcps_req = 1;\n        }\n\n        _params.flags.bits.mac_done = 1;\n    }\n\n    // Verify if the last uplink was a join request\n    if ((_params.flags.bits.mlme_req == 1) &&\n        (mlme_confirm.req_type == MLME_JOIN)) {\n        _params.is_last_tx_join_request = true;\n    } else {\n        _params.is_last_tx_join_request = false;\n    }\n\n    // Store last Tx channel\n    _params.last_channel_idx = _params.channel;\n\n    // Update last tx done time for the current channel\n    tx_done_params.channel = _params.channel;\n    tx_done_params.joined = _params.is_nwk_joined;\n    tx_done_params.last_tx_done_time = cur_time;\n    lora_phy->set_last_tx_done(&tx_done_params);\n\n    // Update Aggregated last tx done time\n    _params.timers.aggregated_last_tx_time = cur_time;\n\n    if (_params.is_node_ack_requested == false) {\n        mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_OK;\n        _params.ul_nb_rep_counter++;\n    }\n\n    _lora_time.start(_params.timers.mac_state_check_timer, 1);\n}\n\nvoid LoRaMac::prepare_rx_done_abort(void)\n{\n    tr_info(\"prepare_rx_done_abort\");\n\n    _params.mac_state |= LORAMAC_RX_ABORT;\n\n    if (_params.is_node_ack_requested) {\n        handle_ack_timeout();\n    }\n\n    _params.flags.bits.mcps_ind = 1;\n    _params.flags.bits.mac_done = 1;\n\n    // Trigger MAC state check event timer as soon as possible\n    _lora_time.start(_params.timers.mac_state_check_timer, 1);\n}\n\nvoid LoRaMac::on_radio_rx_done(uint8_t *payload, uint16_t size, int16_t rssi,\n                               int8_t snr)\n{\n    tr_info(\"on_radio_rx_done, payload=%p, size=%u, rssi=%u, snr=%d\", payload, size, rssi, snr);\n\n    loramac_mhdr_t mac_hdr;\n    loramac_frame_ctrl_t fctrl;\n    cflist_params_t cflist;\n    bool skip_indication = false;\n\n    uint8_t pkt_header_len = 0;\n    uint32_t address = 0;\n    uint8_t app_payload_start_index = 0;\n    uint8_t frame_len = 0;\n    uint32_t mic = 0;\n    uint32_t mic_rx = 0;\n\n    uint16_t sequence_counter = 0;\n    uint16_t sequence_counter_prev = 0;\n    uint16_t sequence_counter_diff = 0;\n    uint32_t downlink_counter = 0;\n\n    multicast_params_t *cur_multicast_params = NULL;\n    uint8_t *nwk_skey = _params.keys.nwk_skey;\n    uint8_t *app_skey = _params.keys.app_skey;\n\n    uint8_t multicast = 0;\n\n    bool is_mic_ok = false;\n\n    mcps.get_confirmation().ack_received = false;\n    mcps.get_indication().rssi = rssi;\n    mcps.get_indication().snr = snr;\n    mcps.get_indication().rx_slot = _params.rx_slot;\n    mcps.get_indication().port = 0;\n    mcps.get_indication().multicast = 0;\n    mcps.get_indication().fpending_status = 0;\n    mcps.get_indication().buffer = NULL;\n    mcps.get_indication().buffer_size = 0;\n    mcps.get_indication().is_data_recvd = false;\n    mcps.get_indication().is_ack_recvd = false;\n    mcps.get_indication().dl_frame_counter = 0;\n    mcps.get_indication().type = MCPS_UNCONFIRMED;\n\n    lora_phy->put_radio_to_sleep();\n\n    _lora_time.stop( _params.timers.rx_window2_timer );\n\n    mac_hdr.value = payload[pkt_header_len++];\n\n    switch (mac_hdr.bits.mtype) {\n\n        case FRAME_TYPE_JOIN_ACCEPT:\n            if (_params.is_nwk_joined == true) {\n                mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                prepare_rx_done_abort();\n                return;\n            }\n\n            if (0 != decrypt_join_frame(payload + 1, size - 1,\n                                        _params.keys.app_key,\n                                        _params.payload + 1)) {\n                mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n                return;\n            }\n\n            _params.payload[0] = mac_hdr.value;\n\n            if (0 != compute_join_frame_mic(_params.payload, size - LORAMAC_MFR_LEN,\n                                           _params.keys.app_key, &mic)) {\n                mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n                return;\n            }\n\n            mic_rx |= (uint32_t) _params.payload[size - LORAMAC_MFR_LEN];\n            mic_rx |= ((uint32_t) _params.payload[size - LORAMAC_MFR_LEN + 1] << 8);\n            mic_rx |= ((uint32_t) _params.payload[size - LORAMAC_MFR_LEN + 2] << 16);\n            mic_rx |= ((uint32_t) _params.payload[size - LORAMAC_MFR_LEN + 3] << 24);\n\n            if (mic_rx == mic) {\n\n                if (0 != compute_skeys_for_join_frame(_params.keys.app_key,\n                                                 _params.payload + 1,\n                                                 _params.dev_nonce,\n                                                 _params.keys.nwk_skey,\n                                                 _params.keys.app_skey)) {\n                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n                    return;\n                }\n\n                _params.net_id = (uint32_t) _params.payload[4];\n                _params.net_id |= ((uint32_t) _params.payload[5] << 8);\n                _params.net_id |= ((uint32_t) _params.payload[6] << 16);\n\n                _params.dev_addr = (uint32_t) _params.payload[7];\n                _params.dev_addr |= ((uint32_t) _params.payload[8] << 8);\n                _params.dev_addr |= ((uint32_t) _params.payload[9] << 16);\n                _params.dev_addr |= ((uint32_t) _params.payload[10] << 24);\n\n                // DLSettings\n                _params.sys_params.rx1_dr_offset = (_params.payload[11] >> 4) & 0x07;\n                _params.sys_params.rx2_channel.datarate = _params.payload[11] & 0x0F;\n\n                // RxDelay\n                _params.sys_params.recv_delay1 = (_params.payload[12] & 0x0F);\n\n                if (_params.sys_params.recv_delay1 == 0) {\n                    _params.sys_params.recv_delay1 = 1;\n                }\n\n                _params.sys_params.recv_delay1 *= 1000;\n                _params.sys_params.recv_delay2 = _params.sys_params.recv_delay1 + 1000;\n\n                // Apply CF list\n                cflist.payload = &_params.payload[13];\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\n                cflist.size = size - 17;\n\n                lora_phy->apply_cf_list(&cflist);\n\n                mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_OK;\n                _params.is_nwk_joined = true;\n            } else {\n                mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;\n            }\n\n            break;\n\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\n            {\n                uint8_t value = lora_phy->get_max_payload(mcps.get_indication().rx_datarate, _params.is_repeater_supported);\n\n                if (MAX(0, (int16_t) ((int16_t)size - (int16_t)LORA_MAC_FRMPAYLOAD_OVERHEAD )) > (int32_t)value) {\n                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                    prepare_rx_done_abort();\n                    return;\n                }\n\n                address = payload[pkt_header_len++];\n                address |= ((uint32_t)payload[pkt_header_len++] << 8);\n                address |= ((uint32_t)payload[pkt_header_len++] << 16);\n                address |= ((uint32_t)payload[pkt_header_len++] << 24);\n\n                if (address != _params.dev_addr) {\n\n                    cur_multicast_params = _params.multicast_channels;\n\n                    while (cur_multicast_params != NULL) {\n\n                        if (address == cur_multicast_params->address) {\n                            multicast = 1;\n                            nwk_skey = cur_multicast_params->nwk_skey;\n                            app_skey = cur_multicast_params->app_skey;\n                            downlink_counter = cur_multicast_params->dl_frame_counter;\n                            break;\n                        }\n\n                        cur_multicast_params = cur_multicast_params->next;\n                    }\n\n                    if (multicast == 0) {\n                        // We are not the destination of this frame.\n                        mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\n                        prepare_rx_done_abort();\n                        return;\n                    }\n                } else {\n                    multicast = 0;\n                    nwk_skey = _params.keys.nwk_skey;\n                    app_skey = _params.keys.app_skey;\n                    downlink_counter = _params.dl_frame_counter;\n                }\n\n                fctrl.value = payload[pkt_header_len++];\n\n                sequence_counter = (uint16_t )payload[pkt_header_len++];\n                sequence_counter |= (uint16_t)payload[pkt_header_len++] << 8;\n\n                app_payload_start_index = 8 + fctrl.bits.fopts_len;\n\n                mic_rx |= (uint32_t)payload[size - LORAMAC_MFR_LEN];\n                mic_rx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 1] << 8);\n                mic_rx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 2] << 16);\n                mic_rx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 3] << 24);\n\n                sequence_counter_prev = (uint16_t)downlink_counter;\n                sequence_counter_diff = (sequence_counter - sequence_counter_prev);\n\n                if (sequence_counter_diff < (1 << 15)) {\n\n                    downlink_counter += sequence_counter_diff;\n                    compute_mic(payload, size - LORAMAC_MFR_LEN, nwk_skey,\n                                      address, DOWN_LINK, downlink_counter, &mic);\n                    if (mic_rx == mic) {\n                        is_mic_ok = true;\n                    }\n\n                } else {\n                    // check for sequence roll-over\n                    uint32_t  downlink_counter_tmp = downlink_counter + 0x10000 + (int16_t)sequence_counter_diff;\n                    compute_mic(payload, size - LORAMAC_MFR_LEN, nwk_skey,\n                                      address, DOWN_LINK, downlink_counter_tmp, &mic);\n\n                    if (mic_rx == mic ) {\n                        is_mic_ok = true;\n                        downlink_counter = downlink_counter_tmp;\n                    }\n                }\n\n                if (sequence_counter_diff >= lora_phy->get_maximum_frame_counter_gap()) {\n                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;\n                    mcps.get_indication().dl_frame_counter = downlink_counter;\n                    prepare_rx_done_abort( );\n                    return;\n                }\n\n                if (is_mic_ok == true) {\n                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_OK;\n                    mcps.get_indication().multicast = multicast;\n                    mcps.get_indication().fpending_status = fctrl.bits.fpending;\n                    mcps.get_indication().buffer = NULL;\n                    mcps.get_indication().buffer_size = 0;\n                    mcps.get_indication().dl_frame_counter = downlink_counter;\n\n                    mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_OK;\n\n                    _params.adr_ack_counter = 0;\n                    mac_commands.clear_repeat_buffer();\n\n                    // Update 32 bits downlink counter\n                    if (multicast == 1) {\n                        mcps.get_indication().type = MCPS_MULTICAST;\n\n                        if ((cur_multicast_params->dl_frame_counter == downlink_counter) &&\n                            (cur_multicast_params->dl_frame_counter != 0)) {\n\n                            mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n                            mcps.get_indication().dl_frame_counter = downlink_counter;\n                            prepare_rx_done_abort();\n\n                            return;\n                        }\n\n                        cur_multicast_params->dl_frame_counter = downlink_counter;\n\n                    } else {\n\n                        if (mac_hdr.bits.mtype == FRAME_TYPE_DATA_CONFIRMED_DOWN) {\n                            _params.is_srv_ack_requested = true;\n                            mcps.get_indication().type = MCPS_CONFIRMED;\n\n                            if ((_params.dl_frame_counter == downlink_counter ) &&\n                                (_params.dl_frame_counter != 0)) {\n                                // Duplicated confirmed downlink. Skip indication.\n                                // In this case, the MAC layer shall accept the MAC commands\n                                // which are included in the downlink retransmission.\n                                // It should not provide the same frame to the application\n                                // layer again.\n                                skip_indication = true;\n                            }\n                        } else {\n                            _params.is_srv_ack_requested = false;\n                            mcps.get_indication().type = MCPS_UNCONFIRMED;\n\n                            if ((_params.dl_frame_counter == downlink_counter) &&\n                                (_params.dl_frame_counter != 0)) {\n                                mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n                                mcps.get_indication().dl_frame_counter = downlink_counter;\n                                prepare_rx_done_abort();\n                                return;\n                            }\n                        }\n                        _params.dl_frame_counter = downlink_counter;\n                    }\n\n                    // This must be done before parsing the payload and the MAC commands.\n                    // We need to reset the MacCommandsBufferIndex here, since we need\n                    // to take retransmissions and repetitions into account. Error cases\n                    // will be handled in function OnMacStateCheckTimerEvent.\n                    if (mcps.get_confirmation().req_type == MCPS_CONFIRMED) {\n                        if (fctrl.bits.ack == 1) {\n                            // Reset MacCommandsBufferIndex when we have received an ACK.\n                            mac_commands.clear_command_buffer();\n                        }\n                    } else {\n                        // Reset the variable if we have received any valid frame.\n                        mac_commands.clear_command_buffer();\n                    }\n\n                    // Process payload and MAC commands\n                    if (((size - 4) - app_payload_start_index) > 0) {\n                        uint8_t port = payload[app_payload_start_index++];\n                        frame_len = (size - 4) - app_payload_start_index;\n\n                        mcps.get_indication().port = port;\n\n                        if (port == 0) {\n                            // Only allow frames which do not have fOpts\n                            if (fctrl.bits.fopts_len == 0) {\n                                if (0 != decrypt_payload(payload + app_payload_start_index,\n                                                               frame_len,\n                                                               nwk_skey,\n                                                               address,\n                                                               DOWN_LINK,\n                                                               downlink_counter,\n                                                               _params.payload)) {\n                                    mcps.get_indication().status =  LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n                                }\n\n                                // Decode frame payload MAC commands\n                                if (LORAWAN_STATUS_OK != mac_commands.process_mac_commands(\n                                            _params.payload, 0, frame_len, snr,\n                                            mlme.get_confirmation(), _params.sys_params, *lora_phy)) {\n                                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                                } else if (mac_commands.has_sticky_mac_cmd()) {\n                                    set_mlme_schedule_ul_indication();\n                                    mac_commands.clear_sticky_mac_cmd();\n                                }\n                            } else {\n                                skip_indication = true;\n                            }\n                        } else {\n                            if (fctrl.bits.fopts_len > 0) {\n                                // Decode Options field MAC commands. Omit the fPort.\n                                if (LORAWAN_STATUS_OK != mac_commands.process_mac_commands(\n                                            payload, 8, app_payload_start_index - 1, snr,\n                                            mlme.get_confirmation(), _params.sys_params, *lora_phy )) {\n                                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                                } else if (mac_commands.has_sticky_mac_cmd()) {\n                                    set_mlme_schedule_ul_indication();\n                                    mac_commands.clear_sticky_mac_cmd();\n                                }\n                            }\n\n                            if (0 != decrypt_payload(payload + app_payload_start_index,\n                                                           frame_len,\n                                                           app_skey,\n                                                           address,\n                                                           DOWN_LINK,\n                                                           downlink_counter,\n                                                           _params.payload)) {\n                                mcps.get_indication().status =  LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL;\n                            }\n\n                            if (skip_indication == false) {\n                                mcps.get_indication().buffer = _params.payload;\n                                mcps.get_indication().buffer_size = frame_len;\n                                mcps.get_indication().is_data_recvd = true;\n                            }\n                        }\n                    } else {\n                        if (fctrl.bits.fopts_len > 0) {\n                            // Decode Options field MAC commands\n                            if (LORAWAN_STATUS_OK != mac_commands.process_mac_commands(\n                                        payload, 8, app_payload_start_index, snr,\n                                        mlme.get_confirmation(),\n                                        _params.sys_params, *lora_phy)) {\n                                mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                            } else if (mac_commands.has_sticky_mac_cmd()) {\n                                set_mlme_schedule_ul_indication();\n                                mac_commands.clear_sticky_mac_cmd();\n                            }\n                        }\n                    }\n\n                    if (skip_indication == false) {\n                        // Check if the frame is an acknowledgement\n                        if (fctrl.bits.ack == 1) {\n                            mcps.get_confirmation().ack_received = true;\n                            mcps.get_indication().is_ack_recvd = true;\n\n                            // Stop the AckTimeout timer as no more retransmissions\n                            // are needed.\n                            _lora_time.stop(_params.timers.ack_timeout_timer);\n                        } else {\n                            mcps.get_confirmation().ack_received = false;\n\n                            if (_params.ack_timeout_retry_counter > _params.max_ack_timeout_retries) {\n                                // Stop the AckTimeout timer as no more retransmissions\n                                // are needed.\n                                _lora_time.stop( _params.timers.ack_timeout_timer );\n                            }\n                        }\n                    }\n                    // Provide always an indication, skip the callback to the user application,\n                    // in case of a confirmed downlink retransmission.\n                    _params.flags.bits.mcps_ind = 1;\n                    _params.flags.bits.mcps_ind_skip = skip_indication;\n                } else {\n                    mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\n\n                    prepare_rx_done_abort( );\n                    return;\n                }\n            }\n\n            break;\n\n        case FRAME_TYPE_PROPRIETARY:\n            {\n                memcpy(_params.payload, &payload[pkt_header_len], size);\n\n                mcps.get_indication().type = MCPS_PROPRIETARY;\n                mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_OK;\n                mcps.get_indication().buffer = _params.payload;\n                mcps.get_indication().buffer_size = size - pkt_header_len;\n\n                _params.flags.bits.mcps_ind = 1;\n                break;\n            }\n        default:\n            mcps.get_indication().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n            prepare_rx_done_abort();\n            break;\n    }\n    _params.flags.bits.mac_done = 1;\n\n    _lora_time.start(_params.timers.mac_state_check_timer, 1);\n}\n\nvoid LoRaMac::on_radio_tx_timeout( void )\n{\n    tr_info(\"on_radio_tx_timeout\");\n\n    if (_params.dev_class != CLASS_C) {\n        lora_phy->put_radio_to_sleep();\n    } else {\n        open_continuous_rx2_window();\n    }\n\n    mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\n\n    mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\n\n    _params.flags.bits.mac_done = 1;\n}\n\nvoid LoRaMac::on_radio_rx_error( void )\n{\n    tr_info(\"on_radio_rx_error\");\n\n    if (_params.dev_class != CLASS_C) {\n        lora_phy->put_radio_to_sleep();\n    } else {\n        open_continuous_rx2_window();\n    }\n\n    if (_params.rx_slot == RX_SLOT_WIN_1) {\n        if (_params.is_node_ack_requested == true) {\n            mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX1_ERROR;\n        }\n\n        mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX1_ERROR;\n\n        if (_lora_time.get_elapsed_time(_params.timers.aggregated_last_tx_time) >= _params.rx_window2_delay) {\n            _lora_time.stop(_params.timers.rx_window2_timer);\n            _params.flags.bits.mac_done = 1;\n        }\n\n    } else {\n\n        if (_params.is_node_ack_requested == true) {\n            mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX2_ERROR;\n        }\n\n        mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX2_ERROR;\n\n        _params.flags.bits.mac_done = 1;\n    }\n}\n\nvoid LoRaMac::on_radio_rx_timeout(void)\n{\n    tr_info(\"on_radio_rx_timeout\");\n\n    if (_params.dev_class != CLASS_C) {\n        lora_phy->put_radio_to_sleep();\n    } else {\n        open_continuous_rx2_window();\n    }\n\n    if (_params.rx_slot == RX_SLOT_WIN_1) {\n        if (_params.is_node_ack_requested == true) {\n            mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT;\n        }\n        mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT;\n\n        if (_lora_time.get_elapsed_time(_params.timers.aggregated_last_tx_time ) >= _params.rx_window2_delay) {\n            _lora_time.stop(_params.timers.rx_window2_timer);\n            _params.flags.bits.mac_done = 1;\n        }\n\n    } else {\n\n        if (_params.is_node_ack_requested == true) {\n            mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;\n        }\n\n        mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;\n\n        if (_params.dev_class != CLASS_C) {\n            _params.flags.bits.mac_done = 1;\n        }\n    }\n\n    _lora_time.start(_params.timers.mac_state_check_timer, 1);\n}\n\n/***************************************************************************\n * Timer event callbacks - deliberated locally                             *\n **************************************************************************/\nvoid LoRaMac::on_mac_state_check_timer_event(void)\n{\n    bool tx_timeout = false;\n\n    _lora_time.stop(_params.timers.mac_state_check_timer);\n\n    if (_params.flags.bits.mac_done == 1) {\n\n        if ((_params.mac_state & LORAMAC_RX_ABORT) == LORAMAC_RX_ABORT) {\n            _params.mac_state &= ~LORAMAC_RX_ABORT;\n            _params.mac_state &= ~LORAMAC_TX_RUNNING;\n        }\n\n        if ((_params.flags.bits.mlme_req == 1) || (_params.flags.bits.mcps_req == 1)) {\n\n            if ((mcps.get_confirmation().status == LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT) ||\n                ( mlme.get_confirmation().status == LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT)) {\n                // Stop transmit cycle due to tx timeout.\n                _params.mac_state &= ~LORAMAC_TX_RUNNING;\n                mac_commands.clear_command_buffer();\n                mcps.get_confirmation().nb_retries = _params.ack_timeout_retry_counter;\n                mcps.get_confirmation().ack_received = false;\n                mcps.get_confirmation().tx_toa = 0;\n                tx_timeout = true;\n            }\n        }\n\n        if ((_params.is_node_ack_requested == false) && (tx_timeout == false)) {\n            if ((_params.flags.bits.mlme_req == 1) || ((_params.flags.bits.mcps_req == 1))) {\n                if ((_params.flags.bits.mlme_req == 1) && (mlme.get_confirmation().req_type == MLME_JOIN)) {\n                    // Procedure for the join request\n                    mlme.get_confirmation().nb_retries = _params.join_request_trial_counter;\n\n                    if (mlme.get_confirmation().status == LORAMAC_EVENT_INFO_STATUS_OK) {\n                        // Node joined successfully\n                        _params.ul_frame_counter = 0;\n                        _params.ul_nb_rep_counter = 0;\n                        _params.mac_state &= ~LORAMAC_TX_RUNNING;\n                    } else {\n                        if (_params.join_request_trial_counter >= _params.max_join_request_trials) {\n                            _params.mac_state &= ~LORAMAC_TX_RUNNING;\n                        } else {\n                            _params.flags.bits.mac_done = 0;\n                            // Sends the same frame again\n                            handle_delayed_tx_timer_event();\n                        }\n                    }\n                } else {\n                    // Procedure for all other frames\n                    if ((_params.ul_nb_rep_counter >= _params.sys_params.retry_num) ||\n                        (_params.flags.bits.mcps_ind == 1)) {\n                        if (_params.flags.bits.mcps_ind == 0) {\n                            // Maximum repetitions without downlink. Reset MacCommandsBufferIndex. Increase ADR Ack counter.\n                            // Only process the case when the MAC did not receive a downlink.\n                            mac_commands.clear_command_buffer();\n                            _params.adr_ack_counter++;\n                        }\n\n                        _params.ul_nb_rep_counter = 0;\n\n                        if (_params.is_ul_frame_counter_fixed == false) {\n                            _params.ul_frame_counter++;\n                        }\n\n                        _params.mac_state &= ~LORAMAC_TX_RUNNING;\n                    } else {\n                        _params.flags.bits.mac_done = 0;\n                        // Sends the same frame again\n                        handle_delayed_tx_timer_event();\n                    }\n                }\n            }\n        }\n\n        if (_params.flags.bits.mcps_ind == 1) {\n            // Procedure if we received a frame\n            if ((mcps.get_confirmation().ack_received == true) ||\n                (_params.ack_timeout_retry_counter > _params.max_ack_timeout_retries)) {\n                _params.is_ack_retry_timeout_expired = false;\n                _params.is_node_ack_requested = false;\n                if (_params.is_ul_frame_counter_fixed == false) {\n                    _params.ul_frame_counter++;\n                }\n                mcps.get_confirmation().nb_retries = _params.ack_timeout_retry_counter;\n\n                _params.mac_state &= ~LORAMAC_TX_RUNNING;\n            }\n        }\n\n        if ((_params.is_ack_retry_timeout_expired == true) &&\n            ((_params.mac_state & LORAMAC_TX_DELAYED) == 0)) {\n\n            // Retransmissions procedure for confirmed uplinks\n            _params.is_ack_retry_timeout_expired = false;\n            if ((_params.ack_timeout_retry_counter < _params.max_ack_timeout_retries) &&\n                (_params.ack_timeout_retry_counter <= MAX_ACK_RETRIES)) {\n\n                _params.ack_timeout_retry_counter++;\n\n                if ((_params.ack_timeout_retry_counter % 2) == 1) {\n                    _params.sys_params.channel_data_rate = lora_phy->get_next_lower_tx_datarate(\n                                                           _params.sys_params.channel_data_rate);\n                }\n\n                // Try to send the frame again\n                if (schedule_tx() == LORAWAN_STATUS_OK) {\n                    _params.flags.bits.mac_done = 0;\n                } else {\n                    // The DR is not applicable for the payload size\n                    mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;\n\n                    mac_commands.clear_command_buffer();\n                    _params.mac_state &= ~LORAMAC_TX_RUNNING;\n                    _params.is_node_ack_requested = false;\n                    mcps.get_confirmation().ack_received = false;\n                    mcps.get_confirmation().nb_retries = _params.ack_timeout_retry_counter;\n                    mcps.get_confirmation().data_rate = _params.sys_params.channel_data_rate;\n\n                    if (_params.is_ul_frame_counter_fixed == false) {\n                        _params.ul_frame_counter++;\n                    }\n                }\n            } else {\n                lora_phy->restore_default_channels();\n\n                _params.mac_state &= ~LORAMAC_TX_RUNNING;\n\n                mac_commands.clear_command_buffer();\n                _params.is_node_ack_requested = false;\n                mcps.get_confirmation().ack_received = false;\n                mcps.get_confirmation().nb_retries = _params.ack_timeout_retry_counter;\n\n                if (_params.is_ul_frame_counter_fixed == false) {\n                    _params.ul_frame_counter++;\n                }\n            }\n        }\n    }\n\n    // Handle reception for Class B and Class C\n    if ((_params.mac_state & LORAMAC_RX) == LORAMAC_RX) {\n        _params.mac_state &= ~LORAMAC_RX;\n    }\n\n    if (_params.mac_state == LORAMAC_IDLE) {\n        if (_params.flags.bits.mcps_req == 1) {\n            _params.flags.bits.mcps_req = 0;\n            mac_primitives->mcps_confirm(&mcps.get_confirmation());\n        }\n\n        if (_params.flags.bits.mlme_req == 1) {\n            _params.flags.bits.mlme_req = 0;\n            mac_primitives->mlme_confirm(&mlme.get_confirmation());\n        }\n\n        // Verify if sticky MAC commands are pending or not\n        if (mac_commands.is_sticky_mac_command_pending() == true) {\n            // Setup MLME indication\n            set_mlme_schedule_ul_indication();\n        }\n\n        // Procedure done. Reset variables.\n        _params.flags.bits.mac_done = 0;\n    } else {\n        // Operation not finished restart timer\n        _lora_time.start(_params.timers.mac_state_check_timer, MAC_STATE_CHECK_TIMEOUT);\n    }\n\n    // Handle MCPS indication\n    if (_params.flags.bits.mcps_ind == 1) {\n        _params.flags.bits.mcps_ind = 0;\n\n        if (_params.dev_class== CLASS_C) {\n            // Activate RX2 window for Class C\n            open_continuous_rx2_window();\n        }\n\n        if (_params.flags.bits.mcps_ind_skip == 0) {\n            mac_primitives->mcps_indication(&mcps.get_indication());\n        }\n\n        _params.flags.bits.mcps_ind_skip = 0;\n    }\n\n    // Handle MLME indication\n    if (_params.flags.bits.mlme_ind == 1) {\n        _params.flags.bits.mlme_ind = 0;\n        mac_primitives->mlme_indication(&mlme.get_indication());\n    }\n}\n\nvoid LoRaMac::on_tx_delayed_timer_event(void)\n{\n    tr_info(\"on_tx_delayed_timer_event\");\n\n    loramac_mhdr_t mac_hdr;\n    loramac_frame_ctrl_t fctrl;\n\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    _lora_time.stop(_params.timers.tx_delayed_timer);\n    _params.mac_state &= ~LORAMAC_TX_DELAYED;\n\n    if ((_params.flags.bits.mlme_req == 1 ) &&\n        (mlme.get_confirmation().req_type == MLME_JOIN)) {\n\n        reset_mac_parameters();\n\n        _params.sys_params.channel_data_rate = lora_phy->get_alternate_DR(_params.join_request_trial_counter + 1);\n\n        mac_hdr.value = 0;\n        mac_hdr.bits.mtype = FRAME_TYPE_JOIN_REQ;\n\n        fctrl.value = 0;\n        fctrl.bits.adr = _params.sys_params.adr_on;\n\n        /* In case of join request retransmissions, the stack must prepare\n         * the frame again, because the network server keeps track of the random\n         * LoRaMacDevNonce values to prevent reply attacks. */\n        status = prepare_frame(&mac_hdr, &fctrl, 0, NULL, 0);\n    }\n\n    if (status == LORAWAN_STATUS_OK) {\n        schedule_tx();\n    } else {\n        tr_error(\"Delayed TX: PrepareFrame returned error %d\", status);\n    }\n}\n\nvoid LoRaMac::on_rx_window1_timer_event(void)\n{\n    tr_info(\"on_rx_window1_timer_event\");\n\n    _lora_time.stop(_params.timers.rx_window1_timer);\n    _params.rx_slot = RX_SLOT_WIN_1;\n\n    _params.rx_window1_config.channel = _params.channel;\n    _params.rx_window1_config.dr_offset = _params.sys_params.rx1_dr_offset;\n    _params.rx_window1_config.dl_dwell_time = _params.sys_params.downlink_dwell_time;\n    _params.rx_window1_config.is_repeater_supported = _params.is_repeater_supported;\n    _params.rx_window1_config.is_rx_continuous = false;\n    _params.rx_window1_config.rx_slot = _params.rx_slot;\n\n    if (_params.dev_class == CLASS_C) {\n        lora_phy->put_radio_to_standby();\n    }\n\n    lora_phy->rx_config(&_params.rx_window1_config,\n                        (int8_t*) &mcps.get_indication().rx_datarate);\n\n    rx_window_setup(_params.rx_window1_config.is_rx_continuous,\n                    _params.sys_params.max_rx_win_time);\n}\n\nvoid LoRaMac::on_rx_window2_timer_event(void)\n{\n    tr_info(\"on_rx_window2_timer_event\");\n\n    _lora_time.stop(_params.timers.rx_window2_timer);\n\n    _params.rx_window2_config.channel = _params.channel;\n    _params.rx_window2_config.frequency = _params.sys_params.rx2_channel.frequency;\n    _params.rx_window2_config.dl_dwell_time = _params.sys_params.downlink_dwell_time;\n    _params.rx_window2_config.is_repeater_supported = _params.is_repeater_supported;\n    _params.rx_window2_config.rx_slot = RX_SLOT_WIN_2;\n\n    if (_params.dev_class != CLASS_C) {\n        _params.rx_window2_config.is_rx_continuous = false;\n    } else {\n        // Setup continuous listening for class c\n        _params.rx_window2_config.is_rx_continuous = true;\n    }\n\n    if (lora_phy->rx_config(&_params.rx_window2_config,\n                            (int8_t*) &mcps.get_indication().rx_datarate) == true) {\n\n        rx_window_setup(_params.rx_window2_config.is_rx_continuous,\n                        _params.sys_params.max_rx_win_time);\n\n        _params.rx_slot = RX_SLOT_WIN_2;\n    }\n}\n\nvoid LoRaMac::on_ack_timeout_timer_event(void)\n{\n    tr_info(\"on_ack_timeout_timer_event\");\n\n    _lora_time.stop(_params.timers.ack_timeout_timer);\n\n    if (_params.is_node_ack_requested == true) {\n        _params.is_ack_retry_timeout_expired = true;\n        _params.mac_state &= ~LORAMAC_ACK_REQ;\n    }\n    if (_params.dev_class == CLASS_C) {\n        _params.flags.bits.mac_done = 1;\n    }\n}\n\nvoid LoRaMac::rx_window_setup(bool rx_continuous, uint32_t max_rx_window_time)\n{\n    tr_info(\"rx_window_setup\");\n\n    lora_phy->setup_rx_window(rx_continuous, max_rx_window_time);\n}\n\nbool LoRaMac::validate_payload_length(uint8_t length, int8_t datarate,\n                                      uint8_t fopts_len)\n{\n    tr_info(\"validate_payload_length\");\n\n    uint16_t max_value = 0;\n    uint16_t payloadSize = 0;\n\n    max_value = lora_phy->get_max_payload(datarate, _params.is_repeater_supported);\n\n    // Calculate the resulting payload size\n    payloadSize = (length + fopts_len);\n\n    // Validation of the application payload size\n    if ((payloadSize <= max_value) &&\n        (payloadSize <= LORAMAC_PHY_MAXPAYLOAD)) {\n        return true;\n    }\n    return false;\n}\n\nvoid LoRaMac::set_mlme_schedule_ul_indication(void)\n{\n    tr_info(\"set_mlme_schedule_ul_indication\");\n\n    mlme.get_indication().indication_type = MLME_SCHEDULE_UPLINK;\n    _params.flags.bits.mlme_ind = 1;\n}\n\n// This is not actual transmission. It just schedules a message in response\n// to MCPS request\nlorawan_status_t LoRaMac::send(loramac_mhdr_t *machdr, uint8_t fport,\n                               void *fbuffer, uint16_t fbuffer_size)\n{\n    loramac_frame_ctrl_t fctrl;\n\n    fctrl.value = 0;\n    fctrl.bits.fopts_len = 0;\n    fctrl.bits.fpending = 0;\n    fctrl.bits.ack = false;\n    fctrl.bits.adr_ack_req = false;\n    fctrl.bits.adr = _params.sys_params.adr_on;\n\n    // Prepare the frame\n    lorawan_status_t status = prepare_frame(machdr, &fctrl, fport, fbuffer,\n                                            fbuffer_size);\n\n    // Validate status\n    if (status != LORAWAN_STATUS_OK) {\n        return status;\n    }\n\n    // Reset confirm parameters\n    mcps.get_confirmation().nb_retries = 0;\n    mcps.get_confirmation().ack_received = false;\n    mcps.get_confirmation().ul_frame_counter = _params.ul_frame_counter;\n\n    status = schedule_tx();\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::schedule_tx(void)\n{\n    lorawan_time_t dutyCycleTimeOff = 0;\n    channel_selection_params_t nextChan;\n\n    // Check if the device is off\n    if (_params.sys_params.max_duty_cycle == 255) {\n        return LORAWAN_STATUS_DEVICE_OFF;\n    }\n\n    if (_params.sys_params.max_duty_cycle == 0) {\n        _params.timers.aggregated_timeoff = 0;\n    }\n\n    // Update Backoff\n    calculate_backOff(_params.last_channel_idx);\n\n    nextChan.aggregate_timeoff = _params.timers.aggregated_timeoff;\n    nextChan.current_datarate = _params.sys_params.channel_data_rate;\n    _params.is_dutycycle_on = MBED_CONF_LORA_DUTY_CYCLE_ON;\n    nextChan.dc_enabled = _params.is_dutycycle_on;\n    nextChan.joined = _params.is_nwk_joined;\n    nextChan.last_aggregate_tx_time = _params.timers.aggregated_last_tx_time;\n\n    // Select channel\n    while (lora_phy->set_next_channel(&nextChan, &_params.channel,\n                                      &dutyCycleTimeOff,\n                                      &_params.timers.aggregated_timeoff) == false) {\n        _params.sys_params.channel_data_rate = lora_phy->get_default_tx_datarate();\n        // Update datarate in the function parameters\n        nextChan.current_datarate = _params.sys_params.channel_data_rate;\n    }\n\n    tr_debug(\"Next Channel Idx=%d, DR=%d\", _params.channel, nextChan.current_datarate);\n\n    // Compute Rx1 windows parameters\n    uint8_t dr_offset = lora_phy->apply_DR_offset(_params.sys_params.channel_data_rate,\n                                                  _params.sys_params.rx1_dr_offset);\n\n    lora_phy->compute_rx_win_params(dr_offset, _params.sys_params.min_rx_symb,\n                                    _params.sys_params.max_sys_rx_error,\n                                    &_params.rx_window1_config);\n\n    // Compute Rx2 windows parameters\n    lora_phy->compute_rx_win_params(_params.sys_params.rx2_channel.datarate,\n                                    _params.sys_params.min_rx_symb,\n                                    _params.sys_params.max_sys_rx_error,\n                                    &_params.rx_window2_config);\n\n    if (_params.is_nwk_joined == false) {\n        _params.rx_window1_delay = _params.sys_params.join_accept_delay1\n                + _params.rx_window1_config.window_offset;\n        _params.rx_window2_delay = _params.sys_params.join_accept_delay2\n                + _params.rx_window2_config.window_offset;\n    } else {\n        if (validate_payload_length(_params.payload_length,\n                                    _params.sys_params.channel_data_rate,\n                                    mac_commands.get_mac_cmd_length()) == false) {\n            return LORAWAN_STATUS_LENGTH_ERROR;\n        }\n        _params.rx_window1_delay = _params.sys_params.recv_delay1\n                + _params.rx_window1_config.window_offset;\n        _params.rx_window2_delay = _params.sys_params.recv_delay2\n                + _params.rx_window2_config.window_offset;\n    }\n\n    // Schedule transmission of frame\n    if (dutyCycleTimeOff == 0) {\n        // Try to send now\n        return send_frame_on_channel(_params.channel);\n    } else {\n        // Send later - prepare timer\n        _params.mac_state |= LORAMAC_TX_DELAYED;\n        tr_debug(\"Next Transmission in %lu ms\", dutyCycleTimeOff);\n\n        _lora_time.start(_params.timers.tx_delayed_timer, dutyCycleTimeOff);\n\n        return LORAWAN_STATUS_OK;\n    }\n}\n\nvoid LoRaMac::calculate_backOff(uint8_t channel)\n{\n    backoff_params_t backoff_params;\n\n    backoff_params.joined = _params.is_nwk_joined;\n    _params.is_dutycycle_on = MBED_CONF_LORA_DUTY_CYCLE_ON;\n    backoff_params.dc_enabled = _params.is_dutycycle_on;\n    backoff_params.channel = channel;\n    backoff_params.elapsed_time = _lora_time.get_elapsed_time(_params.timers.mac_init_time);\n    backoff_params.tx_toa = _params.timers.tx_toa;\n    backoff_params.last_tx_was_join_req = _params.is_last_tx_join_request;\n\n    // Update regional back-off\n    lora_phy->calculate_backoff(&backoff_params);\n\n    // Update aggregated time-off\n    _params.timers.aggregated_timeoff = _params.timers.aggregated_timeoff\n            + (_params.timers.tx_toa * _params.sys_params.aggregated_duty_cycle\n            - _params.timers.tx_toa);\n}\n\nvoid LoRaMac::reset_mac_parameters(void)\n{\n    _params.is_nwk_joined = false;\n\n    // Counters\n    _params.ul_frame_counter = 0;\n    _params.dl_frame_counter = 0;\n    _params.adr_ack_counter = 0;\n\n    _params.ul_nb_rep_counter = 0;\n\n    _params.max_ack_timeout_retries = 1;\n    _params.ack_timeout_retry_counter = 1;\n    _params.is_ack_retry_timeout_expired = false;\n\n    _params.sys_params.max_duty_cycle = 0;\n    _params.sys_params.aggregated_duty_cycle = 1;\n\n    mac_commands.clear_command_buffer();\n    mac_commands.clear_repeat_buffer();\n    mac_commands.clear_mac_commands_in_next_tx();\n\n    _params.is_rx_window_enabled = true;\n\n    lora_phy->reset_to_default_values(&_params, false);\n\n    _params.is_node_ack_requested = false;\n    _params.is_srv_ack_requested = false;\n\n    // Reset Multicast downlink counters\n    multicast_params_t *cur = _params.multicast_channels;\n    while (cur != NULL) {\n        cur->dl_frame_counter = 0;\n        cur = cur->next;\n    }\n\n    // Initialize channel index.\n    _params.channel = 0;\n    _params.last_channel_idx = _params.channel;\n}\n\nbool LoRaMac::is_fPort_allowed (uint8_t fPort)\n{\n    if ((fPort == 0) || (fPort > 224)) {\n        return false;\n    }\n    return true;\n}\n\nvoid LoRaMac::open_continuous_rx2_window (void)\n{\n    handle_rx2_timer_event();\n    _params.rx_slot = RX_SLOT_WIN_CLASS_C;\n}\n\nstatic void memcpy_convert_endianess(uint8_t *dst, const uint8_t *src,\n                                     uint16_t size)\n{\n    dst = dst + (size - 1);\n    while (size--) {\n        *dst-- = *src++;\n    }\n}\n\nlorawan_status_t LoRaMac::prepare_frame(loramac_mhdr_t *machdr,\n                                        loramac_frame_ctrl_t *fctrl,\n                                        uint8_t fport, void *fbuffer,\n                                        uint16_t fbuffer_size)\n{\n    uint16_t i;\n    uint8_t pkt_header_len = 0;\n    uint32_t mic = 0;\n    const void* payload = fbuffer;\n    uint8_t frame_port = fport;\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    _params.buffer_pkt_len = 0;\n\n    _params.is_node_ack_requested = false;\n\n    if (fbuffer == NULL) {\n        fbuffer_size = 0;\n    }\n\n    _params.payload_length = fbuffer_size;\n\n    _params.buffer[pkt_header_len++] = machdr->value;\n\n    switch (machdr->bits.mtype) {\n\n        case FRAME_TYPE_JOIN_REQ:\n\n            _params.buffer_pkt_len = pkt_header_len;\n            memcpy_convert_endianess(_params.buffer + _params.buffer_pkt_len,\n                                     _params.keys.app_eui, 8);\n            _params.buffer_pkt_len += 8;\n            memcpy_convert_endianess(_params.buffer + _params.buffer_pkt_len,\n                                     _params.keys.dev_eui, 8);\n            _params.buffer_pkt_len += 8;\n\n            _params.dev_nonce = lora_phy->get_radio_rng();\n\n            _params.buffer[_params.buffer_pkt_len++] = _params.dev_nonce & 0xFF;\n            _params.buffer[_params.buffer_pkt_len++] = (_params.dev_nonce >> 8) & 0xFF;\n\n            if (0 != compute_join_frame_mic(_params.buffer,\n                                           _params.buffer_pkt_len & 0xFF,\n                                           _params.keys.app_key, &mic)) {\n                return LORAWAN_STATUS_CRYPTO_FAIL;\n            }\n\n            _params.buffer[_params.buffer_pkt_len++] = mic & 0xFF;\n            _params.buffer[_params.buffer_pkt_len++] = (mic >> 8) & 0xFF;\n            _params.buffer[_params.buffer_pkt_len++] = (mic >> 16) & 0xFF;\n            _params.buffer[_params.buffer_pkt_len++] = (mic >> 24) & 0xFF;\n\n            break;\n        case FRAME_TYPE_DATA_CONFIRMED_UP:\n            _params.is_node_ack_requested = true;\n            //Intentional fallthrough\n        case FRAME_TYPE_DATA_UNCONFIRMED_UP: {\n            if (_params.is_nwk_joined == false) {\n                // No network has been joined yet\n                return LORAWAN_STATUS_NO_NETWORK_JOINED;\n            }\n\n            if (_params.sys_params.adr_on) {\n                if (lora_phy->get_next_ADR(true,\n                                           _params.sys_params.channel_data_rate,\n                                           _params.sys_params.channel_tx_power,\n                                           _params.adr_ack_counter)) {\n                    fctrl->bits.adr_ack_req = 1;\n                }\n            }\n\n            if (_params.is_srv_ack_requested == true) {\n                _params.is_srv_ack_requested = false;\n                fctrl->bits.ack = 1;\n            }\n\n            _params.buffer[pkt_header_len++] = (_params.dev_addr) & 0xFF;\n            _params.buffer[pkt_header_len++] = (_params.dev_addr >> 8) & 0xFF;\n            _params.buffer[pkt_header_len++] = (_params.dev_addr >> 16) & 0xFF;\n            _params.buffer[pkt_header_len++] = (_params.dev_addr >> 24) & 0xFF;\n\n            _params.buffer[pkt_header_len++] = fctrl->value;\n\n            _params.buffer[pkt_header_len++] = _params.ul_frame_counter & 0xFF;\n            _params.buffer[pkt_header_len++] = (_params.ul_frame_counter >> 8)\n                    & 0xFF;\n\n            // Copy the MAC commands which must be re-send into the MAC command buffer\n            mac_commands.copy_repeat_commands_to_buffer();\n\n            const uint8_t mac_commands_len = mac_commands.get_mac_cmd_length();\n\n            if ((payload != NULL) && (_params.payload_length > 0)) {\n                if (mac_commands.is_mac_command_in_next_tx() == true) {\n                    if (mac_commands_len <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH) {\n                        fctrl->bits.fopts_len += mac_commands_len;\n\n                        // Update FCtrl field with new value of OptionsLength\n                        _params.buffer[0x05] = fctrl->value;\n\n                        const uint8_t *buffer =\n                                mac_commands.get_mac_commands_buffer();\n                        for (i = 0; i < mac_commands_len; i++) {\n                            _params.buffer[pkt_header_len++] = buffer[i];\n                        }\n                    } else {\n                        _params.payload_length = mac_commands_len;\n                        payload = mac_commands.get_mac_commands_buffer();\n                        frame_port = 0;\n                    }\n                }\n            } else {\n                if ((mac_commands_len > 0)\n                        && (mac_commands.is_mac_command_in_next_tx() == true)) {\n                    _params.payload_length = mac_commands_len;\n                    payload = mac_commands.get_mac_commands_buffer();\n                    frame_port = 0;\n                }\n            }\n\n            // Store MAC commands which must be re-send in case the device does not receive a downlink anymore\n            mac_commands.parse_mac_commands_to_repeat();\n\n            if ((payload != NULL) && (_params.payload_length > 0)) {\n                _params.buffer[pkt_header_len++] = frame_port;\n\n                if (frame_port == 0) {\n                    // Reset buffer index as the mac commands are being sent on port 0\n                    mac_commands.clear_command_buffer();\n                    if (0 != encrypt_payload((uint8_t*) payload, _params.payload_length,\n                                                   _params.keys.nwk_skey, _params.dev_addr,\n                                                   UP_LINK,\n                                                   _params.ul_frame_counter,\n                                                   &_params.buffer[pkt_header_len])) {\n                        status = LORAWAN_STATUS_CRYPTO_FAIL;\n                    }\n                } else {\n                    if (0 != encrypt_payload((uint8_t*) payload, _params.payload_length,\n                                                   _params.keys.app_skey, _params.dev_addr,\n                                                   UP_LINK,\n                                                   _params.ul_frame_counter,\n                                                   &_params.buffer[pkt_header_len])) {\n                        status = LORAWAN_STATUS_CRYPTO_FAIL;\n                    }\n                }\n            }\n\n            _params.buffer_pkt_len = pkt_header_len + _params.payload_length;\n\n            if (0 != compute_mic(_params.buffer, _params.buffer_pkt_len,\n                                       _params.keys.nwk_skey,\n                                       _params.dev_addr,\n                                       UP_LINK,\n                                       _params.ul_frame_counter, &mic)) {\n                status = LORAWAN_STATUS_CRYPTO_FAIL;\n            }\n\n            _params.buffer[_params.buffer_pkt_len + 0] = mic & 0xFF;\n            _params.buffer[_params.buffer_pkt_len + 1] = (mic >> 8) & 0xFF;\n            _params.buffer[_params.buffer_pkt_len + 2] = (mic >> 16) & 0xFF;\n            _params.buffer[_params.buffer_pkt_len + 3] = (mic >> 24) & 0xFF;\n\n            _params.buffer_pkt_len += LORAMAC_MFR_LEN;\n        }\n            break;\n        case FRAME_TYPE_PROPRIETARY:\n            if ((fbuffer != NULL) && (_params.payload_length > 0)) {\n                memcpy(_params.buffer + pkt_header_len, (uint8_t*) fbuffer,\n                       _params.payload_length);\n                _params.buffer_pkt_len = pkt_header_len + _params.payload_length;\n            }\n            break;\n        default:\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::send_frame_on_channel(uint8_t channel)\n{\n    tr_info(\"send_frame_on_channel\");\n\n    tx_config_params_t tx_config;\n    int8_t tx_power = 0;\n\n    tx_config.channel = channel;\n    tx_config.datarate = _params.sys_params.channel_data_rate;\n    tx_config.tx_power = _params.sys_params.channel_tx_power;\n    tx_config.max_eirp = _params.sys_params.max_eirp;\n    tx_config.antenna_gain = _params.sys_params.antenna_gain;\n    tx_config.pkt_len = _params.buffer_pkt_len;\n\n    lora_phy->tx_config(&tx_config, &tx_power, &_params.timers.tx_toa);\n\n    mlme.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n\n    mcps.get_confirmation().status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n    mcps.get_confirmation().data_rate = _params.sys_params.channel_data_rate;\n    mcps.get_confirmation().tx_power = tx_power;\n\n    // Store the time on air\n    mcps.get_confirmation().tx_toa = _params.timers.tx_toa;\n    mlme.get_confirmation().tx_toa = _params.timers.tx_toa;\n\n    // Starts the MAC layer status check timer\n    // _lora_time.start(_params.timers.mac_state_check_timer,\n    //                  MAC_STATE_CHECK_TIMEOUT);\n\n    if (_params.is_nwk_joined == false) {\n        _params.join_request_trial_counter++;\n    }\n\n    // Send now\n    lora_phy->handle_send(_params.buffer, _params.buffer_pkt_len);\n\n    _params.mac_state |= LORAMAC_TX_RUNNING;\n\n    return LORAWAN_STATUS_OK;\n}\n\n//lorawan_status_t LoRaMac::set_tx_continuous_wave(uint16_t timeout)\n//{\n//    cw_mode_params_t continuous_wave;\n\n//    continuous_wave.channel = _params.channel;\n//    continuous_wave.datarate = _params.sys_params.channel_data_rate;\n//    continuous_wave.tx_power = _params.sys_params.channel_tx_power;\n//    continuous_wave.max_eirp = _params.sys_params.max_eirp;\n//    continuous_wave.antenna_gain = _params.sys_params.antenna_gain;\n//    continuous_wave.timeout = timeout;\n\n//    lora_phy->set_tx_cont_mode(&continuous_wave);\n\n//    // Starts the MAC layer status check timer\n//    _lora_time.start(_params.timers.mac_state_check_timer,\n//                     MAC_STATE_CHECK_TIMEOUT);\n\n//    _params.mac_state |= LORAMAC_TX_RUNNING;\n\n//    return LORAWAN_STATUS_OK;\n//}\n\n//lorawan_status_t LoRaMac::set_tx_continuous_wave1(uint16_t timeout,\n//                                                  uint32_t frequency,\n//                                                  uint8_t power)\n//{\n//    cw_mode_params_t continuous_wave;\n\n//    continuous_wave.channel = 0;\n//    continuous_wave.datarate = 0;\n//    continuous_wave.tx_power = power;\n//    continuous_wave.max_eirp = 0;\n//    continuous_wave.antenna_gain = 0;\n//    continuous_wave.timeout = timeout;\n\n//    lora_phy->set_tx_cont_mode(&continuous_wave);\n\n//    // Starts the MAC layer status check timer\n//    _lora_time.start(_params.timers.mac_state_check_timer,\n//                     MAC_STATE_CHECK_TIMEOUT);\n\n//    _params.mac_state |= LORAMAC_TX_RUNNING;\n\n//    return LORAWAN_STATUS_OK;\n//}\n\nlorawan_status_t LoRaMac::initialize(loramac_primitives_t *primitives,\n                                     LoRaPHY *phy, EventQueue *queue)\n{\n    //store event queue pointer\n    ev_queue = queue;\n\n    if (!primitives) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    lora_phy = phy;\n\n    // Activate MLME subsystem\n    mlme.activate_mlme_subsystem(lora_phy);\n\n    // Activate MCPS subsystem\n    mcps.activate_mcps_subsystem();\n\n    // Activate MIB subsystem\n    mib.activate_mib_subsystem(lora_phy);\n\n    // Activate channel planning subsystem\n    channel_plan.activate_channelplan_subsystem(lora_phy);\n\n    mac_primitives = primitives;\n\n    _params.flags.value = 0;\n\n    _params.dev_class = CLASS_A;\n    _params.mac_state = LORAMAC_IDLE;\n\n    _params.join_request_trial_counter = 0;\n    _params.max_join_request_trials = 1;\n    _params.is_repeater_supported = false;\n\n    // Reset duty cycle times\n    _params.timers.aggregated_last_tx_time = 0;\n    _params.timers.aggregated_timeoff = 0;\n\n    lora_phy->reset_to_default_values(&_params, true);\n\n    // Init parameters which are not set in function ResetMacParameters\n    _params.sys_params.max_sys_rx_error = 10;\n    _params.sys_params.min_rx_symb = 6;\n    _params.sys_params.retry_num = 1;\n\n    reset_mac_parameters();\n\n    // Random seed initialization\n    srand(lora_phy->get_radio_rng());\n\n    _params.is_nwk_public = MBED_CONF_LORA_PUBLIC_NETWORK;\n    lora_phy->setup_public_network_mode(_params.is_nwk_public);\n    lora_phy->put_radio_to_sleep();\n\n    // Initialize timers\n    _lora_time.init(_params.timers.mac_state_check_timer,\n                    mbed::callback(this, &LoRaMac::handle_mac_state_check_timer_event));\n    _lora_time.init(_params.timers.tx_delayed_timer,\n                    mbed::callback(this, &LoRaMac::handle_delayed_tx_timer_event));\n    _lora_time.init(_params.timers.rx_window1_timer,\n                    mbed::callback(this, &LoRaMac::handle_rx1_timer_event));\n    _lora_time.init(_params.timers.rx_window2_timer,\n                    mbed::callback(this, &LoRaMac::handle_rx2_timer_event));\n    _lora_time.init(_params.timers.ack_timeout_timer,\n                    mbed::callback(this, &LoRaMac::handle_ack_timeout));\n\n    // Store the current initialization time\n    _params.timers.mac_init_time = _lora_time.get_current_time();\n\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaMac::disconnect()\n{\n    // Cancel all timers\n    _lora_time.stop(_params.timers.mac_state_check_timer);\n    _lora_time.stop(_params.timers.tx_delayed_timer);\n    _lora_time.stop(_params.timers.rx_window1_timer);\n    _lora_time.stop(_params.timers.rx_window2_timer);\n    _lora_time.stop(_params.timers.ack_timeout_timer);\n\n    // Put radio to sleep\n    lora_phy->put_radio_to_sleep();\n\n    // Reset internal state\n    _params.is_nwk_joined = false;\n    _params.is_ack_retry_timeout_expired = false;\n    _params.is_rx_window_enabled = true;\n    _params.is_node_ack_requested = false;\n    _params.is_srv_ack_requested = false;\n    _params.flags.value = 0;\n    _params.mac_state = 0;\n\n    // Clear MAC commands\n    mac_commands.clear_command_buffer();\n    mac_commands.clear_repeat_buffer();\n    mac_commands.clear_mac_commands_in_next_tx();\n\n    // Set internal state to idle.\n    _params.mac_state = LORAMAC_IDLE;\n}\n\nlorawan_status_t LoRaMac::query_tx_possible(uint8_t size,\n                                            loramac_tx_info_t* tx_info)\n{\n    uint8_t fopt_len = mac_commands.get_mac_cmd_length()\n            + mac_commands.get_repeat_commands_length();\n\n    if (tx_info == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    // if applicaion has turned on ADR, we want to opt it out\n    if (_params.sys_params.adr_on) {\n        lora_phy->get_next_ADR(false, _params.sys_params.channel_data_rate,\n                               _params.sys_params.channel_tx_power,\n                               _params.adr_ack_counter);\n    }\n\n    tx_info->current_payload_size = lora_phy->get_max_payload(_params.sys_params.channel_data_rate, _params.is_repeater_supported);\n\n\n    // Verify if the fOpts fit into the maximum payload\n    if (tx_info->current_payload_size >= fopt_len) {\n        tx_info->max_possible_payload_size = tx_info->current_payload_size - fopt_len;\n    } else {\n        tx_info->max_possible_payload_size = tx_info->current_payload_size;\n        // The fOpts don't fit into the maximum payload. Omit the MAC commands to\n        // ensure that another uplink is possible.\n        fopt_len = 0;\n        mac_commands.clear_command_buffer();\n        mac_commands.clear_repeat_buffer();\n    }\n\n    // Verify if the fOpts and the payload fit into the maximum payload\n    if (validate_payload_length(size, _params.sys_params.channel_data_rate,\n                                fopt_len) == false) {\n        return LORAWAN_STATUS_LENGTH_ERROR;\n    }\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMac::add_channel_plan(const lorawan_channelplan_t& plan)\n{\n    // Validate if the MAC is in a correct state\n    if ((_params.mac_state & LORAMAC_TX_RUNNING) == LORAMAC_TX_RUNNING) {\n        if ((_params.mac_state & LORAMAC_TX_CONFIG) != LORAMAC_TX_CONFIG) {\n            return LORAWAN_STATUS_BUSY;\n        }\n    }\n\n    return channel_plan.set_plan(plan);\n}\n\nlorawan_status_t LoRaMac::remove_channel_plan()\n{\n    if ((_params.mac_state & LORAMAC_TX_RUNNING) == LORAMAC_TX_RUNNING) {\n        if ((_params.mac_state & LORAMAC_TX_CONFIG) != LORAMAC_TX_CONFIG) {\n            return LORAWAN_STATUS_BUSY;\n        }\n    }\n\n    return channel_plan.remove_plan();\n\n}\n\nlorawan_status_t LoRaMac::get_channel_plan(lorawan_channelplan_t& plan)\n{\n    // Request Mib to get channels\n    loramac_mib_req_confirm_t mib_confirm;\n    memset(&mib_confirm, 0, sizeof(mib_confirm));\n    mib_confirm.type = MIB_CHANNELS;\n\n    lorawan_status_t status = mib.get_request(&mib_confirm, &_params);\n\n    if (status != LORAWAN_STATUS_OK) {\n        return status;\n    }\n\n    return channel_plan.get_plan(plan, &mib_confirm);\n}\n\nlorawan_status_t LoRaMac::remove_single_channel(uint8_t id)\n{\n    if ((_params.mac_state & LORAMAC_TX_RUNNING) == LORAMAC_TX_RUNNING) {\n        if ((_params.mac_state & LORAMAC_TX_CONFIG) != LORAMAC_TX_CONFIG) {\n            return LORAWAN_STATUS_BUSY;\n        }\n    }\n\n    return channel_plan.remove_single_channel(id);\n}\n\nlorawan_status_t LoRaMac::multicast_channel_link(multicast_params_t *channel_param)\n{\n    if (channel_param == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n    if ((_params.mac_state & LORAMAC_TX_RUNNING) == LORAMAC_TX_RUNNING) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    // Reset downlink counter\n    channel_param->dl_frame_counter = 0;\n\n    if (_params.multicast_channels == NULL) {\n        // New node is the fist element\n        _params.multicast_channels = channel_param;\n    } else {\n        multicast_params_t *cur = _params.multicast_channels;\n\n        // Search the last node in the list\n        while (cur->next != NULL) {\n            cur = cur->next;\n        }\n        // This function always finds the last node\n        cur->next = channel_param;\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMac::multicast_channel_unlink(\n        multicast_params_t *channel_param)\n{\n    if (channel_param == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n    if ((_params.mac_state & LORAMAC_TX_RUNNING) == LORAMAC_TX_RUNNING) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    if (_params.multicast_channels != NULL) {\n        if (_params.multicast_channels == channel_param) {\n            // First element\n            _params.multicast_channels = channel_param->next;\n        } else {\n            multicast_params_t *cur = _params.multicast_channels;\n\n            // Search the node in the list\n            while (cur->next && cur->next != channel_param) {\n                cur = cur->next;\n            }\n            // If we found the node, remove it\n            if (cur->next) {\n                cur->next = channel_param->next;\n            }\n        }\n        channel_param->next = NULL;\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMac::mlme_request( loramac_mlme_req_t *mlmeRequest )\n{\n    tr_info(\"mlme_request\");\n\n    if (LORAMAC_IDLE != _params.mac_state) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    mlme.reset_confirmation();\n\n    mlme.get_confirmation().req_type = mlmeRequest->type;\n    _params.flags.bits.mlme_req = 1;\n\n    lorawan_status_t status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n\n    if (MLME_LINK_CHECK == mlmeRequest->type) {\n        status = mac_commands.add_mac_command(MOTE_MAC_LINK_CHECK_REQ, 0, 0);\n    } else if (MLME_JOIN == mlmeRequest->type) {\n        if ((_params.mac_state & LORAMAC_TX_DELAYED) == LORAMAC_TX_DELAYED) {\n            return LORAWAN_STATUS_BUSY;\n        }\n\n        if ((mlmeRequest->req.join.dev_eui == NULL)\n                || (mlmeRequest->req.join.app_eui == NULL)\n                || (mlmeRequest->req.join.app_key == NULL)\n                || (mlmeRequest->req.join.nb_trials == 0)) {\n            return LORAWAN_STATUS_PARAMETER_INVALID;\n        }\n        _params.keys.dev_eui = mlmeRequest->req.join.dev_eui;\n        _params.keys.app_eui = mlmeRequest->req.join.app_eui;\n        _params.keys.app_key = mlmeRequest->req.join.app_key;\n        _params.max_join_request_trials = mlmeRequest->req.join.nb_trials;\n\n        if (!lora_phy->verify_nb_join_trials(mlmeRequest->req.join.nb_trials)) {\n            // Value not supported, get default\n            _params.max_join_request_trials = MBED_CONF_LORA_NB_TRIALS;\n        }\n        // Reset variable JoinRequestTrials\n        _params.join_request_trial_counter = 0;\n\n        reset_mac_parameters();\n\n        _params.sys_params.channel_data_rate =\n                lora_phy->get_alternate_DR(_params.join_request_trial_counter + 1);\n\n        loramac_mhdr_t machdr;\n        machdr.value = 0;\n        machdr.bits.mtype = FRAME_TYPE_JOIN_REQ;\n        status = send(&machdr, 0, NULL, 0);\n    } else if (MLME_TXCW == mlmeRequest->type) {\n        mlme.set_tx_continuous_wave(_params.channel, _params.sys_params.channel_data_rate, _params.sys_params.channel_tx_power,\n                                    _params.sys_params.max_eirp, _params.sys_params.antenna_gain, mlmeRequest->req.cw_tx_mode.timeout);\n        _lora_time.start(_params.timers.mac_state_check_timer,\n                         MAC_STATE_CHECK_TIMEOUT);\n\n        _params.mac_state |= LORAMAC_TX_RUNNING;\n        status = LORAWAN_STATUS_OK;\n    } else if (MLME_TXCW_1 == mlmeRequest->type) {\n        mlme.set_tx_continuous_wave(0, 0, mlmeRequest->req.cw_tx_mode.power, 0, 0, mlmeRequest->req.cw_tx_mode.timeout);\n        _lora_time.start(_params.timers.mac_state_check_timer,\n                         MAC_STATE_CHECK_TIMEOUT);\n\n        _params.mac_state |= LORAMAC_TX_RUNNING;\n        status = LORAWAN_STATUS_OK;\n    }\n\n    if (status != LORAWAN_STATUS_OK) {\n        _params.is_node_ack_requested = false;\n        _params.flags.bits.mlme_req = 0;\n    }\n\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::mcps_request( loramac_mcps_req_t *mcpsRequest )\n{\n    tr_info(\"mcps_request\");\n\n    if (_params.mac_state != LORAMAC_IDLE) {\n        return LORAWAN_STATUS_BUSY;\n    }\n\n    loramac_mhdr_t machdr;\n    int8_t datarate = mcpsRequest->data_rate;\n    // TODO: The comment is different than the code???\n    // Apply the minimum possible datarate.\n    // Some regions have limitations for the minimum datarate.\n    datarate = MAX(datarate, (int8_t)lora_phy->get_minimum_tx_datarate());\n\n    machdr.value = 0;\n\n    mcps.reset_confirmation();\n\n    _params.ack_timeout_retry_counter = 1;\n    _params.max_ack_timeout_retries = 1;\n\n    switch (mcpsRequest->type) {\n        case MCPS_UNCONFIRMED: {\n            machdr.bits.mtype = FRAME_TYPE_DATA_UNCONFIRMED_UP;\n            break;\n        }\n        case MCPS_CONFIRMED: {\n            machdr.bits.mtype = FRAME_TYPE_DATA_CONFIRMED_UP;\n            _params.max_ack_timeout_retries = mcpsRequest->nb_trials;\n            break;\n        }\n        case MCPS_PROPRIETARY: {\n            machdr.bits.mtype = FRAME_TYPE_PROPRIETARY;\n            break;\n        }\n        default:\n            return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n//    Filter fPorts\n//    TODO: Does not work with PROPRIETARY messages\n//    if( IsFPortAllowed( mcpsRequest->fport ) == false ) {\n//        return LORAWAN_STATUS_PARAMETER_INVALID;\n//    }\n\n    if (_params.sys_params.adr_on == false) {\n        if (lora_phy->verify_tx_datarate(datarate, false) == true) {\n            _params.sys_params.channel_data_rate = datarate;\n        } else {\n            return LORAWAN_STATUS_PARAMETER_INVALID;\n        }\n    }\n\n    lorawan_status_t status = send(&machdr, mcpsRequest->fport, mcpsRequest->f_buffer,\n                                   mcpsRequest->f_buffer_size);\n    if (status == LORAWAN_STATUS_OK) {\n        mcps.get_confirmation().req_type = mcpsRequest->type;\n        _params.flags.bits.mcps_req = 1;\n    } else {\n        _params.is_node_ack_requested = false;\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMac::mib_get_request_confirm( loramac_mib_req_confirm_t *mibGet )\n{\n    tr_info(\"mib_get_request_confirm\");\n    return mib.get_request(mibGet, &_params);\n}\n\nlorawan_status_t LoRaMac::mib_set_request_confirm( loramac_mib_req_confirm_t *mibSet )\n{\n    tr_info(\"mib_set_request_confirm\");\n    lorawan_status_t status = mib.set_request(mibSet, &_params);\n    if (LORAWAN_STATUS_OK == status && CLASS_C == _params.dev_class && (MIB_DEVICE_CLASS == mibSet->type ||\n       (MIB_RX2_CHANNEL == mibSet->type && _params.is_nwk_joined))) {\n        open_continuous_rx2_window();\n    }\n    return status;\n}\n\nradio_events_t *LoRaMac::get_phy_event_handlers()\n{\n    radio_events.tx_done = mbed::callback(this, &LoRaMac::handle_tx_done);\n    radio_events.rx_done = mbed::callback(this, &LoRaMac::handle_rx_done);\n    radio_events.rx_error = mbed::callback(this, &LoRaMac::handle_rx_error);\n    radio_events.tx_timeout = mbed::callback(this, &LoRaMac::handle_tx_timeout);\n    radio_events.rx_timeout = mbed::callback(this, &LoRaMac::handle_rx_timeout);\n\n    return &radio_events;\n}\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n/***************************************************************************\n * Compliance testing                                                      *\n **************************************************************************/\n\nlorawan_status_t LoRaMac::LoRaMacSetTxTimer( uint32_t TxDutyCycleTime )\n{\n    _lora_time.start(tx_next_packet_timer, TxDutyCycleTime);\n    return LORAWAN_STATUS_OK;\n}\n\n lorawan_status_t LoRaMac::LoRaMacStopTxTimer( )\n{\n    _lora_time.stop(tx_next_packet_timer);\n    return LORAWAN_STATUS_OK;\n}\n\nvoid LoRaMac::LoRaMacTestRxWindowsOn( bool enable )\n{\n    _params.is_rx_window_enabled = enable;\n}\n\nvoid LoRaMac::LoRaMacTestSetMic( uint16_t txPacketCounter )\n{\n    _params.ul_frame_counter = txPacketCounter;\n    _params.is_ul_frame_counter_fixed = true;\n}\n\nvoid LoRaMac::LoRaMacTestSetDutyCycleOn( bool enable )\n{\n    if(lora_phy->verify_duty_cycle(enable) == true)\n    {\n        _params.is_dutycycle_on = enable;\n    }\n}\n\nvoid LoRaMac::LoRaMacTestSetChannel( uint8_t channel )\n{\n    _params.channel = channel;\n}\n#endif\n","/**\n * @file lorawan_data_structures.h\n *\n * @brief Contains common data structures used by Mbed-OS\n *        LoRaWAN mplementation.\n *\n *  \\code\n *   ______                              _\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *   (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n * Description: LoRa PHY layer\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n */\n\n#ifndef LORAWAN_SYSTEM_LORAWAN_DATA_STRUCTURES_H_\n#define LORAWAN_SYSTEM_LORAWAN_DATA_STRUCTURES_H_\n\n#include <inttypes.h>\n#include \"device.h\"\n#include \"platform/Callback.h\"\n\n/*!\n * \\brief Timer time variable definition\n */\n#ifndef lorawan_time_t\ntypedef uint32_t lorawan_time_t;\n#endif\n\n// Radio wake-up time from sleep - unit ms.\n#define RADIO_WAKEUP_TIME                           1\n\n/**\n * Option Flags for send(), receive() APIs\n */\n#define MSG_UNCONFIRMED_FLAG                  0x01\n#define MSG_CONFIRMED_FLAG                    0x02\n#define MSG_MULTICAST_FLAG                    0x04\n#define MSG_PROPRIETARY_FLAG                  0x08\n\n/**\n * A macro to test a if a bit is on in a channel mask or not.\n */\n//#define MASK_BIT_TEST(mask, bit)    (mask & (1U << bit))\n//#define MASK_BIT_TEST(mask, bit)    ((mask)[(bit) / 16] & (1U << ((bit) % 16)))\n/**\n * A macro to clear a bit in a channel mask.\n */\n//#define MASK_BIT_CLEAR(mask, bit)   (mask &= ~(1 << bit))\n\n/**\n * A macro to clear a bit in a channel mask.\n */\n//#define MASK_BIT_SET(mask, bit)   (mask |= (1 << bit))\n\n/**\n * Bit mask for message flags\n */\n\n#define MSG_FLAG_MASK                         0x0F\n\n/**\n * Mask for unconfirmed multicast message\n */\n#define MSG_UNCONFIRMED_MULTICAST              0x05\n\n/**\n * Mask for confirmed multicast message\n */\n#define MSG_CONFIRMED_MULTICAST                0x06\n\n/**\n * Mask for unconfirmed message proprietary message\n */\n#define MSG_UNCONFIRMED_PROPRIETARY            0x09\n\n/**\n * Mask for confirmed proprietary message\n */\n#define MSG_CONFIRMED_PROPRIETARY              0x0A\n\n/*!\n * Sets the length of the LoRaMAC footer field.\n * Mainly indicates the MIC field length.\n */\n#define LORAMAC_MFR_LEN                             4\n\n/*!\n * The FRMPayload overhead to be used when setting the `Radio.SetMaxPayloadLength`\n * in the `RxWindowSetup` function.\n * The maximum PHYPayload = MaxPayloadOfDatarate/MaxPayloadOfDatarateRepeater + LORA_MAC_FRMPAYLOAD_OVERHEAD\n */\n#define LORA_MAC_FRMPAYLOAD_OVERHEAD                13 // MHDR(1) + FHDR(7) + Port(1) + MIC(4)\n\n/**\n * LoRaMac maximum number of channels\n */\n#define LORA_MAX_NB_CHANNELS                        16\n\n/**\n * Maximum PHY layer payload size for reception.\n */\n#define LORAMAC_PHY_MAXPAYLOAD                      255\n\n/**\n *\n * Default user application maximum data size for transmission\n */\n// reject if user tries to set more than MTU\n#if MBED_CONF_LORA_TX_MAX_SIZE > 255\n    #warning \"Cannot set TX Max size more than MTU=255\"\n    #define MBED_CONF_LORA_TX_MAX_SIZE              255\n#endif\n\n/*!\n * LoRaWAN device classes definition.\n *\n * LoRaWAN Specification V1.0.2, chapter 2.1.\n */\ntypedef enum {\n    /*!\n     * LoRaWAN device class A.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 3.\n     */\n    CLASS_A,\n    /*!\n     * LoRaWAN device class B.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 8.\n     */\n    CLASS_B,\n    /*!\n     * LoRaWAN device class C.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 17.\n     */\n    CLASS_C,\n} device_class_t;\n\n/*!\n * LoRaMAC channel parameters definition.\n */\ntypedef union {\n    /*!\n     * Byte-access to the bits.\n     */\n    int8_t value;\n    /*!\n     * The structure to store the minimum and the maximum datarate.\n     */\n    struct sFields\n    {\n         /*!\n         * The minimum data rate.\n         *\n         * LoRaWAN Regional Parameters V1.0.2rB.\n         *\n         * The allowed ranges are region-specific. Please refer to \\ref DR_0 to \\ref DR_15 for details.\n         */\n        int8_t min : 4;\n        /*!\n         * The maximum data rate.\n         *\n         * LoRaWAN Regional Parameters V1.0.2rB.\n         *\n         * The allowed ranges are region-specific. Please refer to \\ref DR_0 to \\ref DR_15 for details.\n         */\n        int8_t max : 4;\n    } fields;\n} dr_range_t;\n\n/*!\n * LoRaMAC channel definition.\n */\ntypedef struct {\n    /*!\n     * The frequency in Hz.\n     */\n    uint32_t frequency;\n    /*!\n     * The alternative frequency for RX window 1.\n     */\n    uint32_t rx1_frequency;\n    /*!\n     * The data rate definition.\n     */\n    dr_range_t dr_range;\n    /*!\n     * The band index.\n     */\n    uint8_t band;\n} channel_params_t;\n\n/*!\n * LoRaMAC band parameters definition.\n */\ntypedef struct {\n    /*!\n     * The duty cycle.\n     */\n    uint16_t duty_cycle;\n    /*!\n     * The maximum TX power.\n     */\n    int8_t max_tx_pwr;\n    /*!\n     * The timestamp of the last Join Request TX frame.\n     */\n    lorawan_time_t last_join_tx_time;\n    /*!\n     * The timestamp of the last TX frame.\n     */\n    lorawan_time_t last_tx_time;\n    /*!\n     * The device off time.\n     */\n    lorawan_time_t off_time;\n    /*!\n     * Lower band boundry\n     */\n    uint32_t lower_band_freq;\n    /*!\n     * Higher band boundry\n     */\n    uint32_t higher_band_freq;\n} band_t;\n\n/*!\n * LoRaMAC receive window 2 channel parameters.\n */\ntypedef struct {\n    /*!\n     * The frequency in Hz.\n     */\n    uint32_t frequency;\n    /*!\n     * The data rate.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * The allowed ranges are region-specific. Please refer to \\ref DR_0 to \\ref DR_15 for details.\n     */\n    uint8_t  datarate;\n} rx2_channel_params;\n\n/*!\n * LoRaMAC receive window enumeration\n */\ntypedef enum {\n    /*!\n     * LoRaMAC receive window 1\n     */\n    RX_SLOT_WIN_1,\n    /*!\n     * LoRaMAC receive window 2\n     */\n    RX_SLOT_WIN_2,\n    /*!\n     * LoRaMAC receive window 2 for class c - continuous listening\n     */\n    RX_SLOT_WIN_CLASS_C,\n    /*!\n     * LoRaMAC class b ping slot window\n     */\n    RX_SLOT_WIN_PING_SLOT\n} rx_slot_t;\n\n/*!\n * The global MAC layer parameters.\n */\ntypedef struct {\n    /*!\n     * The TX power in channels.\n     */\n    int8_t channel_tx_power;\n    /*!\n     * The data rate in channels.\n     */\n    int8_t channel_data_rate;\n    /*!\n     * The system overall timing error in milliseconds.\n     * [-SystemMaxRxError : +SystemMaxRxError]\n     * Default: +/-10 ms\n     */\n    uint32_t max_sys_rx_error;\n    /*!\n     * The minimum number of symbols required to detect an RX frame.\n     * Default: 6 symbols\n     */\n    uint8_t min_rx_symb;\n    /*!\n     * LoRaMac maximum time a reception window stays open.\n     */\n    uint32_t max_rx_win_time;\n    /*!\n     * Receive delay 1.\n     */\n    uint32_t recv_delay1;\n    /*!\n     * Receive delay 2.\n     */\n    uint32_t recv_delay2;\n    /*!\n     * Join accept delay 1.\n     */\n    uint32_t join_accept_delay1;\n    /*!\n     * Join accept delay 1.\n     */\n    uint32_t join_accept_delay2;\n    /*!\n     * The number of uplink messages repetitions (confirmed messages only).\n     */\n    uint8_t retry_num;\n    /*!\n     * The datarate offset between uplink and downlink on first window.\n     */\n    uint8_t rx1_dr_offset;\n    /*!\n     * LoRaMAC 2nd reception window settings.\n     */\n    rx2_channel_params rx2_channel;\n    /*!\n     * The uplink dwell time configuration. 0: No limit, 1: 400ms\n     */\n    uint8_t uplink_dwell_time;\n    /*!\n     * The downlink dwell time configuration. 0: No limit, 1: 400ms\n     */\n    uint8_t downlink_dwell_time;\n    /*!\n     * The maximum possible EIRP.\n     */\n    float max_eirp;\n    /*!\n     * The antenna gain of the node.\n     */\n    float antenna_gain;\n\n    /*!\n     * Maximum duty cycle\n     * \\remark Possibility to shutdown the device.\n     */\n    uint8_t max_duty_cycle;\n    /*!\n     * Aggregated duty cycle management\n     */\n    uint16_t aggregated_duty_cycle;\n\n    /*!\n     * LoRaMac ADR control status\n     */\n    bool adr_on;\n} lora_mac_system_params_t;\n\n/*!\n * LoRaMAC multicast channel parameter.\n */\ntypedef struct multicast_params_s {\n    /*!\n     * Address.\n     */\n    uint32_t address;\n    /*!\n     * Network session key.\n     */\n    uint8_t nwk_skey[16];\n    /*!\n     * Application session key.\n     */\n    uint8_t app_skey[16];\n    /*!\n     * Downlink counter.\n     */\n    uint32_t dl_frame_counter;\n    /*!\n     * A reference pointer to the next multicast channel parameters in the list.\n     */\n    struct multicast_params_s *next;\n} multicast_params_t;\n\n/*!\n * LoRaMAC frame types.\n *\n * LoRaWAN Specification V1.0.2, chapter 4.2.1, table 1.\n */\ntypedef enum {\n    /*!\n     * LoRaMAC join request frame.\n     */\n    FRAME_TYPE_JOIN_REQ              = 0x00,\n    /*!\n     * LoRaMAC join accept frame.\n     */\n    FRAME_TYPE_JOIN_ACCEPT           = 0x01,\n    /*!\n     * LoRaMAC unconfirmed uplink frame.\n     */\n    FRAME_TYPE_DATA_UNCONFIRMED_UP   = 0x02,\n    /*!\n     * LoRaMAC unconfirmed downlink frame.\n     */\n    FRAME_TYPE_DATA_UNCONFIRMED_DOWN = 0x03,\n    /*!\n     * LoRaMAC confirmed uplink frame.\n     */\n    FRAME_TYPE_DATA_CONFIRMED_UP     = 0x04,\n    /*!\n     * LoRaMAC confirmed downlink frame.\n     */\n    FRAME_TYPE_DATA_CONFIRMED_DOWN   = 0x05,\n    /*!\n     * LoRaMAC RFU frame.\n     */\n    FRAME_TYPE_RFU                   = 0x06,\n    /*!\n     * LoRaMAC proprietary frame.\n     */\n    FRAME_TYPE_PROPRIETARY           = 0x07,\n} mac_frame_type_t;\n\n/*!\n * LoRaMAC mote MAC commands.\n *\n * LoRaWAN Specification V1.0.2, chapter 5, table 4.\n */\ntypedef enum {\n    /*!\n     * LinkCheckReq\n     */\n    MOTE_MAC_LINK_CHECK_REQ          = 0x02,\n    /*!\n     * LinkADRAns\n     */\n    MOTE_MAC_LINK_ADR_ANS            = 0x03,\n    /*!\n     * DutyCycleAns\n     */\n    MOTE_MAC_DUTY_CYCLE_ANS          = 0x04,\n    /*!\n     * RXParamSetupAns\n     */\n    MOTE_MAC_RX_PARAM_SETUP_ANS      = 0x05,\n    /*!\n     * DevStatusAns\n     */\n    MOTE_MAC_DEV_STATUS_ANS          = 0x06,\n    /*!\n     * NewChannelAns\n     */\n    MOTE_MAC_NEW_CHANNEL_ANS         = 0x07,\n    /*!\n     * RXTimingSetupAns\n     */\n    MOTE_MAC_RX_TIMING_SETUP_ANS     = 0x08,\n    /*!\n     * TXParamSetupAns\n     */\n    MOTE_MAC_TX_PARAM_SETUP_ANS      = 0x09,\n    /*!\n     * DlChannelAns\n     */\n    MOTE_MAC_DL_CHANNEL_ANS          = 0x0A\n} mote_mac_cmds_t;\n\n/*!\n * LoRaMAC server MAC commands.\n *\n * LoRaWAN Specification V1.0.2 chapter 5, table 4.\n */\ntypedef enum {\n    /*!\n     * LinkCheckAns\n     */\n    SRV_MAC_LINK_CHECK_ANS           = 0x02,\n    /*!\n     * LinkADRReq\n     */\n    SRV_MAC_LINK_ADR_REQ             = 0x03,\n    /*!\n     * DutyCycleReq\n     */\n    SRV_MAC_DUTY_CYCLE_REQ           = 0x04,\n    /*!\n     * RXParamSetupReq\n     */\n    SRV_MAC_RX_PARAM_SETUP_REQ       = 0x05,\n    /*!\n     * DevStatusReq\n     */\n    SRV_MAC_DEV_STATUS_REQ           = 0x06,\n    /*!\n     * NewChannelReq\n     */\n    SRV_MAC_NEW_CHANNEL_REQ          = 0x07,\n    /*!\n     * RXTimingSetupReq\n     */\n    SRV_MAC_RX_TIMING_SETUP_REQ      = 0x08,\n    /*!\n     * NewChannelReq\n     */\n    SRV_MAC_TX_PARAM_SETUP_REQ       = 0x09,\n    /*!\n     * DlChannelReq\n     */\n    SRV_MAC_DL_CHANNEL_REQ           = 0x0A,\n} server_mac_cmds_t;\n\n/*!\n * LoRaMAC battery level indicator.\n */\ntypedef enum {\n    /*!\n     * An external power source.\n     */\n    BAT_LEVEL_EXT_SRC                = 0x00,\n    /*!\n     * Battery level empty.\n     */\n    BAT_LEVEL_EMPTY                  = 0x01,\n    /*!\n     * Battery level full.\n     */\n    BAT_LEVEL_FULL                   = 0xFE,\n    /*!\n     * Battery level - no measurement available.\n     */\n    BAT_LEVEL_NO_MEASURE             = 0xFF,\n} device_battery_level_t;\n\n/*!\n * LoRaMAC header field definition (MHDR field).\n *\n * LoRaWAN Specification V1.0.2, chapter 4.2.\n */\ntypedef union {\n    /*!\n     * Byte-access to the bits.\n     */\n    uint8_t value;\n    /*!\n     * The structure containing single access to header bits.\n     */\n    struct hdr_bits_s\n    {\n        /*!\n         * Major version.\n         */\n        uint8_t major           : 2;\n        /*!\n         * RFU\n         */\n        uint8_t RFU             : 3;\n        /*!\n         * Message type\n         */\n        uint8_t mtype           : 3;\n    } bits;\n} loramac_mhdr_t;\n\n/*!\n * LoRaMAC frame control field definition (FCtrl).\n *\n * LoRaWAN Specification V1.0.2, chapter 4.3.1.\n */\ntypedef union {\n    /*!\n     * Byte-access to the bits.\n     */\n    uint8_t value;\n    /*!\n     * The structure containing single access to bits.\n     */\n    struct ctrl_bits_s\n    {\n        /*!\n         * Frame options length.\n         */\n        uint8_t fopts_len        : 4;\n        /*!\n         * Frame pending bit.\n         */\n        uint8_t fpending        : 1;\n        /*!\n         * Message acknowledge bit.\n         */\n        uint8_t ack             : 1;\n        /*!\n         * ADR acknowledgment request bit.\n         */\n        uint8_t adr_ack_req       : 1;\n        /*!\n         * ADR control in the frame header.\n         */\n        uint8_t adr             : 1;\n    } bits;\n} loramac_frame_ctrl_t;\n\n/*!\n * The enumeration containing the status of the operation of a MAC service.\n */\ntypedef enum {\n    /*!\n     * Service performed successfully.\n     */\n    LORAMAC_EVENT_INFO_STATUS_OK = 0,\n    /*!\n     * An error occurred during the execution of the service.\n     */\n    LORAMAC_EVENT_INFO_STATUS_ERROR,\n    /*!\n     * A TX timeout occurred.\n     */\n    LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT,\n    /*!\n     * An RX timeout occurred on receive window 1.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT,\n    /*!\n     * An RX timeout occurred on receive window 2.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT,\n    /*!\n     * An RX error occurred on receive window 1.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX1_ERROR,\n    /*!\n     * An RX error occurred on receive window 2.\n     */\n    LORAMAC_EVENT_INFO_STATUS_RX2_ERROR,\n    /*!\n     * An error occurred in the join procedure.\n     */\n    LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL,\n    /*!\n     * A frame with an invalid downlink counter was received. The\n     * downlink counter of the frame was equal to the local copy\n     * of the downlink counter of the node.\n     */\n    LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED,\n    /*!\n     * The MAC could not retransmit a frame since the MAC decreased the datarate. The\n     * payload size is not applicable for the datarate.\n     */\n    LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR,\n    /*!\n     * The node has lost MAX_FCNT_GAP or more frames.\n     */\n    LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS,\n    /*!\n     * An address error occurred.\n     */\n    LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL,\n    /*!\n     * Message integrity check failure.\n     */\n    LORAMAC_EVENT_INFO_STATUS_MIC_FAIL,\n    /*!\n     * Crypto methods failure\n     */\n    LORAMAC_EVENT_INFO_STATUS_CRYPTO_FAIL,\n} loramac_event_info_status_t;\n\n/*!\n * LoRaMac service state flags.\n */\ntypedef union {\n    /*!\n     * Byte-access to the bits.\n     */\n    uint8_t value;\n    /*!\n     * The structure containing single access to bits.\n     */\n    struct mac_flag_bits_s\n    {\n        /*!\n         * MCPS-Req pending\n         */\n        uint8_t mcps_req         : 1;\n        /*!\n         * MCPS-Ind pending\n         */\n        uint8_t mcps_ind         : 1;\n        /*!\n         * MCPS-Ind pending. Skip indication to the application layer.\n         */\n        uint8_t mcps_ind_skip     : 1;\n        /*!\n         * MLME-Req pending\n         */\n        uint8_t mlme_req         : 1;\n        /*!\n         * MLME-Ind pending\n         */\n        uint8_t mlme_ind         : 1;\n        /*!\n         * MAC cycle done\n         */\n        uint8_t mac_done         : 1;\n    } bits;\n} loramac_flags_t;\n\n/*!\n *\n * \\brief   LoRaMAC data services\n *\n * \\details The following table list the primitives supported by a\n *          specific MAC data service:\n *\n * Name                  | Request | Indication | Response | Confirm\n * --------------------- | :-----: | :--------: | :------: | :-----:\n * \\ref MCPS_UNCONFIRMED | YES     | YES        | NO       | YES\n * \\ref MCPS_CONFIRMED   | YES     | YES        | NO       | YES\n * \\ref MCPS_MULTICAST   | NO      | YES        | NO       | NO\n * \\ref MCPS_PROPRIETARY | YES     | YES        | NO       | YES\n *\n * The following table provides links to the function implementations of the\n * related MCPS primitives:\n *\n * Primitive        | Function\n * ---------------- | :---------------------:\n * MCPS-Request     | LoRaMacMlmeRequest\n * MCPS-Confirm     | MacMcpsConfirm in \\ref loramac_primitives_t\n * MCPS-Indication  | MacMcpsIndication in \\ref loramac_primitives_t\n */\ntypedef enum {\n    /*!\n     * Unconfirmed LoRaMAC frame.\n     */\n    MCPS_UNCONFIRMED,\n    /*!\n     * Confirmed LoRaMAC frame.\n     */\n    MCPS_CONFIRMED,\n    /*!\n     * Multicast LoRaMAC frame.\n     */\n    MCPS_MULTICAST,\n    /*!\n     * Proprietary frame.\n     */\n    MCPS_PROPRIETARY,\n} mcps_type_t;\n\n/*!\n * LoRaMAC MCPS-Request structure.\n */\ntypedef struct {\n    /*!\n     * MCPS-Request type.\n     */\n    mcps_type_t type;\n\n    /*!\n     * Frame port field. Must be set if the payload is not empty. Use the\n     * application-specific frame port values: [1...223].\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.2.\n     */\n    uint8_t fport;\n\n    /*!\n     * Uplink datarate, if ADR is off.\n     */\n    int8_t data_rate;\n    /*!\n     * The number of trials to transmit the frame, if the LoRaMAC layer did not\n     * receive an acknowledgment. The MAC performs a datarate adaptation\n     * according to the LoRaWAN Specification V1.0.2, chapter 18.4, as in\n     * the following table:\n     *\n     * Transmission nb | Data Rate\n     * ----------------|-----------\n     * 1 (first)       | DR\n     * 2               | DR\n     * 3               | max(DR-1,0)\n     * 4               | max(DR-1,0)\n     * 5               | max(DR-2,0)\n     * 6               | max(DR-2,0)\n     * 7               | max(DR-3,0)\n     * 8               | max(DR-3,0)\n     *\n     * Note that if nb_trials is set to 1 or 2, the MAC will not decrease\n     * the datarate, if the LoRaMAC layer did not receive an acknowledgment.\n     */\n    uint8_t nb_trials;\n\n    /** Payload data\n      *\n      * A pointer to the buffer of the frame payload.\n      */\n     void *f_buffer;\n     /** Payload size\n      *\n      * The size of the frame payload.\n      */\n     uint16_t f_buffer_size;\n\n} loramac_mcps_req_t;\n\n/*!\n * LoRaMAC MCPS-Confirm.\n */\ntypedef struct {\n    /*!\n     * Holds the previously performed MCPS-Request type. i.e., the type of\n     * the MCPS request for which this confirmation is being generated\n     */\n    mcps_type_t req_type;\n    /*!\n     * The status of the operation.\n     */\n    loramac_event_info_status_t status;\n    /*!\n     * The uplink datarate.\n     */\n    uint8_t data_rate;\n    /*!\n     * The transmission power.\n     */\n    int8_t tx_power;\n    /*!\n     * Set if an acknowledgement was received.\n     */\n    bool ack_received;\n    /*!\n     * Provides the number of retransmissions.\n     */\n    uint8_t nb_retries;\n    /*!\n     * The transmission time on air of the frame.\n     */\n    lorawan_time_t tx_toa;\n    /*!\n     * The uplink counter value related to the frame.\n     */\n    uint32_t ul_frame_counter;\n    /*!\n     * The uplink frequency related to the frame.\n     */\n    uint32_t ul_frequency;\n} loramac_mcps_confirm_t;\n\n/*!\n * LoRaMAC MCPS-Indication primitive.\n */\ntypedef struct {\n    /*!\n     * MCPS-Indication type.\n     */\n    mcps_type_t type;\n    /*!\n     * The status of the operation.\n     */\n    loramac_event_info_status_t status;\n    /*!\n     * Multicast.\n     */\n    uint8_t multicast;\n    /*!\n     * The application port.\n     */\n    uint8_t port;\n    /*!\n     * The downlink datarate.\n     */\n    uint8_t rx_datarate;\n    /*!\n     * Frame pending status.\n     */\n    uint8_t fpending_status;\n    /*!\n     * A pointer to the received data stream.\n     */\n    uint8_t *buffer;\n    /*!\n     * The size of the received data stream.\n     */\n    uint16_t buffer_size;\n    /*!\n     * Indicates, if data is available.\n     */\n    bool is_data_recvd;\n    /*!\n     * The RSSI of the received packet.\n     */\n    int16_t rssi;\n    /*!\n     * The SNR of the received packet.\n     */\n    uint8_t snr;\n    /*!\n     * The receive window.\n     *\n     * [0: Rx window 1, 1: Rx window 2]\n     */\n    rx_slot_t rx_slot;\n    /*!\n     * Set if an acknowledgement was received.\n     */\n    bool is_ack_recvd;\n    /*!\n     * The downlink counter value for the received frame.\n     */\n    uint32_t dl_frame_counter;\n} loramac_mcps_indication_t;\n\n/*!\n * \\brief LoRaMAC management services.\n *\n * \\details The following table list the primitives supported by a\n *          specific MAC management service:\n *\n * Name                         | Request | Indication | Response | Confirm\n * ---------------------------- | :-----: | :--------: | :------: | :-----:\n * \\ref MLME_JOIN               | YES     | NO         | NO       | YES\n * \\ref MLME_LINK_CHECK         | YES     | NO         | NO       | YES\n * \\ref MLME_TXCW               | YES     | NO         | NO       | YES\n * \\ref MLME_SCHEDULE_UPLINK    | NO      | YES        | NO       | NO\n *\n * The following table provides links to the function implementations of the\n * related MLME primitives.\n *\n * Primitive        | Function\n * ---------------- | :---------------------:\n * MLME-Request     | LoRaMacMlmeRequest\n * MLME-Confirm     | MacMlmeConfirm in \\ref loramac_primitives_t\n * MLME-Indication  | MacMlmeIndication in \\ref loramac_primitives_t\n */\ntypedef enum {\n    /*!\n     * Initiates the Over-the-Air activation.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.\n     */\n    MLME_JOIN,\n    /*!\n     * LinkCheckReq - Connectivity validation.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 5, table 4.\n     */\n    MLME_LINK_CHECK,\n    /*!\n     * Sets TX continuous wave mode.\n     *\n     * LoRaWAN end-device certification.\n     */\n    MLME_TXCW,\n    /*!\n     * Sets TX continuous wave mode (new LoRa-Alliance CC definition).\n     *\n     * LoRaWAN end-device certification.\n     */\n    MLME_TXCW_1,\n    /*!\n     * Indicates that the application shall perform an uplink as\n     * soon as possible.\n     */\n    MLME_SCHEDULE_UPLINK\n} mlme_type_t;\n\n/*!\n * LoRaMAC MLME-Request for the join service.\n */\ntypedef struct {\n    /*!\n     * A globally unique end-device identifier.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.1.\n     */\n    uint8_t *dev_eui;\n    /*!\n     * An application identifier.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.2\n     */\n    uint8_t *app_eui;\n    /*!\n     * AES-128 application key.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.2.\n     */\n    uint8_t *app_key;\n    /*!\n     * The number of trials for the join request.\n     */\n    uint8_t nb_trials;\n} mlme_join_req_t;\n\n/*!\n * LoRaMAC MLME-Request for TX continuous wave mode.\n */\ntypedef struct {\n    /*!\n     * The time while the radio is kept in continuous wave mode, in seconds.\n     */\n    uint16_t timeout;\n    /*!\n     * The RF frequency to set (only used with the new way).\n     */\n    uint32_t frequency;\n    /*!\n     * The RF output power to set (only used with the new way).\n     */\n    uint8_t power;\n} mlme_cw_tx_mode_t;\n\n/*!\n * LoRaMAC MLME-Request structure.\n */\ntypedef struct {\n    /*!\n     * MLME-Request type.\n     */\n    mlme_type_t type;\n\n    /*!\n     * MLME-Request parameters.\n     */\n    union {\n        /*!\n         * MLME-Request parameters for a join request.\n         */\n        mlme_join_req_t join;\n        /*!\n         * MLME-Request parameters for TX continuous mode request.\n         */\n        mlme_cw_tx_mode_t cw_tx_mode;\n    } req;\n} loramac_mlme_req_t;\n\n/*!\n * LoRaMAC MLME-Confirm primitive.\n */\ntypedef struct {\n    /*!\n     * The previously performed MLME-Request. i.e., the request type\n     * for which the confirmation is being generated\n     */\n    mlme_type_t req_type;\n    /*!\n     * The status of the operation.\n     */\n    loramac_event_info_status_t status;\n    /*!\n     * The transmission time on air of the frame.\n     */\n    lorawan_time_t tx_toa;\n    /*!\n     * The demodulation margin. Contains the link margin [dB] of the last LinkCheckReq\n     * successfully received.\n     */\n    uint8_t demod_margin;\n    /*!\n     * The number of gateways which received the last LinkCheckReq.\n     */\n    uint8_t nb_gateways;\n    /*!\n     * The number of retransmissions.\n     */\n    uint8_t nb_retries;\n} loramac_mlme_confirm_t;\n\n/*!\n * LoRaMAC MLME-Indication primitive\n */\ntypedef struct {\n    /*!\n     * MLME-Indication type\n     */\n    mlme_type_t indication_type;\n} loramac_mlme_indication_t;\n\n/*!\n * LoRa MAC Information Base (MIB).\n *\n * The following table lists the MIB parameters and the related attributes:\n *\n * Attribute                         | Get | Set\n * --------------------------------- | :-: | :-:\n * \\ref MIB_DEVICE_CLASS             | YES | YES\n * \\ref MIB_NETWORK_JOINED           | YES | YES\n * \\ref MIB_ADR                      | YES | YES\n * \\ref MIB_NET_ID                   | YES | YES\n * \\ref MIB_DEV_ADDR                 | YES | YES\n * \\ref MIB_NWK_SKEY                 | YES | YES\n * \\ref MIB_APP_SKEY                 | YES | YES\n * \\ref MIB_PUBLIC_NETWORK           | YES | YES\n * \\ref MIB_REPEATER_SUPPORT         | YES | YES\n * \\ref MIB_CHANNELS                 | YES | NO\n * \\ref MIB_RX2_CHANNEL              | YES | YES\n * \\ref MIB_CHANNELS_MASK            | YES | YES\n * \\ref MIB_CHANNELS_DEFAULT_MASK    | YES | YES\n * \\ref MIB_CHANNELS_NB_REP          | YES | YES\n * \\ref MIB_MAX_RX_WINDOW_DURATION   | YES | YES\n * \\ref MIB_RECEIVE_DELAY_1          | YES | YES\n * \\ref MIB_RECEIVE_DELAY_2          | YES | YES\n * \\ref MIB_JOIN_ACCEPT_DELAY_1      | YES | YES\n * \\ref MIB_JOIN_ACCEPT_DELAY_2      | YES | YES\n * \\ref MIB_CHANNELS_DATARATE        | YES | YES\n * \\ref MIB_CHANNELS_DEFAULT_DATARATE| YES | YES\n * \\ref MIB_CHANNELS_TX_POWER        | YES | YES\n * \\ref MIB_CHANNELS_DEFAULT_TX_POWER| YES | YES\n * \\ref MIB_UPLINK_COUNTER           | YES | YES\n * \\ref MIB_DOWNLINK_COUNTER         | YES | YES\n * \\ref MIB_MULTICAST_CHANNEL        | YES | NO\n * \\ref MIB_SYSTEM_MAX_RX_ERROR      | YES | YES\n * \\ref MIB_MIN_RX_SYMBOLS           | YES | YES\n * \\ref MIB_ANTENNA_GAIN             | YES | YES\n *\n * The following table provides links to the function implementations of the\n * related MIB primitives:\n *\n * Primitive        | Function\n * ---------------- | :---------------------:\n * MIB-Set          | LoRaMacMibSetRequestConfirm\n * MIB-Get          | LoRaMacMibGetRequestConfirm\n */\ntypedef enum {\n    /*!\n     * LoRaWAN device class.\n     *\n     * LoRaWAN Specification V1.0.2.\n     */\n    MIB_DEVICE_CLASS,\n    /*!\n     * LoRaWAN Network joined attribute.\n     *\n     * LoRaWAN Specification V1.0.2.\n     */\n    MIB_NETWORK_JOINED,\n    /*!\n     * Adaptive data rate.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.1.1.\n     *\n     * [true: ADR enabled, false: ADR disabled].\n     */\n    MIB_ADR,\n    /*!\n     * Network identifier.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.1.\n     */\n    MIB_NET_ID,\n    /*!\n     * End-device address.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.1.\n     */\n    MIB_DEV_ADDR,\n    /*!\n     * Network session key.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.3.\n     */\n    MIB_NWK_SKEY,\n    /*!\n     * Application session key.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.4.\n     */\n    MIB_APP_SKEY,\n    /*!\n     * Set the network type to public or private.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * [true: public network, false: private network]\n     */\n    MIB_PUBLIC_NETWORK,\n    /*!\n     * Support the operation with repeaters.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * [true: repeater support enabled, false: repeater support disabled]\n     */\n    MIB_REPEATER_SUPPORT,\n    /*!\n     * Communication channels. A GET request will return a\n     * pointer that references the first entry of the channel list. The\n     * list is of size LORA_MAX_NB_CHANNELS.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_CHANNELS,\n    /*!\n     * Set receive window 2 channel.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 3.3.1.\n     */\n    MIB_RX2_CHANNEL,\n    /*!\n     * Set receive window 2 channel.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 3.3.2.\n     */\n    MIB_RX2_DEFAULT_CHANNEL,\n    /*!\n     * LoRaWAN channels mask.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_CHANNELS_MASK,\n    /*!\n     * LoRaWAN default channels mask.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_CHANNELS_DEFAULT_MASK,\n    /*!\n     * Set the number of repetitions on a channel.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 5.2.\n     */\n    MIB_CHANNELS_NB_REP,\n    /*!\n     * The maximum receive window duration in [ms].\n     *\n     * LoRaWAN Specification V1.0.2, chapter 3.3.3.\n     */\n    MIB_MAX_RX_WINDOW_DURATION,\n    /*!\n     * The receive delay 1 in [ms].\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_RECEIVE_DELAY_1,\n    /*!\n     * The receive delay 2 in [ms].\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_RECEIVE_DELAY_2,\n    /*!\n     * The join accept delay 1 in [ms].\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_JOIN_ACCEPT_DELAY_1,\n    /*!\n     * The join accept delay 2 in [ms].\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     */\n    MIB_JOIN_ACCEPT_DELAY_2,\n    /*!\n     * The default data rate of a channel.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * The allowed ranges are region-specific. Please refer to \\ref DR_0 to \\ref DR_15 for details.\n     */\n    MIB_CHANNELS_DEFAULT_DATARATE,\n    /*!\n     * The data rate of a channel.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * The allowed ranges are region-specific. Please refer to \\ref DR_0 to \\ref DR_15 for details.\n     */\n    MIB_CHANNELS_DATARATE,\n    /*!\n     * The transmission power of a channel.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * The allowed ranges are region-specific. Please refer to \\ref TX_POWER_0 to \\ref TX_POWER_15 for details.\n     */\n    MIB_CHANNELS_TX_POWER,\n    /*!\n     * The transmission power of a channel.\n     *\n     * LoRaWAN Regional Parameters V1.0.2rB.\n     *\n     * The allowed ranges are region-specific. Please refer to \\ref TX_POWER_0 to \\ref TX_POWER_15 for details.\n     */\n    MIB_CHANNELS_DEFAULT_TX_POWER,\n    /*!\n     * LoRaWAN uplink counter.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.1.5.\n     */\n    MIB_UPLINK_COUNTER,\n    /*!\n     * LoRaWAN downlink counter.\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.1.5.\n     */\n    MIB_DOWNLINK_COUNTER,\n    /*!\n     * Multicast channels. A GET request will return a pointer to the first\n     * entry of the multicast channel linked list. If the pointer is equal to\n     * NULL, the list is empty.\n     */\n    MIB_MULTICAST_CHANNEL,\n    /*!\n     * System overall timing error in milliseconds.\n     * [-SystemMaxRxError : +SystemMaxRxError]\n     * Default: +/-10 ms\n     */\n    MIB_SYSTEM_MAX_RX_ERROR,\n    /*!\n     * The minimum  number of symbols required to detect an RX frame.\n     * Default: 6 symbols\n     */\n    MIB_MIN_RX_SYMBOLS,\n    /*!\n     * The antenna gain of the node. The default value is region-specific.\n     * The antenna gain is used to calculate the TX power of the node.\n     * The formula is:\n     * radioTxPower = ( int8_t )floor( maxEirp - antennaGain )\n     */\n    MIB_ANTENNA_GAIN\n} mib_type_t;\n\n/*!\n * LoRaMAC MIB parameters.\n */\ntypedef union {\n    /*!\n     * LoRaWAN device class.\n     *\n     * Related MIB type: \\ref MIB_DEVICE_CLASS\n     */\n    device_class_t dev_class;\n    /*!\n     * LoRaWAN network joined attribute\n     *\n     * Related MIB type: \\ref MIB_NETWORK_JOINED\n     */\n    bool is_nwk_joined;\n    /*!\n     * Activation state of ADR\n     *\n     * Related MIB type: \\ref MIB_ADR\n     */\n    bool is_adr_enable;\n    /*!\n     * Network identifier\n     *\n     * Related MIB type: \\ref MIB_NET_ID\n     */\n    uint32_t net_id;\n    /*!\n     * End-device address\n     *\n     * Related MIB type: \\ref MIB_DEV_ADDR\n     */\n    uint32_t dev_addr;\n    /*!\n     * Network session key\n     *\n     * Related MIB type: \\ref MIB_NWK_SKEY\n     */\n    uint8_t *nwk_skey;\n    /*!\n     * Application session key\n     *\n     * Related MIB type: \\ref MIB_APP_SKEY\n     */\n    uint8_t *app_skey;\n    /*!\n     * Enable or disable a public network\n     *\n     * Related MIB type: \\ref MIB_PUBLIC_NETWORK\n     */\n    bool enable_public_nwk;\n    /*!\n     * Enable or disable repeater support\n     *\n     * Related MIB type: \\ref MIB_REPEATER_SUPPORT\n     */\n    bool enable_repeater_support;\n    /*!\n     * LoRaWAN channel\n     *\n     * Related MIB type: \\ref MIB_CHANNELS\n     */\n    channel_params_t* channel_list;\n     /*!\n     * Channel for the receive window 2\n     *\n     * Related MIB type: \\ref MIB_RX2_CHANNEL\n     */\n    rx2_channel_params rx2_channel;\n     /*!\n     * Channel for the receive window 2\n     *\n     * Related MIB type: \\ref MIB_RX2_DEFAULT_CHANNEL\n     */\n    rx2_channel_params default_rx2_channel;\n    /*!\n     * Channel mask\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_MASK\n     */\n    uint16_t* channel_mask;\n    /*!\n     * Default channel mask\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_DEFAULT_MASK\n     */\n    uint16_t* default_channel_mask;\n    /*!\n     * Number of frame repetitions\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_NB_REP\n     */\n    uint8_t channel_nb_rep;\n    /*!\n     * Maximum receive window duration\n     *\n     * Related MIB type: \\ref MIB_MAX_RX_WINDOW_DURATION\n     */\n    uint32_t max_rx_window;\n    /*!\n     * Receive delay 1\n     *\n     * Related MIB type: \\ref MIB_RECEIVE_DELAY_1\n     */\n    uint32_t recv_delay1;\n    /*!\n     * Receive delay 2\n     *\n     * Related MIB type: \\ref MIB_RECEIVE_DELAY_2\n     */\n    uint32_t recv_delay2;\n    /*!\n     * Join accept delay 1\n     *\n     * Related MIB type: \\ref MIB_JOIN_ACCEPT_DELAY_1\n     */\n    uint32_t join_accept_delay1;\n    /*!\n     * Join accept delay 2\n     *\n     * Related MIB type: \\ref MIB_JOIN_ACCEPT_DELAY_2\n     */\n    uint32_t join_accept_delay2;\n    /*!\n     * Channels data rate\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_DEFAULT_DATARATE\n     */\n    int8_t default_channel_data_rate;\n    /*!\n     * Channels data rate\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_DATARATE\n     */\n    int8_t channel_data_rate;\n    /*!\n     * Channels TX power\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_DEFAULT_TX_POWER\n     */\n    int8_t default_channel_tx_pwr;\n    /*!\n     * Channels TX power\n     *\n     * Related MIB type: \\ref MIB_CHANNELS_TX_POWER\n     */\n    int8_t channel_tx_pwr;\n    /*!\n     * LoRaWAN uplink counter\n     *\n     * Related MIB type: \\ref MIB_UPLINK_COUNTER\n     */\n    uint32_t ul_frame_counter;\n    /*!\n     * LoRaWAN downlink counter\n     *\n     * Related MIB type: \\ref MIB_DOWNLINK_COUNTER\n     */\n    uint32_t dl_frame_counter;\n    /*!\n     * Multicast channel\n     *\n     * Related MIB type: \\ref MIB_MULTICAST_CHANNEL\n     */\n    multicast_params_t* multicast_list;\n    /*!\n     * System overall timing error in milliseconds\n     *\n     * Related MIB type: \\ref MIB_SYSTEM_MAX_RX_ERROR\n     */\n    uint32_t max_rx_sys_error;\n    /*!\n     * Minimum required number of symbols to detect an RX frame\n     *\n     * Related MIB type: \\ref MIB_MIN_RX_SYMBOLS\n     */\n    uint8_t min_rx_symb;\n    /*!\n     * Antenna gain\n     *\n     * Related MIB type: \\ref MIB_ANTENNA_GAIN\n     */\n    float antenna_gain;\n} mib_params_t;\n\n/*!\n * LoRaMAC MIB-RequestConfirm structure\n */\ntypedef struct {\n    /*!\n     * MIB-Request type\n     */\n    mib_type_t type;\n\n    /*!\n     * MLME-RequestConfirm parameters\n     */\n    mib_params_t param;\n}loramac_mib_req_confirm_t;\n\n/*!\n * LoRaMAC TX information\n */\ntypedef struct {\n    /*!\n     * Defines the size of the applicable payload that can be processed.\n     */\n    uint8_t max_possible_payload_size;\n    /*!\n     * The current payload size, dependent on the current datarate.\n     */\n    uint8_t current_payload_size;\n} loramac_tx_info_t;\n\n/** LoRaMAC status.\n *\n */\ntypedef enum lorawan_status {\n    LORAWAN_STATUS_OK = 0,                         /**< Service started successfully */\n    LORAWAN_STATUS_BUSY = -1000,                   /**< Service not started - LoRaMAC is busy */\n    LORAWAN_STATUS_WOULD_BLOCK = -1001,            /**< LoRaMAC cannot send at the moment or have nothing to read */\n    LORAWAN_STATUS_SERVICE_UNKNOWN = -1002,        /**< Service unknown */\n    LORAWAN_STATUS_PARAMETER_INVALID = -1003,      /**< Service not started - invalid parameter */\n    LORAWAN_STATUS_FREQUENCY_INVALID = -1004,      /**< Service not started - invalid frequency */\n    LORAWAN_STATUS_DATARATE_INVALID = -1005,       /**< Service not started - invalid datarate */\n    LORAWAN_STATUS_FREQ_AND_DR_INVALID = -1006,    /**< Service not started - invalid frequency and datarate */\n    LORAWAN_STATUS_NO_NETWORK_JOINED = -1009,      /**< Service not started - the device is not in a LoRaWAN */\n    LORAWAN_STATUS_LENGTH_ERROR = -1010,           /**< Service not started - payload lenght error */\n    LORAWAN_STATUS_DEVICE_OFF = -1011,             /**< Service not started - the device is switched off */\n    LORAWAN_STATUS_NOT_INITIALIZED = -1012,        /**< Service not started - stack not initialized */\n    LORAWAN_STATUS_UNSUPPORTED = -1013,            /**< Service not supported */\n    LORAWAN_STATUS_CRYPTO_FAIL = -1014,            /**< Service not started - crypto failure */\n    LORAWAN_STATUS_PORT_INVALID = -1015,           /**< Invalid port */\n    LORAWAN_STATUS_CONNECT_IN_PROGRESS = -1016,    /**< Services started - Connection in progress */\n    LORAWAN_STATUS_NO_ACTIVE_SESSIONS = -1017,            /**< Services not started - No active session */\n    LORAWAN_STATUS_IDLE = -1018,                   /**< Services started - Idle at the moment */\n#if defined(LORAWAN_COMPLIANCE_TEST)\n    LORAWAN_STATUS_COMPLIANCE_TEST_ON = -1019,     /**< Compliance test - is on-going */\n#endif\n} lorawan_status_t;\n\n/*!\n * LoRaMAC events structure.\n * Used to notify upper layers of MAC events.\n */\ntypedef struct {\n    /*!\n     * \\brief   MCPS-Confirm primitive.\n     *\n     * \\param   [OUT] MCPS-Confirm parameters.\n     */\n    mbed::Callback<void(loramac_mcps_confirm_t*)> mcps_confirm;\n\n    /*!\n     * \\brief   MCPS-Indication primitive.\n     *\n     * \\param   [OUT] MCPS-Indication parameters.\n     */\n    mbed::Callback<void(loramac_mcps_indication_t*)> mcps_indication;\n\n    /*!\n     * \\brief   MLME-Confirm primitive.\n     *\n     * \\param   [OUT] MLME-Confirm parameters.\n     */\n    mbed::Callback<void(loramac_mlme_confirm_t*)> mlme_confirm;\n\n    /*!\n     * \\brief   MLME-Indication primitive\n     *\n     * \\param   [OUT] MLME-Indication parameters\n     */\n    mbed::Callback<void(loramac_mlme_indication_t*)> mlme_indication;\n}loramac_primitives_t;\n\n/** Enum of LoRaWAN connection type.\n *\n * The LoRaWAN connection type specifies how an end-device connects to the gateway.\n */\ntypedef enum lorawan_connect_type {\n    LORAWAN_CONNECTION_OTAA = 0,    /**< Over The Air Activation */\n    LORAWAN_CONNECTION_ABP          /**< Activation By Personalization */\n} lorawan_connect_type_t;\n\n/** The lorawan_connect_otaa structure.\n *\n * A structure representing the LoRaWAN Over The Air Activation\n * parameters.\n */\ntypedef struct {\n    /** End-device identifier\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.1\n     */\n    uint8_t *dev_eui;\n    /** Application identifier\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.2\n     */\n    uint8_t *app_eui;\n    /** AES-128 application key\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.2.2\n     */\n    uint8_t *app_key;\n    /** Join request trials\n     *\n     * Number of trials for the join request.\n     */\n    uint8_t nb_trials;\n} lorawan_connect_otaa_t;\n\n/** The lorawan_connect_abp structure.\n *\n * A structure representing the LoRaWAN Activation By Personalization\n * parameters.\n */\ntypedef struct {\n    /** Network identifier\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.1\n     */\n    uint32_t nwk_id;\n    /** End-device address\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.1\n     */\n    uint32_t dev_addr;\n    /** Network session key\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.3\n     */\n    uint8_t *nwk_skey;\n    /** Application session key\n     *\n     * LoRaWAN Specification V1.0.2, chapter 6.1.4\n     */\n    uint8_t *app_skey;\n} lorawan_connect_abp_t;\n\n/**\n * Stack level TX message structure\n */\ntypedef struct {\n\n    /**\n     * TX Ongoing flag\n     */\n    bool tx_ongoing;\n\n    /**\n     * Application Port Number\n     */\n    uint8_t port;\n\n    /**\n     * Message type\n     */\n    mcps_type_t type;\n\n    /*!\n     * Frame port field. Must be set if the payload is not empty. Use the\n     * application-specific frame port values: [1...223].\n     *\n     * LoRaWAN Specification V1.0.2, chapter 4.3.2.\n     */\n    uint8_t fport;\n\n    /*!\n     * Uplink datarate, if ADR is off.\n     */\n    int8_t data_rate;\n    /*!\n     * The number of trials to transmit the frame, if the LoRaMAC layer did not\n     * receive an acknowledgment. The MAC performs a datarate adaptation\n     * according to the LoRaWAN Specification V1.0.2, chapter 18.4, as in\n     * the following table:\n     *\n     * Transmission nb | Data Rate\n     * ----------------|-----------\n     * 1 (first)       | DR\n     * 2               | DR\n     * 3               | max(DR-1,0)\n     * 4               | max(DR-1,0)\n     * 5               | max(DR-2,0)\n     * 6               | max(DR-2,0)\n     * 7               | max(DR-3,0)\n     * 8               | max(DR-3,0)\n     *\n     * Note that if nb_trials is set to 1 or 2, the MAC will not decrease\n     * the datarate, if the LoRaMAC layer did not receive an acknowledgment.\n     */\n    uint8_t nb_trials;\n\n    /** Payload data\n     *\n     * Base pointer to the buffer\n     */\n    uint8_t f_buffer[MBED_CONF_LORA_TX_MAX_SIZE];\n\n    /** Payload size.\n     *\n     * The size of the frame payload.\n     */\n    uint16_t f_buffer_size;\n\n    /**\n     * Pending data size\n     */\n    uint16_t pending_size;\n\n} loramac_tx_message_t;\n\n/** lora_mac_rx_message_type_t\n *\n * An enum representing a structure for RX messages.\n */\ntypedef enum  {\n    LORAMAC_RX_MLME_CONFIRM = 0,    /**< lora_mac_mlme_confirm_t */\n    LORAMAC_RX_MCPS_CONFIRM,        /**< lora_mac_mcps_confirm_t */\n    LORAMAC_RX_MCPS_INDICATION      /**< lora_mac_mcps_indication_t */\n} rx_msg_type;\n\n/** lora_mac_rx_message_by_type_t union\n *\n * A union representing a structure for RX messages.\n */\ntypedef union {\n    loramac_mlme_confirm_t mlme_confirm;\n    loramac_mcps_confirm_t mcps_confirm;\n    loramac_mcps_indication_t mcps_indication;\n} rx_message_u;\n\n/** loramac_rx_message_t\n *\n * A structure representing a structure for an RX message.\n */\ntypedef struct {\n    bool receive_ready;\n    rx_msg_type type;\n    rx_message_u msg;\n    uint16_t pending_size;\n    uint16_t prev_read_size;\n} loramac_rx_message_t;\n\n/**\n * Structure to hold A list of LoRa Channels\n */\ntypedef struct lora_channels_s {\n    uint8_t id;\n    channel_params_t ch_param;\n} loramac_channel_t;\n\n\n/** lorawan_connect_t structure\n *\n * A structure representing the parameters for different connections.\n */\ntypedef struct lorawan_connect {\n    /*!\n     * Select the connection type, either LORAWAN_CONNECTION_OTAA\n     * or LORAWAN_CONNECTION_ABP.\n     */\n    uint8_t connect_type;\n\n    union {\n        /*!\n         * Join the network using OTA\n         */\n        lorawan_connect_otaa_t otaa;\n        /*!\n         * Authentication by personalization\n         */\n        lorawan_connect_abp_t abp;\n    } connection_u;\n\n} lorawan_connect_t;\n\n/** LoRaWAN session\n *\n * A structure for keeping session details.\n */\ntypedef struct lorawan_session {\n    /**\n     * True if the session is active\n     */\n    bool active;\n\n    lorawan_connect_t connection;\n    /**\n     * LoRaWAN uplink counter\n     *\n     * Related MIB type: LORA_MIB_UPLINK_COUNTER\n     */\n    uint32_t uplink_counter;\n    /**\n     * LoRaWAN downlink counter\n     *\n     * Related MIB type: LORA_MIB_DOWNLINK_COUNTER\n     */\n    uint32_t downlink_counter;\n} lorawan_session_t;\n\n/** Commissioning data\n *\n * A structure for data in commission.\n */\ntypedef struct {\n    /** Connection information\n     *\n     * Saves information for etc. keys\n     */\n    lorawan_connect_t connection;\n    /**\n     * LoRaWAN Up-link counter\n     *\n     * Related MIB type: LORA_MIB_UPLINK_COUNTER\n     */\n    uint32_t uplink_counter;\n    /**\n     * LoRaWAN Down-link counter\n     *\n     * Related MIB type: LORA_MIB_DOWNLINK_COUNTER\n     */\n    uint32_t downlink_counter;\n} lorawan_dev_commission_t;\n\n/** Structure containing the uplink status\n *\n */\ntypedef struct {\n    /** Is acked\n     *\n     */\n    uint8_t acked;\n    /** Uplink data rate\n     *\n     */\n    int8_t datarate;\n    /** Uplink counter\n     *\n     */\n    uint16_t uplink_counter;\n    /** Port is used by application\n     *\n     */\n    uint8_t port;\n    /** Payload\n     *\n     */\n    uint8_t *buffer;\n    /** Payload size\n     *\n     */\n    uint8_t buffer_size;\n} loramac_uplink_status_t;\n\n/** A structure containing the downlink status\n *\n */\ntypedef struct {\n    /** RSSI of downlink\n     *\n     */\n    int16_t rssi;\n    /** SNR of downlink\n     *\n     */\n    int8_t snr;\n    /** Downlink counter\n     *\n     */\n    uint16_t downlink_counter;\n    /** Is RX data received\n     *\n     */\n    bool rx_data;\n    /** Port used by application\n     *\n     */\n    uint8_t port;\n    /** Payload\n     *\n     */\n    uint8_t *buffer;\n    /** Payload size\n     *\n     */\n    uint8_t buffer_size;\n} loramac_downlink_status_t;\n\n/*!\n * The parameter structure for the function for regional rx configuration.\n */\ntypedef struct {\n    /*!\n     * The RX channel.\n     */\n    uint8_t channel;\n    /*!\n     * The RX datarate.\n     */\n    uint8_t datarate;\n    /*!\n     * The RX bandwidth.\n     */\n    uint8_t bandwidth;\n    /*!\n     * The RX datarate offset.\n     */\n    int8_t dr_offset;\n    /*!\n     * The RX frequency.\n     */\n    uint32_t frequency;\n    /*!\n     * The RX window timeout\n     */\n     uint32_t window_timeout;\n    /*!\n     * The RX window offset\n     */\n    int32_t window_offset;\n    /*!\n     * The downlink dwell time.\n     */\n    uint8_t dl_dwell_time;\n    /*!\n     * Set to true, if a repeater is supported.\n     */\n    bool is_repeater_supported;\n    /*!\n     * Set to true, if RX should be continuous.\n     */\n    bool is_rx_continuous;\n    /*!\n     * Sets the RX window.\n     */\n    rx_slot_t rx_slot;\n} rx_config_params_t;\n\n/*!\n * \\brief Timer object description\n */\ntypedef struct {\n    mbed::Callback<void()> callback;\n    int timer_id;\n} timer_event_t;\n\n/*!\n * LoRaMac internal states\n */\ntypedef enum {\n    LORAMAC_IDLE          = 0x00000000,\n    LORAMAC_TX_RUNNING    = 0x00000001,\n    LORAMAC_RX            = 0x00000002,\n    LORAMAC_ACK_REQ       = 0x00000004,\n    LORAMAC_ACK_RETRY     = 0x00000008,\n    LORAMAC_TX_DELAYED    = 0x00000010,\n    LORAMAC_TX_CONFIG     = 0x00000020,\n    LORAMAC_RX_ABORT      = 0x00000040,\n} loramac_internal_state;\n\ntypedef struct {\n    /*!\n     * Device IEEE EUI\n     */\n    uint8_t *dev_eui;\n\n    /*!\n     * Application IEEE EUI\n     */\n    uint8_t *app_eui;\n\n    /*!\n     * AES encryption/decryption cipher application key\n     */\n    uint8_t *app_key;\n\n    /*!\n     * AES encryption/decryption cipher network session key\n     */\n    uint8_t nwk_skey[16];\n\n    /*!\n     * AES encryption/decryption cipher application session key\n     */\n    uint8_t app_skey[16];\n\n} loramac_keys;\n\ntypedef struct {\n      /*!\n       * Aggregated duty cycle management\n       */\n      lorawan_time_t aggregated_last_tx_time;\n      lorawan_time_t aggregated_timeoff;\n\n      /*!\n       * Stores the time at LoRaMac initialization.\n       *\n       * \\remark Used for the BACKOFF_DC computation.\n       */\n      lorawan_time_t mac_init_time;\n\n\n      /*!\n       * Last transmission time on air\n       */\n      lorawan_time_t tx_toa;\n\n      /*!\n       * LoRaMac timer used to check the LoRaMacState (runs every second)\n       */\n      timer_event_t mac_state_check_timer;\n\n      /*!\n       * LoRaMac duty cycle delayed Tx timer\n       */\n      timer_event_t tx_delayed_timer;\n\n      /*!\n       * LoRaMac reception windows timers\n       */\n      timer_event_t rx_window1_timer;\n      timer_event_t rx_window2_timer;\n\n      /*!\n       * Acknowledge timeout timer. Used for packet retransmissions.\n       */\n      timer_event_t ack_timeout_timer;\n\n} lorawan_timers;\n\ntypedef struct {\n\n    /*!\n     * Actual device class\n     */\n    device_class_t dev_class;\n\n    /*!\n     * Holds the type of current Receive window slot\n     */\n     rx_slot_t rx_slot;\n\n    /*!\n     * Indicates if the node is connected to a private or public network\n     */\n    bool is_nwk_public;\n\n    /*!\n     * Indicates if the node supports repeaters\n     */\n    bool is_repeater_supported;\n\n    /*!\n     * IsPacketCounterFixed enables the MIC field tests by fixing the\n     * ul_frame_counter value\n     */\n    bool is_ul_frame_counter_fixed;\n\n    /*!\n     * Used for test purposes. Disables the opening of the reception windows.\n     */\n    bool is_rx_window_enabled;\n\n    /*!\n     * Indicates if the MAC layer has already joined a network.\n     */\n    bool is_nwk_joined;\n\n    /*!\n     * If the node has sent a FRAME_TYPE_DATA_CONFIRMED_UP this variable indicates\n     * if the nodes needs to manage the server acknowledgement.\n     */\n    bool is_node_ack_requested;\n\n    /*!\n     * If the server has sent a FRAME_TYPE_DATA_CONFIRMED_DOWN this variable indicates\n     * if the ACK bit must be set for the next transmission\n     */\n    bool is_srv_ack_requested;\n\n    /*!\n     * Enables/Disables duty cycle management (Test only)\n     */\n    bool is_dutycycle_on;\n\n    /*!\n     * Set to true, if the last uplink was a join request\n     */\n    bool is_last_tx_join_request;\n\n    /*!\n     * Indicates if the AckTimeout timer has expired or not\n     */\n    bool is_ack_retry_timeout_expired;\n\n    /*!\n     * Current channel index\n     */\n    uint8_t channel;\n\n    /*!\n     * Current channel index\n     */\n    uint8_t last_channel_idx;\n\n    /*!\n     * Uplink messages repetitions counter\n     */\n    uint8_t ul_nb_rep_counter;\n\n    /*!\n     * Buffer containing the data to be sent or received.\n     */\n    uint8_t buffer[LORAMAC_PHY_MAXPAYLOAD];\n\n    /*!\n     * Length of packet in LoRaMacBuffer\n     */\n    uint16_t buffer_pkt_len;\n\n    /*!\n     * Buffer containing the upper layer data.\n     */\n    uint8_t payload[LORAMAC_PHY_MAXPAYLOAD];\n\n    /*!\n     * Length of the payload in LoRaMacBuffer\n     */\n    uint8_t payload_length;\n\n    /*!\n     * Number of trials to get a frame acknowledged\n     */\n    uint8_t max_ack_timeout_retries;\n\n    /*!\n     * Number of trials to get a frame acknowledged\n     */\n    uint8_t ack_timeout_retry_counter;\n\n    /*!\n     * Maximum number of trials for the Join Request\n     */\n    uint8_t max_join_request_trials;\n\n    /*!\n     * Number of trials for the Join Request\n     */\n    uint8_t join_request_trial_counter;\n\n    /*!\n     * Mac keys\n     */\n    loramac_keys keys;\n\n    /*!\n     * LoRaMac tx/rx operation state\n     */\n    loramac_flags_t flags;\n\n    /*!\n     * Device nonce is a random value extracted by issuing a sequence of RSSI\n     * measurements\n     */\n    uint16_t dev_nonce;\n\n    /*!\n     * Network ID ( 3 bytes )\n     */\n    uint32_t net_id;\n\n    /*!\n     * Mote Address\n     */\n    uint32_t dev_addr;\n\n    /*!\n     * LoRaMAC frame counter. Each time a packet is sent the counter is incremented.\n     * Only the 16 LSB bits are sent\n     */\n    uint32_t ul_frame_counter;\n\n    /*!\n     * LoRaMAC frame counter. Each time a packet is received the counter is incremented.\n     * Only the 16 LSB bits are received\n     */\n    uint32_t dl_frame_counter;\n\n    /*!\n     * Counts the number of missed ADR acknowledgements\n     */\n    uint32_t adr_ack_counter;\n\n    /*!\n     * LoRaMac internal state\n     */\n    uint32_t mac_state;\n\n    /*!\n     * LoRaMac reception windows delay\n     * \\remark normal frame: RxWindowXDelay = ReceiveDelayX - RADIO_WAKEUP_TIME\n     *         join frame  : RxWindowXDelay = JoinAcceptDelayX - RADIO_WAKEUP_TIME\n     */\n    uint32_t rx_window1_delay;\n    uint32_t rx_window2_delay;\n\n    /*!\n     * Timer objects and stored values\n     */\n    lorawan_timers timers;\n\n    /*!\n     * LoRaMac parameters\n     */\n    lora_mac_system_params_t sys_params;\n\n    /*!\n     * Receive Window configurations for PHY layer\n     */\n    rx_config_params_t rx_window1_config;\n    rx_config_params_t rx_window2_config;\n\n    /*!\n     * Multicast channels linked list\n     */\n    multicast_params_t *multicast_channels;\n\n} loramac_protocol_params;\n\n/** LoRaWAN callback functions\n *\n */\ntypedef enum lora_events {\n    CONNECTED=0,\n    DISCONNECTED,\n    TX_DONE,\n    TX_TIMEOUT,\n    TX_ERROR,\n    TX_CRYPTO_ERROR,\n    TX_SCHEDULING_ERROR,\n    RX_DONE,\n    RX_TIMEOUT,\n    RX_ERROR,\n    JOIN_FAILURE,\n} lorawan_event_t;\n\ntypedef struct  {\n     // Mandatory. Event Callback must be provided\n     mbed::Callback<void(lorawan_event_t)> events;\n\n     // Rest are optional\n     // If the user do not assign these callbacks, these callbacks would return\n     // null if checked with bool operator\n     // link_check_resp callback and other such callbacks will be maped in\n     // future releases of Mbed-OS\n     mbed::Callback<void(uint8_t, uint8_t)> link_check_resp;\n\n     // Battery level callback goes in the down direction, i.e., it informs\n     // the stack about the battery level by calling a function provided\n     // by the upper layers\n     mbed::Callback<uint8_t(void)> battery_level;\n } lorawan_app_callbacks_t;\n\ntypedef struct lora_channelplan {\n    uint8_t nb_channels;    // number of channels\n    loramac_channel_t *channels;\n} lorawan_channelplan_t;\n\n#if defined(LORAWAN_COMPLIANCE_TEST)\n/**  LoRaWAN compliance tests support data\n *\n */\ntypedef struct compliance_test {\n    /** Is test running\n     *\n     */\n    bool running;\n    /** State of test\n     *\n     */\n    uint8_t state;\n    /** Is TX confirmed\n     *\n     */\n    bool is_tx_confirmed;\n    /** Port used by the application\n     *\n     */\n    uint8_t app_port;\n    /** Maximum size of data used by application\n     *\n     */\n    uint8_t app_data_size;\n    /** Data provided by application\n     *\n     */\n    uint8_t *app_data_buffer;\n    /** Downlink counter\n     *\n     */\n    uint16_t downlink_counter;\n    /** Is link check required\n     *\n     */\n    bool link_check;\n    /** Demodulation margin\n     *\n     */\n    uint8_t demod_margin;\n    /** Number of gateways\n     *\n     */\n    uint8_t nb_gateways;\n} compliance_test_t;\n#endif\n\n#endif /* LORAWAN_SYSTEM_LORAWAN_DATA_STRUCTURES_H_ */\n","/**\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef LORARADIO_H_\n#define LORARADIO_H_\n\n#include \"platform/Callback.h\"\n#include \"PinNames.h\"\n\n/**\n * Structure to hold RF controls for LoRa Radio.\n * SX1276 have an extra control for the crystal (used in DOSCO-L072CZ)\n */\ntypedef struct {\n    PinName rf_switch_ctl1;\n    PinName rf_switch_ctl2;\n    PinName txctl;\n    PinName rxctl;\n    PinName ant_switch;\n    PinName pwr_amp_ctl;\n    PinName tcxo;\n} rf_ctrls;\n\n/** Radio driver internal state.\n * State machine states definition.\n */\ntypedef enum radio_state {\n    RF_IDLE = 0,\n    RF_RX_RUNNING,\n    RF_TX_RUNNING,\n    RF_CAD,\n} radio_state_t;\n\n/** Type of the modem.\n *  [LORA/FSK]\n */\ntypedef enum modem_type {\n    MODEM_FSK = 0,\n    MODEM_LORA\n} radio_modems_t;\n\n/** Radio FSK modem parameters.\n *\n */\ntypedef struct radio_fsk_settings {\n    int8_t   power;\n    uint32_t f_dev;\n    uint32_t bandwidth;\n    uint32_t bandwidth_afc;\n    uint32_t datarate;\n    uint16_t preamble_len;\n    bool     fix_len;\n    uint8_t  payload_len;\n    bool     crc_on;\n    bool     iq_inverted;\n    bool     rx_continuous;\n    uint32_t tx_timeout;\n    uint32_t rx_single_timeout;\n} radio_fsk_settings_t;\n\n/** Radio FSK packet handler state.\n *\n */\ntypedef struct radio_fsk_packet_handler {\n    uint8_t  preamble_detected;\n    uint8_t  sync_word_detected;\n    int8_t   rssi_value;\n    int32_t  afc_value;\n    uint8_t  rx_gain;\n    uint16_t size;\n    uint16_t nb_bytes;\n    uint8_t  fifo_thresh;\n    uint8_t  chunk_size;\n} radio_fsk_packet_handler_t;\n\n/** Radio LoRa modem parameters.\n *\n */\ntypedef struct radio_lora_settings {\n    int8_t   power;\n    uint32_t bandwidth;\n    uint32_t datarate;\n    bool     low_datarate_optimize;\n    uint8_t  coderate;\n    uint16_t preamble_len;\n    bool     fix_len;\n    uint8_t  payload_len;\n    bool     crc_on;\n    bool     freq_hop_on;\n    uint8_t  hop_period;\n    bool     iq_inverted;\n    bool     rx_continuous;\n    uint32_t tx_timeout;\n    bool     public_network;\n} radio_lora_settings_t;\n\n/** Radio LoRa packet handler state.\n *\n */\ntypedef struct radio_lora_packet_handler {\n    int8_t  snr_value;\n    int8_t  rssi_value;\n    uint8_t size;\n    bool    pending;\n} radio_lora_packet_handler_t;\n\n/** Radio settings.\n *\n */\ntypedef struct radio_settings {\n    uint8_t                     state;\n    uint8_t                     modem;\n    uint32_t                    channel;\n    radio_fsk_settings_t        fsk;\n    radio_fsk_packet_handler_t  fsk_packet_handler;\n    radio_lora_settings_t       lora;\n    radio_lora_packet_handler_t lora_packet_handler;\n} radio_settings_t;\n\n/** Radio driver callback functions.\n *\n */\ntypedef struct radio_events {\n    /**\n     * Callback when Transmission is done\n     */\n    mbed::Callback<void()> tx_done;\n\n    /**\n     * Callback when Transmission is timed out\n     */\n    mbed::Callback<void()> tx_timeout;\n\n    /**\n     * Rx Done callback prototype.\n     *\n     *  @param payload Received buffer pointer.\n     *  @param size    Received buffer size.\n     *  @param rssi    RSSI value computed while receiving the frame [dBm].\n     *  @param snr     Raw SNR value given by the radio hardware.\n     *                     FSK : N/A (set to 0)\n     *                     LoRa: SNR value in dB\n     */\n    mbed::Callback<void(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr)> rx_done;\n\n    /**\n     * Callback when Reception is timed out\n     */\n    mbed::Callback<void()> rx_timeout;\n\n    /**\n     * Callback when Reception ends up in error\n     */\n    mbed::Callback<void()> rx_error;\n\n   /**\n    * FHSS Change Channel callback prototype.\n    *\n    *  @param current_channel   The index number of the current channel.\n    */\n    mbed::Callback<void(uint8_t current_channel)> fhss_change_channel;\n\n    /**\n     * CAD Done callback prototype.\n     *\n     *  @param channel_busy    True, if Channel activity detected.\n     */\n    mbed::Callback<void(bool channel_busy)> cad_done;\n} radio_events_t;\n\n/**\n *    Interface for the radios, contains the main functions that a radio needs, and five callback functions.\n */\nclass LoRaRadio\n{\n\npublic:\n\n    /**\n     * Registers radio events with the Mbed LoRaWAN stack and undergoes the initialization steps if any.\n     *\n     *  @param events The structure containing the driver callback functions.\n     */\n    virtual void init_radio(radio_events_t *events) = 0;\n\n    /**\n     * Resets the radio module.\n     */\n    virtual void radio_reset() = 0;\n\n    /**\n     *  Put the RF module in the sleep mode.\n     */\n    virtual void sleep(void) = 0;\n\n    /**\n     *  Sets the radio in the standby mode.\n     */\n    virtual void standby(void) = 0;\n\n    /**\n     *  Sets the reception parameters.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param bandwidth     Sets the bandwidth.\n     *                          FSK : >= 2600 and <= 250000 Hz\n     *                          LoRa: [0: 125 kHz, 1: 250 kHz,\n     *                                 2: 500 kHz, 3: Reserved]\n     *  @param datarate      Sets the datarate.\n     *                          FSK : 600..300000 bits/s\n     *                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,\n     *                                10: 1024, 11: 2048, 12: 4096  chips]\n     *  @param coderate      Sets the coding rate (LoRa only).\n     *                          FSK : N/A ( set to 0 )\n     *                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]\n     *  @param bandwidth_afc Sets the AFC bandwidth (FSK only).\n     *                          FSK : >= 2600 and <= 250000 Hz\n     *                          LoRa: N/A (set to 0)\n     *  @param preamble_len  Sets the preamble length (LoRa only).\n     *                          FSK : N/A (set to 0)\n     *                          LoRa: Length in symbols (the hardware adds four more symbols).\n     *  @param symb_timeout  Sets the RxSingle timeout value.\n     *                          FSK : Timeout number of bytes\n     *                          LoRa: Timeout in symbols\n     *  @param fix_len        Fixed length packets [0: variable, 1: fixed].\n     *  @param payload_len   Sets the payload length when fixed length is used.\n     *  @param crc_on        Enables/disables the CRC [0: OFF, 1: ON].\n     *  @param freq_hop_on   Enables/disables the intra-packet frequency hopping [0: OFF, 1: ON] (LoRa only).\n     *  @param hop_period    The number of symbols bewteen each hop (LoRa only).\n     *  @param iq_inverted   Inverts the IQ signals (LoRa only).\n     *                          FSK : N/A (set to 0)\n     *                          LoRa: [0: not inverted, 1: inverted]\n     *  @param rx_continuous Sets the reception in continuous mode.\n     *                          [false: single mode, true: continuous mode]\n     */\n    virtual void set_rx_config (radio_modems_t modem, uint32_t bandwidth,\n                               uint32_t datarate, uint8_t coderate,\n                               uint32_t bandwidth_afc, uint16_t preamble_len,\n                               uint16_t symb_timeout, bool fix_len,\n                               uint8_t payload_len,\n                               bool crc_on, bool freq_hop_on, uint8_t hop_period,\n                               bool iq_inverted, bool rx_continuous) = 0;\n\n    /**\n     *  Sets the transmission parameters.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param power         Sets the output power [dBm].\n     *  @param fdev          Sets the frequency deviation (FSK only).\n     *                          FSK : [Hz]\n     *                          LoRa: 0\n     *  @param bandwidth     Sets the bandwidth (LoRa only).\n     *                          FSK : 0\n     *                          LoRa: [0: 125 kHz, 1: 250 kHz,\n     *                                 2: 500 kHz, 3: Reserved]\n     *  @param datarate      Sets the datarate.\n     *                          FSK : 600..300000 bits/s\n     *                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,\n     *                                10: 1024, 11: 2048, 12: 4096  chips]\n     *  @param coderate      Sets the coding rate (LoRa only).\n     *                          FSK : N/A ( set to 0 )\n     *                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]\n     *  @param preamble_len  Sets the preamble length.\n     *  @param fix_len       Fixed length packets [0: variable, 1: fixed].\n     *  @param crc_on        Enables/disables the CRC [0: OFF, 1: ON].\n     *  @param freq_hop_on   Enables/disables the intra-packet frequency hopping [0: OFF, 1: ON] (LoRa only).\n     *  @param hop_period    The number of symbols between each hop (LoRa only).\n     *  @param iq_inverted   Inverts IQ signals (LoRa only)\n     *                          FSK : N/A (set to 0).\n     *                          LoRa: [0: not inverted, 1: inverted]\n     *  @param timeout       The transmission timeout [us].\n     */\n    virtual void set_tx_config(radio_modems_t modem, int8_t power, uint32_t fdev,\n                              uint32_t bandwidth, uint32_t datarate,\n                              uint8_t coderate, uint16_t preamble_len,\n                              bool fix_len, bool crc_on, bool freq_hop_on,\n                              uint8_t hop_period, bool iq_inverted, uint32_t timeout) = 0;\n\n    /**\n     *  Sends the buffer of size\n     *\n     *  Prepares the packet to be sent and sets the radio in transmission.\n     *\n     *  @param buffer        A pointer to the buffer.\n     *  @param size          The buffer size.\n     */\n    virtual void send(uint8_t *buffer, uint8_t size) = 0;\n\n    /**\n     *  Sets the radio in reception mode for a given time.\n     *\n     *  If the timeout is set to 0, it essentially puts the receiver in continuous mode and it should\n     *  be treated as if in continuous mode. However, an appropriate way to set the receiver in continuous mode is\n     *  to use the `set_rx_config()` API.\n     *\n     *  @param timeout       Reception timeout [ms].\n     *\n     */\n    virtual void receive(uint32_t timeout) = 0;\n\n    /**\n     *  Sets the carrier frequency\n     *\n     *  @param freq          Channel RF frequency.\n     */\n    virtual void set_channel(uint32_t freq) = 0;\n\n    /**\n     *  Generates a 32 bit random value based on the RSSI readings.\n     *\n     *  \\remark This function sets the radio in LoRa modem mode and disables all interrupts.\n     *          After calling this function, either `Radio.SetRxConfig` or\n     *         `Radio.SetTxConfig` functions must be called.\n     *\n     *  @return             A 32 bit random value.\n     */\n    virtual uint32_t random(void) = 0;\n\n    /**\n     *  Gets the radio status.\n     *\n     *  @return              The current radio status.\n     */\n    virtual uint8_t get_status(void) = 0;\n\n    /**\n     *  Sets the maximum payload length.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param max           The maximum payload length in bytes.\n     */\n    virtual void set_max_payload_length(radio_modems_t modem, uint8_t max) = 0;\n\n    /**\n     *  Sets the network to public or private.\n     *\n     *  Updates the sync byte. Applies to LoRa modem only.\n     *\n     *  @param enable        If true, it enables a public network.\n     */\n    virtual void set_public_network(bool enable) = 0;\n\n    /**\n     *  Computes the packet time on air for the given payload.\n     *\n     *  \\remark This can only be called once `SetRxConfig` or `SetTxConfig` have been called.\n     *\n     *  @param modem         The radio modem to be used [0: FSK, 1: LoRa].\n     *  @param pkt_len       The packet payload length.\n     *  @return              The computed `airTime` for the given packet payload length.\n     */\n    virtual uint32_t time_on_air(radio_modems_t modem, uint8_t pkt_len) = 0;\n\n    /**\n     * Performs carrier sensing.\n     *\n     * Checks for a certain time if the RSSI is above a given threshold.\n     * This threshold determines whether or not there is a transmission going on\n     * in the channel already.\n     *\n     * @param modem                     The type of the radio modem.\n     * @param freq                      The carrier frequency.\n     * @param rssi_threshold            The threshold value of RSSI.\n     * @param max_carrier_sense_time    The time set for sensing the channel (ms).\n     *\n     * @return                          True if there is no active transmission\n     *                                  in the channel, otherwise false.\n     */\n    virtual bool perform_carrier_sense(radio_modems_t modem,\n                                       uint32_t freq,\n                                       int16_t rssi_threshold,\n                                       uint32_t max_carrier_sense_time) = 0;\n\n    /**\n     *  Sets the radio in CAD mode.\n     *\n     */\n    virtual void start_cad(void) = 0;\n\n    /**\n     *  Checks whether the given RF is in range.\n     *\n     *  @param frequency       The frequency to be checked.\n     */\n    virtual bool check_rf_frequency(uint32_t frequency) = 0;\n\n    /** Sets the radio in continuous wave transmission mode.\n     *\n     *  @param freq          The RF frequency of the channel.\n     *  @param power         The output power [dBm].\n     *  @param time          The transmission mode timeout [s].\n     */\n    virtual void set_tx_continuous_wave(uint32_t freq, int8_t power, uint16_t time) = 0;\n\n    /**\n     * Acquires exclusive access to this radio.\n     */\n    virtual void lock(void) = 0;\n\n    /**\n     * Releases the exclusive access to this radio.\n     */\n    virtual void unlock(void) = 0;\n};\n\n#endif // LORARADIO_H_\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef EVENT_QUEUE_H\n#define EVENT_QUEUE_H\n\n#include \"equeue/equeue.h\"\n#include \"platform/Callback.h\"\n#include \"platform/NonCopyable.h\"\n#include <cstddef>\n#include <new>\n\nnamespace events {\n/** \\addtogroup events */\n\n/** EVENTS_EVENT_SIZE\n *  Minimum size of an event\n *  This size fits a Callback<void()> at minimum\n */\n#define EVENTS_EVENT_SIZE \\\n    (EQUEUE_EVENT_SIZE - 2*sizeof(void*) + sizeof(mbed::Callback<void()>))\n\n/** EVENTS_QUEUE_SIZE\n *  Default size of buffer for events\n */\n#define EVENTS_QUEUE_SIZE (32*EVENTS_EVENT_SIZE)\n\n// Predeclared classes\ntemplate <typename F>\nclass Event;\n\n\n/** EventQueue\n *\n *  Flexible event queue for dispatching events\n * @ingroup events\n */\nclass EventQueue : private mbed::NonCopyable<EventQueue> {\npublic:\n    /** Create an EventQueue\n     *\n     *  Create an event queue. The event queue either allocates a buffer of\n     *  the specified size with malloc or uses the user provided buffer.\n     *\n     *  @param size     Size of buffer to use for events in bytes\n     *                  (default to EVENTS_QUEUE_SIZE)\n     *  @param buffer   Pointer to buffer to use for events\n     *                  (default to NULL)\n     */\n    EventQueue(unsigned size=EVENTS_QUEUE_SIZE, unsigned char *buffer=NULL);\n\n    /** Destroy an EventQueue\n     */\n    ~EventQueue();\n\n    /** Dispatch events\n     *\n     *  Executes events until the specified milliseconds have passed.\n     *  If ms is negative, the dispatch function will dispatch events\n     *  indefinitely or until break_dispatch is called on this queue.\n     *\n     *  When called with a finite timeout, the dispatch function is guaranteed\n     *  to terminate. When called with a timeout of 0, the dispatch function\n     *  does not wait and is irq safe.\n     *\n     *  @param ms       Time to wait for events in milliseconds, a negative\n     *                  value will dispatch events indefinitely\n     *                  (default to -1)\n     */\n    void dispatch(int ms=-1);\n\n    /** Dispatch events without a timeout\n     *\n     *  This is equivalent to EventQueue::dispatch with no arguments, but \n     *  avoids overload ambiguities when passed as a callback.\n     *\n     *  @see EventQueue::dispatch\n     */\n    void dispatch_forever() { dispatch(); }\n\n    /** Break out of a running event loop\n     *\n     *  Forces the specified event queue's dispatch loop to terminate. Pending\n     *  events may finish executing, but no new events will be executed.\n     */\n    void break_dispatch();\n\n    /** Millisecond counter\n     *\n     *  Returns the underlying tick of the event queue represented as the \n     *  number of milliseconds that have passed since an arbitrary point in\n     *  time. Intentionally overflows to 0 after 2^32-1.\n     *\n     *  @return         The underlying tick of the event queue in milliseconds\n     */\n    unsigned tick();\n\n    /** Cancel an in-flight event\n     *\n     *  Attempts to cancel an event referenced by the unique id returned from\n     *  one of the call functions. It is safe to call cancel after an event\n     *  has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     *\n     *  @param id       Unique id of the event\n     */\n    void cancel(int id);\n\n    /** Background an event queue onto a single-shot timer-interrupt\n     *\n     *  When updated, the event queue will call the provided update function\n     *  with a timeout indicating when the queue should be dispatched. A\n     *  negative timeout will be passed to the update function when the\n     *  timer-interrupt is no longer needed.\n     *\n     *  Passing a null function disables the existing update function.\n     *\n     *  The background function allows an event queue to take advantage of\n     *  hardware timers or other event loops, allowing an event queue to be\n     *  ran in the background without consuming the foreground thread.\n     *\n     *  @param update   Function called to indicate when the queue should be\n     *                  dispatched\n     */\n    void background(mbed::Callback<void(int)> update);\n\n    /** Chain an event queue onto another event queue\n     *\n     *  After chaining a queue to a target, calling dispatch on the target\n     *  queue will also dispatch events from this queue. The queues use\n     *  their own buffers and events must be handled independently.\n     *\n     *  A null queue as the target will unchain the existing queue.\n     *\n     *  The chain function allows multiple event queues to be composed,\n     *  sharing the context of a dispatch loop while still being managed\n     *  independently\n     *\n     *  @param target   Queue that will dispatch this queue's events as a\n     *                  part of its dispatch loop\n     */\n    void chain(EventQueue *target);\n\n    /** Calls an event on the queue\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call(F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call(F f, A0 a0) {\n        return call(context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call(F f, A0 a0, A1 a1) {\n        return call(context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call(F f, A0 a0, A1 a1, A2 a2) {\n        return call(context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue\n     *  @see                     EventQueue::call\n     *  @param f                 Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(T *obj, R (T::*method)()) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const T *obj, R (T::*method)() const) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(volatile T *obj, R (T::*method)() volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const volatile T *obj, R (T::*method)() const volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(T *obj, R (T::*method)(A0), A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_in function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Time to delay in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_in(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0                   Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call_in(int ms, F f, A0 a0) {\n        return call_in(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1                Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call_in(int ms, F f, A0 a0, A1 a1) {\n        return call_in(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2             Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3          Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, T *obj, R (T::*method)()) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const T *obj, R (T::*method)() const) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *\n     *  @note The first call_every event occurs after the specified delay.\n     *  To create a periodic event that fires immediately, @see Event.\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_every function is irq safe and can act as a mechanism for\n     *  moving events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Period of the event in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_every(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_period(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0>\n    int call_every(int ms, F f, A0 a0) {\n        return call_every(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1>\n    int call_every(int ms, F f, A0 a0, A1 a1) {\n        return call_every(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3      Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, T *obj, R (T::*method)()) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const T *obj, R (T::*method)() const) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Creates an event bound to the event queue\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param func        Function to execute when the event is dispatched\n     *  @return            Event that will dispatch on the specific queue\n     */\n    template <typename R>\n    Event<void()> event(R (*func)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(T *obj, R (T::*method)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const T *obj, R (T::*method)() const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(volatile T *obj, R (T::*method)() volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const volatile T *obj, R (T::*method)() const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R>\n    Event<void()> event(mbed::Callback<R()> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(R (*func)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(T *obj, R (T::*method)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const T *obj, R (T::*method)(B0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(mbed::Callback<R(B0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(R (*func)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(R (*func)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(A0) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(A0) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(A0) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(A0)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(R (*func)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, A0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, A0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(A0, A1) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(A0, A1) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(A0, A1) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(A0, A1)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(A0, A1, A2) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(A0, A1, A2)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(A0, A1, A2, A3) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(A0, A1, A2, A3)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\nprotected:\n    template <typename F>\n    friend class Event;\n    struct equeue _equeue;\n    mbed::Callback<void(int)> _update;\n\n    // Function attributes\n    template <typename F>\n    static void function_call(void *p) {\n        (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Context structures\n    template <typename F>\n    struct context00 {\n        F f;\n\n        context00(F f)\n            : f(f) {}\n\n        void operator()() {\n            f();\n        }\n    };\n\n    template <typename F, typename C0>\n    struct context10 {\n        F f; C0 c0;\n\n        context10(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()() {\n            f(c0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1>\n    struct context20 {\n        F f; C0 c0; C1 c1;\n\n        context20(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()() {\n            f(c0, c1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2>\n    struct context30 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context30(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()() {\n            f(c0, c1, c2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    struct context40 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context40(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    struct context50 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context50(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3, c4);\n        }\n    };\n\n    template <typename F, typename A0>\n    struct context01 {\n        F f;\n\n        context01(F f)\n            : f(f) {}\n\n        void operator()(A0 a0) {\n            f(a0);\n        }\n    };\n\n    template <typename F, typename C0, typename A0>\n    struct context11 {\n        F f; C0 c0;\n\n        context11(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0) {\n            f(c0, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0>\n    struct context21 {\n        F f; C0 c0; C1 c1;\n\n        context21(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0>\n    struct context31 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context31(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0>\n    struct context41 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context41(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    struct context51 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context51(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, c4, a0);\n        }\n    };\n\n    template <typename F, typename A0, typename A1>\n    struct context02 {\n        F f;\n\n        context02(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1>\n    struct context12 {\n        F f; C0 c0;\n\n        context12(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1>\n    struct context22 {\n        F f; C0 c0; C1 c1;\n\n        context22(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1>\n    struct context32 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context32(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    struct context42 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context42(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    struct context52 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context52(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, c4, a0, a1);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2>\n    struct context03 {\n        F f;\n\n        context03(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2>\n    struct context13 {\n        F f; C0 c0;\n\n        context13(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2>\n    struct context23 {\n        F f; C0 c0; C1 c1;\n\n        context23(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    struct context33 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context33(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    struct context43 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context43(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    struct context53 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context53(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    struct context04 {\n        F f;\n\n        context04(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3>\n    struct context14 {\n        F f; C0 c0;\n\n        context14(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    struct context24 {\n        F f; C0 c0; C1 c1;\n\n        context24(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    struct context34 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context34(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    struct context44 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context44(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    struct context54 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context54(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context05 {\n        F f;\n\n        context05(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context15 {\n        F f; C0 c0;\n\n        context15(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context25 {\n        F f; C0 c0; C1 c1;\n\n        context25(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context35 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context35(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context45 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context45(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context55 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context55(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n}\n\n#endif\n\n","/*\n *  FIPS-197 compliant AES implementation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n/*\n *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.\n *\n *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf\n *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_AES_C)\n\n#include <string.h>\n\n#include \"mbedtls/aes.h\"\n#if defined(MBEDTLS_PADLOCK_C)\n#include \"mbedtls/padlock.h\"\n#endif\n#if defined(MBEDTLS_AESNI_C)\n#include \"mbedtls/aesni.h\"\n#endif\n\n#if defined(MBEDTLS_SELF_TEST)\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdio.h>\n#define mbedtls_printf printf\n#endif /* MBEDTLS_PLATFORM_C */\n#endif /* MBEDTLS_SELF_TEST */\n\n#if !defined(MBEDTLS_AES_ALT)\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;\n}\n\n/*\n * 32-bit integer manipulation macros (little endian)\n */\n#ifndef GET_UINT32_LE\n#define GET_UINT32_LE(n,b,i)                            \\\n{                                                       \\\n    (n) = ( (uint32_t) (b)[(i)    ]       )             \\\n        | ( (uint32_t) (b)[(i) + 1] <<  8 )             \\\n        | ( (uint32_t) (b)[(i) + 2] << 16 )             \\\n        | ( (uint32_t) (b)[(i) + 3] << 24 );            \\\n}\n#endif\n\n#ifndef PUT_UINT32_LE\n#define PUT_UINT32_LE(n,b,i)                                    \\\n{                                                               \\\n    (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );    \\\n    (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );    \\\n    (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );    \\\n    (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    \\\n}\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) &&                      \\\n    ( defined(MBEDTLS_HAVE_X86) || defined(MBEDTLS_PADLOCK_ALIGN16) )\nstatic int aes_padlock_ace = -1;\n#endif\n\n#if defined(MBEDTLS_AES_ROM_TABLES)\n/*\n * Forward S-box\n */\nstatic const unsigned char FSb[256] =\n{\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,\n    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,\n    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,\n    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,\n    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,\n    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,\n    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,\n    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,\n    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,\n    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,\n    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,\n    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,\n    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,\n    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,\n    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,\n    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,\n    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n};\n\n/*\n * Forward tables\n */\n#define FT \\\n\\\n    V(A5,63,63,C6), V(84,7C,7C,F8), V(99,77,77,EE), V(8D,7B,7B,F6), \\\n    V(0D,F2,F2,FF), V(BD,6B,6B,D6), V(B1,6F,6F,DE), V(54,C5,C5,91), \\\n    V(50,30,30,60), V(03,01,01,02), V(A9,67,67,CE), V(7D,2B,2B,56), \\\n    V(19,FE,FE,E7), V(62,D7,D7,B5), V(E6,AB,AB,4D), V(9A,76,76,EC), \\\n    V(45,CA,CA,8F), V(9D,82,82,1F), V(40,C9,C9,89), V(87,7D,7D,FA), \\\n    V(15,FA,FA,EF), V(EB,59,59,B2), V(C9,47,47,8E), V(0B,F0,F0,FB), \\\n    V(EC,AD,AD,41), V(67,D4,D4,B3), V(FD,A2,A2,5F), V(EA,AF,AF,45), \\\n    V(BF,9C,9C,23), V(F7,A4,A4,53), V(96,72,72,E4), V(5B,C0,C0,9B), \\\n    V(C2,B7,B7,75), V(1C,FD,FD,E1), V(AE,93,93,3D), V(6A,26,26,4C), \\\n    V(5A,36,36,6C), V(41,3F,3F,7E), V(02,F7,F7,F5), V(4F,CC,CC,83), \\\n    V(5C,34,34,68), V(F4,A5,A5,51), V(34,E5,E5,D1), V(08,F1,F1,F9), \\\n    V(93,71,71,E2), V(73,D8,D8,AB), V(53,31,31,62), V(3F,15,15,2A), \\\n    V(0C,04,04,08), V(52,C7,C7,95), V(65,23,23,46), V(5E,C3,C3,9D), \\\n    V(28,18,18,30), V(A1,96,96,37), V(0F,05,05,0A), V(B5,9A,9A,2F), \\\n    V(09,07,07,0E), V(36,12,12,24), V(9B,80,80,1B), V(3D,E2,E2,DF), \\\n    V(26,EB,EB,CD), V(69,27,27,4E), V(CD,B2,B2,7F), V(9F,75,75,EA), \\\n    V(1B,09,09,12), V(9E,83,83,1D), V(74,2C,2C,58), V(2E,1A,1A,34), \\\n    V(2D,1B,1B,36), V(B2,6E,6E,DC), V(EE,5A,5A,B4), V(FB,A0,A0,5B), \\\n    V(F6,52,52,A4), V(4D,3B,3B,76), V(61,D6,D6,B7), V(CE,B3,B3,7D), \\\n    V(7B,29,29,52), V(3E,E3,E3,DD), V(71,2F,2F,5E), V(97,84,84,13), \\\n    V(F5,53,53,A6), V(68,D1,D1,B9), V(00,00,00,00), V(2C,ED,ED,C1), \\\n    V(60,20,20,40), V(1F,FC,FC,E3), V(C8,B1,B1,79), V(ED,5B,5B,B6), \\\n    V(BE,6A,6A,D4), V(46,CB,CB,8D), V(D9,BE,BE,67), V(4B,39,39,72), \\\n    V(DE,4A,4A,94), V(D4,4C,4C,98), V(E8,58,58,B0), V(4A,CF,CF,85), \\\n    V(6B,D0,D0,BB), V(2A,EF,EF,C5), V(E5,AA,AA,4F), V(16,FB,FB,ED), \\\n    V(C5,43,43,86), V(D7,4D,4D,9A), V(55,33,33,66), V(94,85,85,11), \\\n    V(CF,45,45,8A), V(10,F9,F9,E9), V(06,02,02,04), V(81,7F,7F,FE), \\\n    V(F0,50,50,A0), V(44,3C,3C,78), V(BA,9F,9F,25), V(E3,A8,A8,4B), \\\n    V(F3,51,51,A2), V(FE,A3,A3,5D), V(C0,40,40,80), V(8A,8F,8F,05), \\\n    V(AD,92,92,3F), V(BC,9D,9D,21), V(48,38,38,70), V(04,F5,F5,F1), \\\n    V(DF,BC,BC,63), V(C1,B6,B6,77), V(75,DA,DA,AF), V(63,21,21,42), \\\n    V(30,10,10,20), V(1A,FF,FF,E5), V(0E,F3,F3,FD), V(6D,D2,D2,BF), \\\n    V(4C,CD,CD,81), V(14,0C,0C,18), V(35,13,13,26), V(2F,EC,EC,C3), \\\n    V(E1,5F,5F,BE), V(A2,97,97,35), V(CC,44,44,88), V(39,17,17,2E), \\\n    V(57,C4,C4,93), V(F2,A7,A7,55), V(82,7E,7E,FC), V(47,3D,3D,7A), \\\n    V(AC,64,64,C8), V(E7,5D,5D,BA), V(2B,19,19,32), V(95,73,73,E6), \\\n    V(A0,60,60,C0), V(98,81,81,19), V(D1,4F,4F,9E), V(7F,DC,DC,A3), \\\n    V(66,22,22,44), V(7E,2A,2A,54), V(AB,90,90,3B), V(83,88,88,0B), \\\n    V(CA,46,46,8C), V(29,EE,EE,C7), V(D3,B8,B8,6B), V(3C,14,14,28), \\\n    V(79,DE,DE,A7), V(E2,5E,5E,BC), V(1D,0B,0B,16), V(76,DB,DB,AD), \\\n    V(3B,E0,E0,DB), V(56,32,32,64), V(4E,3A,3A,74), V(1E,0A,0A,14), \\\n    V(DB,49,49,92), V(0A,06,06,0C), V(6C,24,24,48), V(E4,5C,5C,B8), \\\n    V(5D,C2,C2,9F), V(6E,D3,D3,BD), V(EF,AC,AC,43), V(A6,62,62,C4), \\\n    V(A8,91,91,39), V(A4,95,95,31), V(37,E4,E4,D3), V(8B,79,79,F2), \\\n    V(32,E7,E7,D5), V(43,C8,C8,8B), V(59,37,37,6E), V(B7,6D,6D,DA), \\\n    V(8C,8D,8D,01), V(64,D5,D5,B1), V(D2,4E,4E,9C), V(E0,A9,A9,49), \\\n    V(B4,6C,6C,D8), V(FA,56,56,AC), V(07,F4,F4,F3), V(25,EA,EA,CF), \\\n    V(AF,65,65,CA), V(8E,7A,7A,F4), V(E9,AE,AE,47), V(18,08,08,10), \\\n    V(D5,BA,BA,6F), V(88,78,78,F0), V(6F,25,25,4A), V(72,2E,2E,5C), \\\n    V(24,1C,1C,38), V(F1,A6,A6,57), V(C7,B4,B4,73), V(51,C6,C6,97), \\\n    V(23,E8,E8,CB), V(7C,DD,DD,A1), V(9C,74,74,E8), V(21,1F,1F,3E), \\\n    V(DD,4B,4B,96), V(DC,BD,BD,61), V(86,8B,8B,0D), V(85,8A,8A,0F), \\\n    V(90,70,70,E0), V(42,3E,3E,7C), V(C4,B5,B5,71), V(AA,66,66,CC), \\\n    V(D8,48,48,90), V(05,03,03,06), V(01,F6,F6,F7), V(12,0E,0E,1C), \\\n    V(A3,61,61,C2), V(5F,35,35,6A), V(F9,57,57,AE), V(D0,B9,B9,69), \\\n    V(91,86,86,17), V(58,C1,C1,99), V(27,1D,1D,3A), V(B9,9E,9E,27), \\\n    V(38,E1,E1,D9), V(13,F8,F8,EB), V(B3,98,98,2B), V(33,11,11,22), \\\n    V(BB,69,69,D2), V(70,D9,D9,A9), V(89,8E,8E,07), V(A7,94,94,33), \\\n    V(B6,9B,9B,2D), V(22,1E,1E,3C), V(92,87,87,15), V(20,E9,E9,C9), \\\n    V(49,CE,CE,87), V(FF,55,55,AA), V(78,28,28,50), V(7A,DF,DF,A5), \\\n    V(8F,8C,8C,03), V(F8,A1,A1,59), V(80,89,89,09), V(17,0D,0D,1A), \\\n    V(DA,BF,BF,65), V(31,E6,E6,D7), V(C6,42,42,84), V(B8,68,68,D0), \\\n    V(C3,41,41,82), V(B0,99,99,29), V(77,2D,2D,5A), V(11,0F,0F,1E), \\\n    V(CB,B0,B0,7B), V(FC,54,54,A8), V(D6,BB,BB,6D), V(3A,16,16,2C)\n\n#define V(a,b,c,d) 0x##a##b##c##d\nstatic const uint32_t FT0[256] = { FT };\n#undef V\n\n#define V(a,b,c,d) 0x##b##c##d##a\nstatic const uint32_t FT1[256] = { FT };\n#undef V\n\n#define V(a,b,c,d) 0x##c##d##a##b\nstatic const uint32_t FT2[256] = { FT };\n#undef V\n\n#define V(a,b,c,d) 0x##d##a##b##c\nstatic const uint32_t FT3[256] = { FT };\n#undef V\n\n#undef FT\n\n/*\n * Reverse S-box\n */\nstatic const unsigned char RSb[256] =\n{\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,\n    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,\n    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,\n    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,\n    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,\n    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,\n    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,\n    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,\n    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,\n    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,\n    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,\n    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,\n    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,\n    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,\n    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,\n    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,\n    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n};\n\n/*\n * Reverse tables\n */\n#define RT \\\n\\\n    V(50,A7,F4,51), V(53,65,41,7E), V(C3,A4,17,1A), V(96,5E,27,3A), \\\n    V(CB,6B,AB,3B), V(F1,45,9D,1F), V(AB,58,FA,AC), V(93,03,E3,4B), \\\n    V(55,FA,30,20), V(F6,6D,76,AD), V(91,76,CC,88), V(25,4C,02,F5), \\\n    V(FC,D7,E5,4F), V(D7,CB,2A,C5), V(80,44,35,26), V(8F,A3,62,B5), \\\n    V(49,5A,B1,DE), V(67,1B,BA,25), V(98,0E,EA,45), V(E1,C0,FE,5D), \\\n    V(02,75,2F,C3), V(12,F0,4C,81), V(A3,97,46,8D), V(C6,F9,D3,6B), \\\n    V(E7,5F,8F,03), V(95,9C,92,15), V(EB,7A,6D,BF), V(DA,59,52,95), \\\n    V(2D,83,BE,D4), V(D3,21,74,58), V(29,69,E0,49), V(44,C8,C9,8E), \\\n    V(6A,89,C2,75), V(78,79,8E,F4), V(6B,3E,58,99), V(DD,71,B9,27), \\\n    V(B6,4F,E1,BE), V(17,AD,88,F0), V(66,AC,20,C9), V(B4,3A,CE,7D), \\\n    V(18,4A,DF,63), V(82,31,1A,E5), V(60,33,51,97), V(45,7F,53,62), \\\n    V(E0,77,64,B1), V(84,AE,6B,BB), V(1C,A0,81,FE), V(94,2B,08,F9), \\\n    V(58,68,48,70), V(19,FD,45,8F), V(87,6C,DE,94), V(B7,F8,7B,52), \\\n    V(23,D3,73,AB), V(E2,02,4B,72), V(57,8F,1F,E3), V(2A,AB,55,66), \\\n    V(07,28,EB,B2), V(03,C2,B5,2F), V(9A,7B,C5,86), V(A5,08,37,D3), \\\n    V(F2,87,28,30), V(B2,A5,BF,23), V(BA,6A,03,02), V(5C,82,16,ED), \\\n    V(2B,1C,CF,8A), V(92,B4,79,A7), V(F0,F2,07,F3), V(A1,E2,69,4E), \\\n    V(CD,F4,DA,65), V(D5,BE,05,06), V(1F,62,34,D1), V(8A,FE,A6,C4), \\\n    V(9D,53,2E,34), V(A0,55,F3,A2), V(32,E1,8A,05), V(75,EB,F6,A4), \\\n    V(39,EC,83,0B), V(AA,EF,60,40), V(06,9F,71,5E), V(51,10,6E,BD), \\\n    V(F9,8A,21,3E), V(3D,06,DD,96), V(AE,05,3E,DD), V(46,BD,E6,4D), \\\n    V(B5,8D,54,91), V(05,5D,C4,71), V(6F,D4,06,04), V(FF,15,50,60), \\\n    V(24,FB,98,19), V(97,E9,BD,D6), V(CC,43,40,89), V(77,9E,D9,67), \\\n    V(BD,42,E8,B0), V(88,8B,89,07), V(38,5B,19,E7), V(DB,EE,C8,79), \\\n    V(47,0A,7C,A1), V(E9,0F,42,7C), V(C9,1E,84,F8), V(00,00,00,00), \\\n    V(83,86,80,09), V(48,ED,2B,32), V(AC,70,11,1E), V(4E,72,5A,6C), \\\n    V(FB,FF,0E,FD), V(56,38,85,0F), V(1E,D5,AE,3D), V(27,39,2D,36), \\\n    V(64,D9,0F,0A), V(21,A6,5C,68), V(D1,54,5B,9B), V(3A,2E,36,24), \\\n    V(B1,67,0A,0C), V(0F,E7,57,93), V(D2,96,EE,B4), V(9E,91,9B,1B), \\\n    V(4F,C5,C0,80), V(A2,20,DC,61), V(69,4B,77,5A), V(16,1A,12,1C), \\\n    V(0A,BA,93,E2), V(E5,2A,A0,C0), V(43,E0,22,3C), V(1D,17,1B,12), \\\n    V(0B,0D,09,0E), V(AD,C7,8B,F2), V(B9,A8,B6,2D), V(C8,A9,1E,14), \\\n    V(85,19,F1,57), V(4C,07,75,AF), V(BB,DD,99,EE), V(FD,60,7F,A3), \\\n    V(9F,26,01,F7), V(BC,F5,72,5C), V(C5,3B,66,44), V(34,7E,FB,5B), \\\n    V(76,29,43,8B), V(DC,C6,23,CB), V(68,FC,ED,B6), V(63,F1,E4,B8), \\\n    V(CA,DC,31,D7), V(10,85,63,42), V(40,22,97,13), V(20,11,C6,84), \\\n    V(7D,24,4A,85), V(F8,3D,BB,D2), V(11,32,F9,AE), V(6D,A1,29,C7), \\\n    V(4B,2F,9E,1D), V(F3,30,B2,DC), V(EC,52,86,0D), V(D0,E3,C1,77), \\\n    V(6C,16,B3,2B), V(99,B9,70,A9), V(FA,48,94,11), V(22,64,E9,47), \\\n    V(C4,8C,FC,A8), V(1A,3F,F0,A0), V(D8,2C,7D,56), V(EF,90,33,22), \\\n    V(C7,4E,49,87), V(C1,D1,38,D9), V(FE,A2,CA,8C), V(36,0B,D4,98), \\\n    V(CF,81,F5,A6), V(28,DE,7A,A5), V(26,8E,B7,DA), V(A4,BF,AD,3F), \\\n    V(E4,9D,3A,2C), V(0D,92,78,50), V(9B,CC,5F,6A), V(62,46,7E,54), \\\n    V(C2,13,8D,F6), V(E8,B8,D8,90), V(5E,F7,39,2E), V(F5,AF,C3,82), \\\n    V(BE,80,5D,9F), V(7C,93,D0,69), V(A9,2D,D5,6F), V(B3,12,25,CF), \\\n    V(3B,99,AC,C8), V(A7,7D,18,10), V(6E,63,9C,E8), V(7B,BB,3B,DB), \\\n    V(09,78,26,CD), V(F4,18,59,6E), V(01,B7,9A,EC), V(A8,9A,4F,83), \\\n    V(65,6E,95,E6), V(7E,E6,FF,AA), V(08,CF,BC,21), V(E6,E8,15,EF), \\\n    V(D9,9B,E7,BA), V(CE,36,6F,4A), V(D4,09,9F,EA), V(D6,7C,B0,29), \\\n    V(AF,B2,A4,31), V(31,23,3F,2A), V(30,94,A5,C6), V(C0,66,A2,35), \\\n    V(37,BC,4E,74), V(A6,CA,82,FC), V(B0,D0,90,E0), V(15,D8,A7,33), \\\n    V(4A,98,04,F1), V(F7,DA,EC,41), V(0E,50,CD,7F), V(2F,F6,91,17), \\\n    V(8D,D6,4D,76), V(4D,B0,EF,43), V(54,4D,AA,CC), V(DF,04,96,E4), \\\n    V(E3,B5,D1,9E), V(1B,88,6A,4C), V(B8,1F,2C,C1), V(7F,51,65,46), \\\n    V(04,EA,5E,9D), V(5D,35,8C,01), V(73,74,87,FA), V(2E,41,0B,FB), \\\n    V(5A,1D,67,B3), V(52,D2,DB,92), V(33,56,10,E9), V(13,47,D6,6D), \\\n    V(8C,61,D7,9A), V(7A,0C,A1,37), V(8E,14,F8,59), V(89,3C,13,EB), \\\n    V(EE,27,A9,CE), V(35,C9,61,B7), V(ED,E5,1C,E1), V(3C,B1,47,7A), \\\n    V(59,DF,D2,9C), V(3F,73,F2,55), V(79,CE,14,18), V(BF,37,C7,73), \\\n    V(EA,CD,F7,53), V(5B,AA,FD,5F), V(14,6F,3D,DF), V(86,DB,44,78), \\\n    V(81,F3,AF,CA), V(3E,C4,68,B9), V(2C,34,24,38), V(5F,40,A3,C2), \\\n    V(72,C3,1D,16), V(0C,25,E2,BC), V(8B,49,3C,28), V(41,95,0D,FF), \\\n    V(71,01,A8,39), V(DE,B3,0C,08), V(9C,E4,B4,D8), V(90,C1,56,64), \\\n    V(61,84,CB,7B), V(70,B6,32,D5), V(74,5C,6C,48), V(42,57,B8,D0)\n\n#define V(a,b,c,d) 0x##a##b##c##d\nstatic const uint32_t RT0[256] = { RT };\n#undef V\n\n#define V(a,b,c,d) 0x##b##c##d##a\nstatic const uint32_t RT1[256] = { RT };\n#undef V\n\n#define V(a,b,c,d) 0x##c##d##a##b\nstatic const uint32_t RT2[256] = { RT };\n#undef V\n\n#define V(a,b,c,d) 0x##d##a##b##c\nstatic const uint32_t RT3[256] = { RT };\n#undef V\n\n#undef RT\n\n/*\n * Round constants\n */\nstatic const uint32_t RCON[10] =\n{\n    0x00000001, 0x00000002, 0x00000004, 0x00000008,\n    0x00000010, 0x00000020, 0x00000040, 0x00000080,\n    0x0000001B, 0x00000036\n};\n\n#else /* MBEDTLS_AES_ROM_TABLES */\n\n/*\n * Forward S-box & tables\n */\nstatic unsigned char FSb[256];\nstatic uint32_t FT0[256];\nstatic uint32_t FT1[256];\nstatic uint32_t FT2[256];\nstatic uint32_t FT3[256];\n\n/*\n * Reverse S-box & tables\n */\nstatic unsigned char RSb[256];\nstatic uint32_t RT0[256];\nstatic uint32_t RT1[256];\nstatic uint32_t RT2[256];\nstatic uint32_t RT3[256];\n\n/*\n * Round constants\n */\nstatic uint32_t RCON[10];\n\n/*\n * Tables generation code\n */\n#define ROTL8(x) ( ( x << 8 ) & 0xFFFFFFFF ) | ( x >> 24 )\n#define XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )\n#define MUL(x,y) ( ( x && y ) ? pow[(log[x]+log[y]) % 255] : 0 )\n\nstatic int aes_init_done = 0;\n\nstatic void aes_gen_tables( void )\n{\n    int i, x, y, z;\n    int pow[256];\n    int log[256];\n\n    /*\n     * compute pow and log tables over GF(2^8)\n     */\n    for( i = 0, x = 1; i < 256; i++ )\n    {\n        pow[i] = x;\n        log[x] = i;\n        x = ( x ^ XTIME( x ) ) & 0xFF;\n    }\n\n    /*\n     * calculate the round constants\n     */\n    for( i = 0, x = 1; i < 10; i++ )\n    {\n        RCON[i] = (uint32_t) x;\n        x = XTIME( x ) & 0xFF;\n    }\n\n    /*\n     * generate the forward and reverse S-boxes\n     */\n    FSb[0x00] = 0x63;\n    RSb[0x63] = 0x00;\n\n    for( i = 1; i < 256; i++ )\n    {\n        x = pow[255 - log[i]];\n\n        y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;\n        x ^= y ^ 0x63;\n\n        FSb[i] = (unsigned char) x;\n        RSb[x] = (unsigned char) i;\n    }\n\n    /*\n     * generate the forward and reverse tables\n     */\n    for( i = 0; i < 256; i++ )\n    {\n        x = FSb[i];\n        y = XTIME( x ) & 0xFF;\n        z =  ( y ^ x ) & 0xFF;\n\n        FT0[i] = ( (uint32_t) y       ) ^\n                 ( (uint32_t) x <<  8 ) ^\n                 ( (uint32_t) x << 16 ) ^\n                 ( (uint32_t) z << 24 );\n\n        FT1[i] = ROTL8( FT0[i] );\n        FT2[i] = ROTL8( FT1[i] );\n        FT3[i] = ROTL8( FT2[i] );\n\n        x = RSb[i];\n\n        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^\n                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^\n                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^\n                 ( (uint32_t) MUL( 0x0B, x ) << 24 );\n\n        RT1[i] = ROTL8( RT0[i] );\n        RT2[i] = ROTL8( RT1[i] );\n        RT3[i] = ROTL8( RT2[i] );\n    }\n}\n\n#endif /* MBEDTLS_AES_ROM_TABLES */\n\nvoid mbedtls_aes_init( mbedtls_aes_context *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_aes_context ) );\n}\n\nvoid mbedtls_aes_free( mbedtls_aes_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    mbedtls_zeroize( ctx, sizeof( mbedtls_aes_context ) );\n}\n\n/*\n * AES key schedule (encryption)\n */\n#if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)\nint mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    unsigned int i;\n    uint32_t *RK;\n\n#if !defined(MBEDTLS_AES_ROM_TABLES)\n    if( aes_init_done == 0 )\n    {\n        aes_gen_tables();\n        aes_init_done = 1;\n\n    }\n#endif\n\n    switch( keybits )\n    {\n        case 128: ctx->nr = 10; break;\n        case 192: ctx->nr = 12; break;\n        case 256: ctx->nr = 14; break;\n        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );\n    else\n#endif\n    ctx->rk = RK = ctx->buf;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );\n#endif\n\n    for( i = 0; i < ( keybits >> 5 ); i++ )\n    {\n        GET_UINT32_LE( RK[i], key, i << 2 );\n    }\n\n    switch( ctx->nr )\n    {\n        case 10:\n\n            for( i = 0; i < 10; i++, RK += 4 )\n            {\n                RK[4]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );\n\n                RK[5]  = RK[1] ^ RK[4];\n                RK[6]  = RK[2] ^ RK[5];\n                RK[7]  = RK[3] ^ RK[6];\n            }\n            break;\n\n        case 12:\n\n            for( i = 0; i < 8; i++, RK += 6 )\n            {\n                RK[6]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );\n\n                RK[7]  = RK[1] ^ RK[6];\n                RK[8]  = RK[2] ^ RK[7];\n                RK[9]  = RK[3] ^ RK[8];\n                RK[10] = RK[4] ^ RK[9];\n                RK[11] = RK[5] ^ RK[10];\n            }\n            break;\n\n        case 14:\n\n            for( i = 0; i < 7; i++, RK += 8 )\n            {\n                RK[8]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );\n\n                RK[9]  = RK[1] ^ RK[8];\n                RK[10] = RK[2] ^ RK[9];\n                RK[11] = RK[3] ^ RK[10];\n\n                RK[12] = RK[4] ^\n                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^\n                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^\n                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );\n\n                RK[13] = RK[5] ^ RK[12];\n                RK[14] = RK[6] ^ RK[13];\n                RK[15] = RK[7] ^ RK[14];\n            }\n            break;\n    }\n\n    return( 0 );\n}\n#endif /* !MBEDTLS_AES_SETKEY_ENC_ALT */\n\n/*\n * AES key schedule (decryption)\n */\n#if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)\nint mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    int i, j, ret;\n    mbedtls_aes_context cty;\n    uint32_t *RK;\n    uint32_t *SK;\n\n    mbedtls_aes_init( &cty );\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );\n    else\n#endif\n    ctx->rk = RK = ctx->buf;\n\n    /* Also checks keybits */\n    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )\n        goto exit;\n\n    ctx->nr = cty.nr;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n    {\n        mbedtls_aesni_inverse_key( (unsigned char *) ctx->rk,\n                           (const unsigned char *) cty.rk, ctx->nr );\n        goto exit;\n    }\n#endif\n\n    SK = cty.rk + cty.nr * 4;\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\n    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )\n    {\n        for( j = 0; j < 4; j++, SK++ )\n        {\n            *RK++ = RT0[ FSb[ ( *SK       ) & 0xFF ] ] ^\n                    RT1[ FSb[ ( *SK >>  8 ) & 0xFF ] ] ^\n                    RT2[ FSb[ ( *SK >> 16 ) & 0xFF ] ] ^\n                    RT3[ FSb[ ( *SK >> 24 ) & 0xFF ] ];\n        }\n    }\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\nexit:\n    mbedtls_aes_free( &cty );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_AES_SETKEY_DEC_ALT */\n\n#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \\\n{                                               \\\n    X0 = *RK++ ^ FT0[ ( Y0       ) & 0xFF ] ^   \\\n                 FT1[ ( Y1 >>  8 ) & 0xFF ] ^   \\\n                 FT2[ ( Y2 >> 16 ) & 0xFF ] ^   \\\n                 FT3[ ( Y3 >> 24 ) & 0xFF ];    \\\n                                                \\\n    X1 = *RK++ ^ FT0[ ( Y1       ) & 0xFF ] ^   \\\n                 FT1[ ( Y2 >>  8 ) & 0xFF ] ^   \\\n                 FT2[ ( Y3 >> 16 ) & 0xFF ] ^   \\\n                 FT3[ ( Y0 >> 24 ) & 0xFF ];    \\\n                                                \\\n    X2 = *RK++ ^ FT0[ ( Y2       ) & 0xFF ] ^   \\\n                 FT1[ ( Y3 >>  8 ) & 0xFF ] ^   \\\n                 FT2[ ( Y0 >> 16 ) & 0xFF ] ^   \\\n                 FT3[ ( Y1 >> 24 ) & 0xFF ];    \\\n                                                \\\n    X3 = *RK++ ^ FT0[ ( Y3       ) & 0xFF ] ^   \\\n                 FT1[ ( Y0 >>  8 ) & 0xFF ] ^   \\\n                 FT2[ ( Y1 >> 16 ) & 0xFF ] ^   \\\n                 FT3[ ( Y2 >> 24 ) & 0xFF ];    \\\n}\n\n#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \\\n{                                               \\\n    X0 = *RK++ ^ RT0[ ( Y0       ) & 0xFF ] ^   \\\n                 RT1[ ( Y3 >>  8 ) & 0xFF ] ^   \\\n                 RT2[ ( Y2 >> 16 ) & 0xFF ] ^   \\\n                 RT3[ ( Y1 >> 24 ) & 0xFF ];    \\\n                                                \\\n    X1 = *RK++ ^ RT0[ ( Y1       ) & 0xFF ] ^   \\\n                 RT1[ ( Y0 >>  8 ) & 0xFF ] ^   \\\n                 RT2[ ( Y3 >> 16 ) & 0xFF ] ^   \\\n                 RT3[ ( Y2 >> 24 ) & 0xFF ];    \\\n                                                \\\n    X2 = *RK++ ^ RT0[ ( Y2       ) & 0xFF ] ^   \\\n                 RT1[ ( Y1 >>  8 ) & 0xFF ] ^   \\\n                 RT2[ ( Y0 >> 16 ) & 0xFF ] ^   \\\n                 RT3[ ( Y3 >> 24 ) & 0xFF ];    \\\n                                                \\\n    X3 = *RK++ ^ RT0[ ( Y3       ) & 0xFF ] ^   \\\n                 RT1[ ( Y2 >>  8 ) & 0xFF ] ^   \\\n                 RT2[ ( Y1 >> 16 ) & 0xFF ] ^   \\\n                 RT3[ ( Y0 >> 24 ) & 0xFF ];    \\\n}\n\n/*\n * AES-ECB block encryption\n */\n#if !defined(MBEDTLS_AES_ENCRYPT_ALT)\nint mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,\n                                  const unsigned char input[16],\n                                  unsigned char output[16] )\n{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n    RK = ctx->rk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )\n    {\n        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n    }\n\n    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n    X0 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );\n\n    X1 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );\n\n    X2 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );\n\n    X3 = *RK++ ^ \\\n            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^\n            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    return( 0 );\n}\n#endif /* !MBEDTLS_AES_ENCRYPT_ALT */\n\nvoid mbedtls_aes_encrypt( mbedtls_aes_context *ctx,\n                          const unsigned char input[16],\n                          unsigned char output[16] )\n{\n    mbedtls_internal_aes_encrypt( ctx, input, output );\n}\n\n/*\n * AES-ECB block decryption\n */\n#if !defined(MBEDTLS_AES_DECRYPT_ALT)\nint mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,\n                                  const unsigned char input[16],\n                                  unsigned char output[16] )\n{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n    RK = ctx->rk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )\n    {\n        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n    }\n\n    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n    X0 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );\n\n    X1 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );\n\n    X2 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );\n\n    X3 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^\n            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^\n            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    return( 0 );\n}\n#endif /* !MBEDTLS_AES_DECRYPT_ALT */\n\nvoid mbedtls_aes_decrypt( mbedtls_aes_context *ctx,\n                          const unsigned char input[16],\n                          unsigned char output[16] )\n{\n    mbedtls_internal_aes_decrypt( ctx, input, output );\n}\n\n/*\n * AES-ECB block encryption/decryption\n */\nint mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,\n                    int mode,\n                    const unsigned char input[16],\n                    unsigned char output[16] )\n{\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( mbedtls_padlock_xcryptecb( ctx, mode, input, output ) == 0 )\n            return( 0 );\n\n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    if( mode == MBEDTLS_AES_ENCRYPT )\n        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );\n    else\n        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n/*\n * AES-CBC buffer encryption/decryption\n */\nint mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx,\n                    int mode,\n                    size_t length,\n                    unsigned char iv[16],\n                    const unsigned char *input,\n                    unsigned char *output )\n{\n    int i;\n    unsigned char temp[16];\n\n    if( length % 16 )\n        return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );\n\n#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( mbedtls_padlock_xcryptcbc( ctx, mode, length, iv, input, output ) == 0 )\n            return( 0 );\n\n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    if( mode == MBEDTLS_AES_DECRYPT )\n    {\n        while( length > 0 )\n        {\n            memcpy( temp, input, 16 );\n            mbedtls_aes_crypt_ecb( ctx, mode, input, output );\n\n            for( i = 0; i < 16; i++ )\n                output[i] = (unsigned char)( output[i] ^ iv[i] );\n\n            memcpy( iv, temp, 16 );\n\n            input  += 16;\n            output += 16;\n            length -= 16;\n        }\n    }\n    else\n    {\n        while( length > 0 )\n        {\n            for( i = 0; i < 16; i++ )\n                output[i] = (unsigned char)( input[i] ^ iv[i] );\n\n            mbedtls_aes_crypt_ecb( ctx, mode, output, output );\n            memcpy( iv, output, 16 );\n\n            input  += 16;\n            output += 16;\n            length -= 16;\n        }\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n/*\n * AES-CFB128 buffer encryption/decryption\n */\nint mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       size_t *iv_off,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    int c;\n    size_t n = *iv_off;\n\n    if( mode == MBEDTLS_AES_DECRYPT )\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );\n\n            c = *input++;\n            *output++ = (unsigned char)( c ^ iv[n] );\n            iv[n] = (unsigned char) c;\n\n            n = ( n + 1 ) & 0x0F;\n        }\n    }\n    else\n    {\n        while( length-- )\n        {\n            if( n == 0 )\n                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );\n\n            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );\n\n            n = ( n + 1 ) & 0x0F;\n        }\n    }\n\n    *iv_off = n;\n\n    return( 0 );\n}\n\n/*\n * AES-CFB8 buffer encryption/decryption\n */\nint mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    unsigned char c;\n    unsigned char ov[17];\n\n    while( length-- )\n    {\n        memcpy( ov, iv, 16 );\n        mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n            ov[16] = *input;\n\n        c = *output++ = (unsigned char)( iv[0] ^ *input++ );\n\n        if( mode == MBEDTLS_AES_ENCRYPT )\n            ov[16] = c;\n\n        memcpy( iv, ov + 1, 16 );\n    }\n\n    return( 0 );\n}\n#endif /*MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n/*\n * AES-CTR buffer encryption/decryption\n */\nint mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,\n                       size_t length,\n                       size_t *nc_off,\n                       unsigned char nonce_counter[16],\n                       unsigned char stream_block[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    int c, i;\n    size_t n = *nc_off;\n\n    while( length-- )\n    {\n        if( n == 0 ) {\n            mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block );\n\n            for( i = 16; i > 0; i-- )\n                if( ++nonce_counter[i - 1] != 0 )\n                    break;\n        }\n        c = *input++;\n        *output++ = (unsigned char)( c ^ stream_block[n] );\n\n        n = ( n + 1 ) & 0x0F;\n    }\n\n    *nc_off = n;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#endif /* !MBEDTLS_AES_ALT */\n\n#if defined(MBEDTLS_SELF_TEST)\n/*\n * AES test vectors from:\n *\n * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip\n */\nstatic const unsigned char aes_test_ecb_dec[3][16] =\n{\n    { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,\n      0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },\n    { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,\n      0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },\n    { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,\n      0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }\n};\n\nstatic const unsigned char aes_test_ecb_enc[3][16] =\n{\n    { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,\n      0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },\n    { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,\n      0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },\n    { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,\n      0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const unsigned char aes_test_cbc_dec[3][16] =\n{\n    { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,\n      0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },\n    { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,\n      0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },\n    { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,\n      0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }\n};\n\nstatic const unsigned char aes_test_cbc_enc[3][16] =\n{\n    { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,\n      0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },\n    { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,\n      0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },\n    { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,\n      0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n/*\n * AES-CFB128 test vectors from:\n *\n * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf\n */\nstatic const unsigned char aes_test_cfb128_key[3][32] =\n{\n    { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,\n      0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },\n    { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,\n      0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,\n      0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },\n    { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,\n      0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,\n      0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,\n      0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }\n};\n\nstatic const unsigned char aes_test_cfb128_iv[16] =\n{\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F\n};\n\nstatic const unsigned char aes_test_cfb128_pt[64] =\n{\n    0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,\n    0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,\n    0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,\n    0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,\n    0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,\n    0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,\n    0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,\n    0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10\n};\n\nstatic const unsigned char aes_test_cfb128_ct[3][64] =\n{\n    { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,\n      0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,\n      0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,\n      0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,\n      0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,\n      0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,\n      0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,\n      0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6 },\n    { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,\n      0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,\n      0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,\n      0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,\n      0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,\n      0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,\n      0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,\n      0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF },\n    { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,\n      0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,\n      0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,\n      0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,\n      0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,\n      0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,\n      0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,\n      0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71 }\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n/*\n * AES-CTR test vectors from:\n *\n * http://www.faqs.org/rfcs/rfc3686.html\n */\n\nstatic const unsigned char aes_test_ctr_key[3][16] =\n{\n    { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,\n      0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },\n    { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,\n      0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },\n    { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,\n      0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }\n};\n\nstatic const unsigned char aes_test_ctr_nonce_counter[3][16] =\n{\n    { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },\n    { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,\n      0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },\n    { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,\n      0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }\n};\n\nstatic const unsigned char aes_test_ctr_pt[3][48] =\n{\n    { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,\n      0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },\n\n    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },\n\n    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n      0x20, 0x21, 0x22, 0x23 }\n};\n\nstatic const unsigned char aes_test_ctr_ct[3][48] =\n{\n    { 0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,\n      0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8 },\n    { 0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,\n      0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,\n      0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,\n      0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28 },\n    { 0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,\n      0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,\n      0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,\n      0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,\n      0x25, 0xB2, 0x07, 0x2F }\n};\n\nstatic const int aes_test_ctr_len[3] =\n    { 16, 32, 36 };\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n/*\n * Checkup routine\n */\nint mbedtls_aes_self_test( int verbose )\n{\n    int ret = 0, i, j, u, mode;\n    unsigned int keybits;\n    unsigned char key[32];\n    unsigned char buf[64];\n    const unsigned char *aes_tests;\n#if defined(MBEDTLS_CIPHER_MODE_CBC) || defined(MBEDTLS_CIPHER_MODE_CFB)\n    unsigned char iv[16];\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    unsigned char prv[16];\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_CFB)\n    size_t offset;\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    int len;\n    unsigned char nonce_counter[16];\n    unsigned char stream_block[16];\n#endif\n    mbedtls_aes_context ctx;\n\n    memset( key, 0, 32 );\n    mbedtls_aes_init( &ctx );\n\n    /*\n     * ECB mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        keybits = 128 + u * 64;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-ECB-%3d (%s): \", keybits,\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memset( buf, 0, 16 );\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );\n            aes_tests = aes_test_ecb_dec[u];\n        }\n        else\n        {\n            ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );\n            aes_tests = aes_test_ecb_enc[u];\n        }\n\n        /*\n         * AES-192 is an optional feature that may be unavailable when\n         * there is an alternative underlying implementation i.e. when\n         * MBEDTLS_AES_ALT is defined.\n         */\n        if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )\n        {\n            mbedtls_printf( \"skipped\\n\" );\n            continue;\n        }\n        else if( ret != 0 )\n        {\n            goto exit;\n        }\n\n        for( j = 0; j < 10000; j++ )\n        {\n            ret = mbedtls_aes_crypt_ecb( &ctx, mode, buf, buf );\n            if( ret != 0 )\n                goto exit;\n        }\n\n        if( memcmp( buf, aes_tests, 16 ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    /*\n     * CBC mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        keybits = 128 + u * 64;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-CBC-%3d (%s): \", keybits,\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memset( iv , 0, 16 );\n        memset( prv, 0, 16 );\n        memset( buf, 0, 16 );\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );\n            aes_tests = aes_test_cbc_dec[u];\n        }\n        else\n        {\n            ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );\n            aes_tests = aes_test_cbc_enc[u];\n        }\n\n        /*\n         * AES-192 is an optional feature that may be unavailable when\n         * there is an alternative underlying implementation i.e. when\n         * MBEDTLS_AES_ALT is defined.\n         */\n        if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )\n        {\n            mbedtls_printf( \"skipped\\n\" );\n            continue;\n        }\n        else if( ret != 0 )\n        {\n            goto exit;\n        }\n\n        for( j = 0; j < 10000; j++ )\n        {\n            if( mode == MBEDTLS_AES_ENCRYPT )\n            {\n                unsigned char tmp[16];\n\n                memcpy( tmp, prv, 16 );\n                memcpy( prv, buf, 16 );\n                memcpy( buf, tmp, 16 );\n            }\n\n            ret = mbedtls_aes_crypt_cbc( &ctx, mode, 16, iv, buf, buf );\n            if( ret != 0 )\n                goto exit;\n\n        }\n\n        if( memcmp( buf, aes_tests, 16 ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    /*\n     * CFB128 mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        keybits = 128 + u * 64;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-CFB128-%3d (%s): \", keybits,\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memcpy( iv,  aes_test_cfb128_iv, 16 );\n        memcpy( key, aes_test_cfb128_key[u], keybits / 8 );\n\n        offset = 0;\n        ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );\n        /*\n         * AES-192 is an optional feature that may be unavailable when\n         * there is an alternative underlying implementation i.e. when\n         * MBEDTLS_AES_ALT is defined.\n         */\n        if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )\n        {\n            mbedtls_printf( \"skipped\\n\" );\n            continue;\n        }\n        else if( ret != 0 )\n        {\n            goto exit;\n        }\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            memcpy( buf, aes_test_cfb128_ct[u], 64 );\n            aes_tests = aes_test_cfb128_pt;\n        }\n        else\n        {\n            memcpy( buf, aes_test_cfb128_pt, 64 );\n            aes_tests = aes_test_cfb128_ct[u];\n        }\n\n        ret = mbedtls_aes_crypt_cfb128( &ctx, mode, 64, &offset, iv, buf, buf );\n        if( ret != 0 )\n            goto exit;\n\n        if( memcmp( buf, aes_tests, 64 ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    /*\n     * CTR mode\n     */\n    for( i = 0; i < 6; i++ )\n    {\n        u = i >> 1;\n        mode = i & 1;\n\n        if( verbose != 0 )\n            mbedtls_printf( \"  AES-CTR-128 (%s): \",\n                            ( mode == MBEDTLS_AES_DECRYPT ) ? \"dec\" : \"enc\" );\n\n        memcpy( nonce_counter, aes_test_ctr_nonce_counter[u], 16 );\n        memcpy( key, aes_test_ctr_key[u], 16 );\n\n        offset = 0;\n        if( ( ret = mbedtls_aes_setkey_enc( &ctx, key, 128 ) ) != 0 )\n            goto exit;\n\n        len = aes_test_ctr_len[u];\n\n        if( mode == MBEDTLS_AES_DECRYPT )\n        {\n            memcpy( buf, aes_test_ctr_ct[u], len );\n            aes_tests = aes_test_ctr_pt[u];\n        }\n        else\n        {\n            memcpy( buf, aes_test_ctr_pt[u], len );\n            aes_tests = aes_test_ctr_ct[u];\n        }\n\n        ret = mbedtls_aes_crypt_ctr( &ctx, len, &offset, nonce_counter,\n                                     stream_block, buf, buf );\n        if( ret != 0 )\n            goto exit;\n\n        if( memcmp( buf, aes_tests, len ) != 0 )\n        {\n            ret = 1;\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n    ret = 0;\n\nexit:\n    if( ret != 0 && verbose != 0 )\n        mbedtls_printf( \"failed\\n\" );\n\n    mbedtls_aes_free( &ctx );\n\n    return( ret );\n}\n\n#endif /* MBEDTLS_SELF_TEST */\n\n#endif /* MBEDTLS_AES_C */\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n#include \"lorawan/lorastack/phy/LoRaPHY.h\"\n\n#define tr_debug(...) printf(\"[LPHY][DBG] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_info(...)  printf(\"[LPHY][INF] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_error(...) printf(\"[LPHY][ERR] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_warn(...) printf(\"[LPHY][WRN] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n\n#define BACKOFF_DC_1_HOUR       100\n#define BACKOFF_DC_10_HOURS     1000\n#define BACKOFF_DC_24_HOURS     10000\n\n#define CHANNELS_IN_MASK  16\n\nLoRaPHY::LoRaPHY(LoRaWANTimeHandler &lora_time)\n    : _radio(NULL),\n      _lora_time(lora_time)\n{\n    memset(&phy_params, 0, sizeof(phy_params));\n}\n\nLoRaPHY::~LoRaPHY()\n{\n    _radio = NULL;\n}\n\nbool LoRaPHY::mask_bit_test(const uint16_t *mask, unsigned bit) {\n    return mask[bit/16] & (1U << (bit % 16));\n}\n\nvoid LoRaPHY::mask_bit_set(uint16_t *mask, unsigned bit) {\n    mask[bit/16] |= (1U << (bit % 16));\n}\n\nvoid LoRaPHY::mask_bit_clear(uint16_t *mask, unsigned bit) {\n    mask[bit/16] &= ~(1U << (bit % 16));\n}\n\nvoid LoRaPHY::set_radio_instance(LoRaRadio& radio)\n{\n    _radio = &radio;\n}\n\nvoid LoRaPHY::put_radio_to_sleep() {\n    _radio->lock();\n    _radio->sleep();\n    _radio->unlock();\n}\n\nvoid LoRaPHY::put_radio_to_standby() {\n    _radio->lock();\n    _radio->standby();\n    _radio->unlock();\n}\n\nvoid LoRaPHY::setup_public_network_mode(bool set)\n{\n    _radio->lock();\n    _radio->set_public_network(set);\n    _radio->unlock();\n}\n\nvoid LoRaPHY::setup_rx_window(bool rx_continuous, uint32_t max_rx_window)\n{\n    _radio->lock();\n    if (!rx_continuous) {\n        _radio->receive(max_rx_window);\n    } else {\n        _radio->receive(0); // Continuous mode\n    }\n    _radio->unlock();\n}\n\n// For DevNonce for example\nuint32_t LoRaPHY::get_radio_rng()\n{\n    uint32_t rand;\n\n    _radio->lock();\n    rand =_radio->random();\n    _radio->unlock();\n\n    return rand;\n}\n\nvoid LoRaPHY::handle_send(uint8_t *buf, uint8_t size)\n{\n    tr_info(\"handle_send (size=%u)\", size);\n    _radio->lock();\n    _radio->send(buf, size);\n    _radio->unlock();\n}\n\nuint8_t LoRaPHY::request_new_channel(new_channel_req_params_t* params)\n{\n    if (!phy_params.custom_channelplans_supported) {\n        return 0;\n    }\n\n    uint8_t status = 0x03;\n\n    if (params->new_channel->frequency == 0) {\n        // Remove\n        if (remove_channel(params->channel_id) == false) {\n            status &= 0xFC;\n        }\n    } else {\n\n        switch (add_channel(params->new_channel, params->channel_id)) {\n            case LORAWAN_STATUS_OK:\n            {\n                break;\n            }\n            case LORAWAN_STATUS_FREQUENCY_INVALID:\n            {\n                status &= 0xFE;\n                break;\n            }\n            case LORAWAN_STATUS_DATARATE_INVALID:\n            {\n                status &= 0xFD;\n                break;\n            }\n            case LORAWAN_STATUS_FREQ_AND_DR_INVALID:\n            {\n                status &= 0xFC;\n                break;\n            }\n            default:\n            {\n                status &= 0xFC;\n                break;\n            }\n        }\n    }\n\n    return status;\n}\n\nint32_t LoRaPHY::get_random(int32_t min, int32_t max)\n{\n    return (int32_t) rand() % (max - min + 1) + min;\n}\n\nbool LoRaPHY::verify_channel_DR(uint8_t nb_channels, uint16_t* channel_mask,\n                                int8_t dr, int8_t min_dr, int8_t max_dr,\n                                channel_params_t* channels)\n{\n    if (val_in_range(dr, min_dr, max_dr) == 0) {\n        return false;\n    }\n\n    for (uint8_t i = 0; i < phy_params.max_channel_cnt; i++) {\n        if (mask_bit_test(channel_mask, i)) {\n            // Check datarate validity for enabled channels\n            if (val_in_range(dr, (channels[i].dr_range.fields.min & 0x0F),\n                                 (channels[i].dr_range.fields.max & 0x0F))) {\n                // At least 1 channel has been found we can return OK.\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nuint8_t LoRaPHY::val_in_range( int8_t value, int8_t min, int8_t max )\n{\n    if ((value >= min) && (value <= max)) {\n        return 1;\n    }\n\n    return 0;\n}\n\nbool LoRaPHY::disable_channel(uint16_t* channel_mask, uint8_t id,\n                              uint8_t max_channels_num)\n{\n    uint8_t index = id / 16;\n\n    if ((index > phy_params.channels.mask_size) || (id >= max_channels_num)) {\n        return false;\n    }\n\n    // Deactivate channel\n    mask_bit_clear(channel_mask, id);\n\n    return true;\n}\n\nuint8_t LoRaPHY::count_bits(uint16_t mask, uint8_t nbBits)\n{\n    uint8_t nbActiveBits = 0;\n\n    for(uint8_t j = 0; j < nbBits; j++) {\n        if (mask_bit_test(&mask, j)) {\n            nbActiveBits++;\n        }\n    }\n\n    return nbActiveBits;\n}\n\nuint8_t LoRaPHY::num_active_channels(uint16_t* channel_mask, uint8_t start_idx,\n                                     uint8_t stop_idx)\n{\n    uint8_t nb_channels = 0;\n\n    if (channel_mask == NULL) {\n        return 0;\n    }\n\n    for (uint8_t i = start_idx; i < stop_idx; i++) {\n        nb_channels += count_bits(channel_mask[i], 16);\n    }\n\n    return nb_channels;\n}\n\nvoid LoRaPHY::copy_channel_mask(uint16_t* dest_mask, uint16_t* src_mask, uint8_t len)\n{\n    if ((dest_mask != NULL) && (src_mask != NULL)) {\n        for( uint8_t i = 0; i < len; i++ ) {\n            dest_mask[i] = src_mask[i];\n        }\n    }\n}\n\nvoid LoRaPHY::set_last_tx_done(set_band_txdone_params_t* last_tx_params)\n{\n    if (!last_tx_params) {\n        return;\n    }\n\n    band_t *band_table = (band_t *) phy_params.bands.table;\n    channel_params_t *channel_list = phy_params.channels.channel_list;\n\n    if (last_tx_params->joined == true) {\n        band_table[channel_list[last_tx_params->channel].band].last_tx_time = last_tx_params->last_tx_done_time;\n        return;\n    }\n\n    band_table[channel_list[last_tx_params->channel].band].last_tx_time = last_tx_params->last_tx_done_time;\n    band_table[channel_list[last_tx_params->channel].band].last_join_tx_time = last_tx_params->last_tx_done_time;\n\n}\n\nlorawan_time_t LoRaPHY::update_band_timeoff(bool joined, bool duty_cycle,\n                                            band_t* bands, uint8_t nb_bands)\n{\n    lorawan_time_t next_tx_delay = (lorawan_time_t) (-1);\n\n    // Update bands Time OFF\n    for (uint8_t i = 0; i < nb_bands; i++) {\n\n        if (joined == false) {\n            uint32_t txDoneTime =  MAX(_lora_time.get_elapsed_time(bands[i].last_join_tx_time),\n                                        (duty_cycle == true) ?\n                                        _lora_time.get_elapsed_time(bands[i].last_tx_time) : 0);\n\n            if (bands[i].off_time <= txDoneTime) {\n                bands[i].off_time = 0;\n            }\n\n            if (bands[i].off_time != 0) {\n                next_tx_delay = MIN( bands[i].off_time - txDoneTime, next_tx_delay );\n            }\n\n        } else {\n            // if network has been joined\n            if (duty_cycle == true) {\n\n                if( bands[i].off_time <= _lora_time.get_elapsed_time(bands[i].last_tx_time)) {\n                    bands[i].off_time = 0;\n                }\n\n                if(bands[i].off_time != 0 ) {\n                    next_tx_delay = MIN(bands[i].off_time - _lora_time.get_elapsed_time(bands[i].last_tx_time),\n                                       next_tx_delay);\n                }\n            } else {\n                // if duty cycle is not on\n                next_tx_delay = 0;\n                bands[i].off_time = 0;\n            }\n        }\n    }\n\n    return next_tx_delay;\n}\n\nuint8_t LoRaPHY::parse_link_ADR_req(uint8_t* payload, link_adr_params_t* params)\n{\n    uint8_t ret_index = 0;\n\n    if (payload[0] == SRV_MAC_LINK_ADR_REQ) {\n\n        // Parse datarate and tx power\n        params->datarate = payload[1];\n        params->tx_power = params->datarate & 0x0F;\n        params->datarate = (params->datarate >> 4) & 0x0F;\n\n        // Parse ChMask\n        params->channel_mask = (uint16_t) payload[2];\n        params->channel_mask |= (uint16_t) payload[3] << 8;\n\n        // Parse ChMaskCtrl and nbRep\n        params->nb_rep = payload[4];\n        params->ch_mask_ctrl = ( params->nb_rep >> 4 ) & 0x07;\n        params->nb_rep &= 0x0F;\n\n        // LinkAdrReq has 4 bytes length + 1 byte CMD\n        ret_index = 5;\n    }\n\n    return ret_index;\n}\n\nuint8_t LoRaPHY::verify_link_ADR_req(verify_adr_params_t* verify_params,\n                                     int8_t* dr, int8_t* tx_pow, uint8_t* nb_rep)\n{\n    uint8_t status = verify_params->status;\n    int8_t datarate = verify_params->datarate;\n    int8_t tx_power = verify_params->tx_power;\n    int8_t nb_repetitions = verify_params->nb_rep;\n\n    // Handle the case when ADR is off.\n    if (verify_params->adr_enabled == false) {\n        // When ADR is off, we are allowed to change the channels mask and the NbRep,\n        // if the datarate and the TX power of the LinkAdrReq are set to 0x0F.\n        if ((verify_params->datarate != 0x0F) || (verify_params->tx_power != 0x0F)) {\n            status = 0;\n            nb_repetitions = verify_params->current_nb_rep;\n        }\n\n        // Get the current datarate and tx power\n        datarate = verify_params->current_datarate;\n        tx_power = verify_params->current_tx_power;\n    }\n\n    if (status != 0) {\n        // Verify channel datarate\n        if (verify_channel_DR(phy_params.max_channel_cnt, verify_params->channel_mask,\n                              datarate, phy_params.min_tx_datarate,\n                              phy_params.max_tx_datarate, phy_params.channels.channel_list)\n                == false) {\n            status &= 0xFD; // Datarate KO\n        }\n\n        // Verify tx power\n        if (val_in_range(tx_power, phy_params.max_tx_power,\n                         phy_params.min_tx_power) == 0) {\n            // Verify if the maximum TX power is exceeded\n            if (phy_params.max_tx_power > tx_power) {\n                // Apply maximum TX power. Accept TX power.\n                tx_power = phy_params.max_tx_power;\n            } else {\n                status &= 0xFB; // TxPower KO\n            }\n        }\n    }\n\n    // If the status is ok, verify the NbRep\n    if (status == 0x07 && nb_repetitions == 0) {\n        // Restore the default value according to the LoRaWAN specification\n        nb_repetitions = 1;\n    }\n\n    // Apply changes\n    *dr = datarate;\n    *tx_pow = tx_power;\n    *nb_rep = nb_repetitions;\n\n    return status;\n}\n\ndouble LoRaPHY::compute_symb_timeout_lora(uint8_t phy_dr, uint32_t bandwidth)\n{\n    return ((double)(1 << phy_dr) / (double) bandwidth) * 1000;\n}\n\ndouble LoRaPHY::compute_symb_timeout_fsk(uint8_t phy_dr)\n{\n    return (8.0 / (double) phy_dr); // 1 symbol equals 1 byte\n}\n\nvoid LoRaPHY::get_rx_window_params(double t_symb, uint8_t min_rx_symb,\n                                   uint32_t rx_error, uint32_t wakeup_time,\n                                   uint32_t* window_timeout, int32_t* window_offset)\n{\n    // Computed number of symbols\n    *window_timeout = MAX ((uint32_t) ceil(((2 * min_rx_symb - 8) * t_symb + 2 * rx_error) / t_symb), min_rx_symb );\n    *window_offset = (int32_t) ceil((4.0 * t_symb) - ((*window_timeout * t_symb) / 2.0 ) - wakeup_time);\n}\n\nint8_t LoRaPHY::compute_tx_power(int8_t tx_power_idx, float max_eirp,\n                                 float antenna_gain)\n{\n    int8_t phy_tx_power = 0;\n\n    phy_tx_power = (int8_t) floor((max_eirp - (tx_power_idx * 2U)) - antenna_gain);\n\n    return phy_tx_power;\n}\n\n\nint8_t LoRaPHY::get_next_lower_dr(int8_t dr, int8_t min_dr)\n{\n    uint8_t next_lower_dr = 0;\n\n    if (dr == min_dr) {\n        next_lower_dr = min_dr;\n    } else {\n        next_lower_dr = dr - 1;\n    }\n\n    return next_lower_dr;\n}\n\nuint8_t LoRaPHY::get_bandwidth(uint8_t dr)\n{\n    uint32_t *bandwidths = (uint32_t *) phy_params.bandwidths.table;\n\n    switch(bandwidths[dr]) {\n        default:\n        case 125000:\n            return 0;\n        case 250000:\n            return 1;\n        case 500000:\n            return 2;\n    }\n}\n\nuint8_t LoRaPHY::enabled_channel_count(bool joined, uint8_t datarate,\n                                       const uint16_t *channel_mask,\n                                       uint8_t *channel_indices,\n                                       uint8_t *delayTx)\n{\n    uint8_t count = 0;\n    uint8_t delay_transmission = 0;\n\n    for (uint8_t i = 0; i < phy_params.max_channel_cnt; i++) {\n        if (mask_bit_test(channel_mask, i)) {\n\n            if (val_in_range(datarate, phy_params.channels.channel_list[i].dr_range.fields.min,\n                             phy_params.channels.channel_list[i].dr_range.fields.max ) == 0) {\n                // data rate range invalid for this channel\n                continue;\n            }\n\n            band_t *band_table = (band_t *) phy_params.bands.table;\n            if (band_table[phy_params.channels.channel_list[i].band].off_time > 0) {\n                // Check if the band is available for transmission\n                delay_transmission++;\n                continue;\n            }\n\n            // otherwise count the channel as enabled\n            channel_indices[count++] = i;\n        }\n    }\n\n    *delayTx = delay_transmission;\n\n    return count;\n}\n\nvoid LoRaPHY::reset_to_default_values(loramac_protocol_params *params, bool init)\n{\n    if (init) {\n        params->is_dutycycle_on = phy_params.duty_cycle_enabled;\n\n        params->sys_params.max_rx_win_time = phy_params.max_rx_window;\n\n        params->sys_params.recv_delay1 = phy_params.recv_delay1;\n\n        params->sys_params.recv_delay2 = phy_params.recv_delay2;\n\n        params->sys_params.join_accept_delay1 = phy_params.join_accept_delay1;\n\n        params->sys_params.join_accept_delay2 = phy_params.join_accept_delay2;\n\n        params->sys_params.downlink_dwell_time = phy_params.dl_dwell_time_setting;\n    }\n\n    params->sys_params.channel_tx_power = get_default_tx_power();\n\n    params->sys_params.channel_data_rate = get_default_tx_datarate();\n\n    params->sys_params.rx1_dr_offset = phy_params.default_rx1_dr_offset;\n\n    params->sys_params.rx2_channel.frequency = get_default_rx2_frequency();\n\n    params->sys_params.rx2_channel.datarate = get_default_rx2_datarate();\n\n    params->sys_params.uplink_dwell_time = phy_params.ul_dwell_time_setting;\n\n    params->sys_params.max_eirp = phy_params.default_max_eirp;\n\n    params->sys_params.antenna_gain = phy_params.default_antenna_gain;\n}\n\nint8_t LoRaPHY::get_next_lower_tx_datarate(int8_t datarate)\n{\n    if (phy_params.ul_dwell_time_setting == 0) {\n        return get_next_lower_dr(datarate, phy_params.min_tx_datarate);\n    }\n\n    return get_next_lower_dr(datarate, phy_params.dwell_limit_datarate);\n\n}\n\nuint8_t LoRaPHY::get_minimum_rx_datarate()\n{\n    if (phy_params.dl_dwell_time_setting == 0) {\n        return phy_params.min_rx_datarate;\n    }\n    return phy_params.dwell_limit_datarate;\n}\n\nuint8_t LoRaPHY::get_minimum_tx_datarate()\n{\n    if (phy_params.ul_dwell_time_setting == 0) {\n        return phy_params.min_tx_datarate;\n    }\n    return phy_params.dwell_limit_datarate;\n}\n\nuint8_t LoRaPHY::get_default_tx_datarate()\n{\n    return phy_params.default_datarate;\n}\n\nuint8_t LoRaPHY::get_default_tx_power()\n{\n    return phy_params.default_tx_power;\n}\n\nuint8_t LoRaPHY::get_max_payload(uint8_t datarate, bool use_repeater)\n{\n    uint8_t *payload_table = NULL;\n\n    if (use_repeater) {\n//        if (datarate >= phy_params.payloads_with_repeater.size) {\n//            //TODO: Can this ever happen? If yes, should we return 0?\n//        }\n        payload_table = (uint8_t *) phy_params.payloads_with_repeater.table;\n    } else {\n        payload_table = (uint8_t *) phy_params.payloads.table;\n    }\n\n    return payload_table[datarate];\n}\n\nuint16_t LoRaPHY::get_maximum_frame_counter_gap()\n{\n    return phy_params.max_fcnt_gap;\n}\n\nuint32_t LoRaPHY::get_ack_timeout()\n{\n    uint16_t ack_timeout_rnd = phy_params.ack_timeout_rnd;\n    return (phy_params.ack_timeout\n            + get_random(-ack_timeout_rnd, ack_timeout_rnd));\n}\n\nuint32_t LoRaPHY::get_default_rx2_frequency()\n{\n    return phy_params.rx_window2_frequency;\n}\n\nuint8_t LoRaPHY::get_default_rx2_datarate()\n{\n    return phy_params.rx_window2_datarate;\n}\n\nuint16_t* LoRaPHY::get_channel_mask(bool get_default)\n{\n    if (get_default) {\n        return phy_params.channels.default_mask;\n    }\n    return phy_params.channels.mask;\n}\n\nuint8_t LoRaPHY::get_max_nb_channels()\n{\n    return phy_params.max_channel_cnt;\n}\n\nchannel_params_t* LoRaPHY::get_phy_channels()\n{\n    return phy_params.channels.channel_list;\n}\n\nbool LoRaPHY::is_custom_channel_plan_supported()\n{\n    return phy_params.custom_channelplans_supported;\n}\n\nvoid LoRaPHY::restore_default_channels()\n{\n    // Restore channels default mask\n    for (uint8_t i=0; i < phy_params.channels.mask_size; i++) {\n        phy_params.channels.mask[i] |= phy_params.channels.default_mask[i];\n    }\n}\n\nbool LoRaPHY::verify_rx_datarate(uint8_t datarate)\n{\n    if (phy_params.dl_dwell_time_setting == 0) {\n        //TODO: Check this! datarate must be same as minimum! Can be compared directly if OK\n        return val_in_range(datarate,\n                            phy_params.min_rx_datarate,\n                            phy_params.min_rx_datarate);\n    } else {\n        return val_in_range(datarate,\n                            phy_params.dwell_limit_datarate,\n                            phy_params.min_rx_datarate );\n    }\n}\n\nbool LoRaPHY::verify_tx_datarate(uint8_t datarate, bool use_default)\n{\n    if (use_default) {\n        return val_in_range(datarate, phy_params.default_datarate,\n                            phy_params.default_max_datarate);\n    } else if (phy_params.ul_dwell_time_setting == 0) {\n        return val_in_range(datarate, phy_params.min_tx_datarate,\n                            phy_params.max_tx_datarate);\n    } else {\n        return val_in_range(datarate, phy_params.dwell_limit_datarate,\n                            phy_params.max_tx_datarate);\n    }\n}\n\nbool LoRaPHY::verify_tx_power(uint8_t tx_power)\n{\n    return val_in_range(tx_power, phy_params.max_tx_power,\n                        phy_params.min_tx_power);\n}\n\nbool LoRaPHY::verify_duty_cycle(bool cycle)\n{\n    if (cycle == phy_params.duty_cycle_enabled) {\n        return true;\n    }\n    return false;\n}\n\nbool LoRaPHY::verify_nb_join_trials(uint8_t nb_join_trials)\n{\n    if (nb_join_trials < MBED_CONF_LORA_NB_TRIALS) {\n        return false;\n    }\n    return true;\n}\n\nvoid LoRaPHY::apply_cf_list(cflist_params_t* cf_list)\n{\n    // if the underlying PHY doesn't support CF-List, ignore the request\n    if (!phy_params.cflist_supported) {\n        return;\n    }\n\n    channel_params_t new_channel;\n\n    // Setup default datarate range\n    new_channel.dr_range.value = (phy_params.default_max_datarate << 4)\n                                  | phy_params.default_datarate;\n\n    // Size of the optional CF list\n    if (cf_list->size != 16) {\n        return;\n    }\n\n    // Last byte is RFU, don't take it into account\n    // NOTE: Currently the PHY layers supported by LoRaWAN who accept a CF-List\n    // define first 2 or 3 channels as default channels. this function is\n    // written keeping that in mind. If there would be a PHY in the future that\n    // accepts CF-list but have haphazard allocation of default channels, we\n    // should override this function in the implementation of that particular\n    // PHY.\n    for (uint8_t i = 0, channel_id = phy_params.default_channel_cnt;\n         channel_id < phy_params.max_channel_cnt; i+=phy_params.default_channel_cnt, channel_id++) {\n        if (channel_id < (phy_params.cflist_channel_cnt + phy_params.default_channel_cnt)) {\n            // Channel frequency\n            new_channel.frequency = (uint32_t) cf_list->payload[i];\n            new_channel.frequency |= ((uint32_t) cf_list->payload[i + 1] << 8);\n            new_channel.frequency |= ((uint32_t) cf_list->payload[i + 2] << 16);\n            new_channel.frequency *= 100;\n\n            // Initialize alternative frequency to 0\n            new_channel.rx1_frequency = 0;\n        } else {\n            new_channel.frequency = 0;\n            new_channel.dr_range.value = 0;\n            new_channel.rx1_frequency = 0;\n        }\n\n        if (new_channel.frequency != 0) {\n            // Try to add channel\n            add_channel(&new_channel, channel_id);\n        } else {\n            remove_channel(channel_id);\n        }\n    }\n}\n\n\nbool LoRaPHY::get_next_ADR(bool restore_channel_mask, int8_t& dr_out,\n                           int8_t& tx_power_out, uint32_t& adr_ack_cnt)\n{\n    bool set_adr_ack_bit = false;\n\n    uint16_t ack_limit_plus_delay = phy_params.adr_ack_limit + phy_params.adr_ack_delay;\n\n    if (dr_out == phy_params.min_tx_datarate) {\n        adr_ack_cnt = 0;\n        return set_adr_ack_bit;\n    }\n\n    if (adr_ack_cnt < phy_params.adr_ack_limit) {\n        return set_adr_ack_bit;\n    }\n\n    // ADR ack counter is larger than ADR-ACK-LIMIT\n    set_adr_ack_bit = true;\n    tx_power_out = phy_params.max_tx_power;\n\n    if (adr_ack_cnt >= ack_limit_plus_delay) {\n        if ((adr_ack_cnt % phy_params.adr_ack_delay) == 1) {\n            // Decrease the datarate\n            dr_out = get_next_lower_tx_datarate(dr_out);\n\n            if (dr_out == phy_params.min_tx_datarate) {\n                // We must set adrAckReq to false as soon as we reach the lowest datarate\n                set_adr_ack_bit = false;\n                if (restore_channel_mask) {\n                    // Re-enable default channels\n                    restore_default_channels();\n                }\n            }\n        }\n    }\n\n    return set_adr_ack_bit;\n}\n\nvoid LoRaPHY::compute_rx_win_params(int8_t datarate, uint8_t min_rx_symbols,\n                                    uint32_t rx_error,\n                                    rx_config_params_t *rx_conf_params)\n{\n    double t_symbol = 0.0;\n\n    // Get the datarate, perform a boundary check\n    rx_conf_params->datarate = MIN( datarate, phy_params.max_rx_datarate);\n\n    rx_conf_params->bandwidth = get_bandwidth(rx_conf_params->datarate);\n\n    if (phy_params.fsk_supported && rx_conf_params->datarate == phy_params.max_rx_datarate) {\n        // FSK\n        t_symbol = compute_symb_timeout_fsk(((uint8_t *)phy_params.datarates.table)[rx_conf_params->datarate]);\n    } else {\n        // LoRa\n        t_symbol = compute_symb_timeout_lora(((uint8_t *)phy_params.datarates.table)[rx_conf_params->datarate],\n                                            ((uint32_t *)phy_params.bandwidths.table)[rx_conf_params->datarate]);\n    }\n\n    get_rx_window_params(t_symbol, min_rx_symbols, rx_error, RADIO_WAKEUP_TIME,\n                         &rx_conf_params->window_timeout, &rx_conf_params->window_offset);\n}\n\nbool LoRaPHY::rx_config(rx_config_params_t* rx_conf, int8_t* datarate)\n{\n    radio_modems_t modem;\n    uint8_t dr = rx_conf->datarate;\n    uint8_t max_payload = 0;\n    uint8_t phy_dr = 0;\n    uint32_t frequency = rx_conf->frequency;\n\n    _radio->lock();\n\n    if (_radio->get_status() != RF_IDLE) {\n        _radio->unlock();\n        return false;\n    }\n\n    _radio->unlock();\n\n    if (rx_conf->rx_slot == RX_SLOT_WIN_1) {\n        // Apply window 1 frequency\n        frequency = phy_params.channels.channel_list[rx_conf->channel].frequency;\n        // Apply the alternative RX 1 window frequency, if it is available\n        if (phy_params.channels.channel_list[rx_conf->channel].rx1_frequency != 0) {\n            frequency = phy_params.channels.channel_list[rx_conf->channel].rx1_frequency;\n        }\n    }\n\n    // Read the physical datarate from the datarates table\n    uint8_t *datarate_table = (uint8_t *) phy_params.datarates.table;\n    uint8_t *payload_table = (uint8_t *) phy_params.payloads.table;\n    uint8_t *payload_with_repeater_table = (uint8_t *) phy_params.payloads_with_repeater.table;\n\n    phy_dr = datarate_table[dr];\n\n    _radio->lock();\n\n    _radio->set_channel(frequency);\n\n    // Radio configuration\n    if (dr == DR_7 && phy_params.fsk_supported) {\n        modem = MODEM_FSK;\n        _radio->set_rx_config(modem, 50000, phy_dr * 1000, 0, 83333, 5,\n                              rx_conf->window_timeout, false, 0, true, 0, 0,\n                              false, rx_conf->is_rx_continuous);\n    } else {\n        modem = MODEM_LORA;\n        _radio->set_rx_config(modem, rx_conf->bandwidth, phy_dr, 1, 0, 8,\n                              rx_conf->window_timeout, false, 0, false, 0, 0,\n                              true, rx_conf->is_rx_continuous);\n    }\n\n    if (rx_conf->is_repeater_supported) {\n        max_payload = payload_with_repeater_table[dr];\n    } else {\n        max_payload = payload_table[dr];\n    }\n\n    _radio->set_max_payload_length(modem, max_payload + LORA_MAC_FRMPAYLOAD_OVERHEAD);\n\n    _radio->unlock();\n\n    *datarate = phy_dr;\n\n    return true;\n}\n\nbool LoRaPHY::tx_config(tx_config_params_t* tx_conf, int8_t* tx_power,\n                        lorawan_time_t* tx_toa)\n{\n    radio_modems_t modem;\n    int8_t phy_dr = ((uint8_t *)phy_params.datarates.table)[tx_conf->datarate];\n    channel_params_t *list = phy_params.channels.channel_list;\n    uint8_t band_idx = list[tx_conf->channel].band;\n    band_t *bands = (band_t *)phy_params.bands.table;\n\n    // limit TX power if set to too much\n    if (tx_conf->tx_power > bands[band_idx].max_tx_pwr) {\n        tx_conf->tx_power = bands[band_idx].max_tx_pwr;\n    }\n\n    uint8_t bandwidth = get_bandwidth(tx_conf->datarate);\n    int8_t phy_tx_power = 0;\n\n    // Calculate physical TX power\n    phy_tx_power = compute_tx_power(tx_conf->tx_power, tx_conf->max_eirp,\n                                    tx_conf->antenna_gain);\n\n    _radio->lock();\n\n    // Setup the radio frequency\n    _radio->set_channel(list[tx_conf->channel].frequency);\n\n    if( tx_conf->datarate == phy_params.max_tx_datarate ) {\n        // High Speed FSK channel\n        modem = MODEM_FSK;\n        _radio->set_tx_config(modem, phy_tx_power, 25000, bandwidth,\n                              phy_dr * 1000, 0, 5, false, true, 0, 0, false,\n                              3000);\n    } else {\n        modem = MODEM_LORA;\n        _radio->set_tx_config(modem, phy_tx_power, 0, bandwidth, phy_dr, 1, 8,\n                              false, true, 0, 0, false, 3000 );\n    }\n\n    // Setup maximum payload lenght of the radio driver\n    _radio->set_max_payload_length( modem, tx_conf->pkt_len);\n    // Get the time-on-air of the next tx frame\n    *tx_toa = _radio->time_on_air(modem, tx_conf->pkt_len);\n\n    _radio->unlock();\n\n    *tx_power = tx_conf->tx_power;\n\n    return true;\n}\n\nuint8_t LoRaPHY::link_ADR_request(adr_req_params_t* link_adr_req,\n                                  int8_t* dr_out, int8_t* tx_power_out,\n                                  uint8_t* nb_rep_out, uint8_t* nb_bytes_processed)\n{\n    uint8_t status = 0x07;\n    link_adr_params_t adr_settings;\n    uint8_t next_index = 0;\n    uint8_t bytes_processed = 0;\n\n    // rather than dynamically allocating memory, we choose to set\n    // a channel mask list size of unity here as we know that all\n    // the PHY layer implementations who have more than 16 channels, i.e.,\n    // have channel mask list size more than unity, override this method.\n    uint16_t temp_channel_mask[1] = {0};\n\n    verify_adr_params_t verify_params;\n\n    while (bytes_processed < link_adr_req->payload_size) {\n        // Get ADR request parameters\n        next_index = parse_link_ADR_req(&(link_adr_req->payload[bytes_processed]),\n                                       &adr_settings);\n\n        if (next_index == 0) {\n            break; // break loop, since no more request has been found\n        }\n\n        // Update bytes processed\n        bytes_processed += next_index;\n\n        // Revert status, as we only check the last ADR request for the channel mask KO\n        status = 0x07;\n\n        // Setup temporary channels mask\n        temp_channel_mask[0] = adr_settings.channel_mask;\n\n        // Verify channels mask\n        if (adr_settings.ch_mask_ctrl == 0 && temp_channel_mask[0] == 0) {\n            status &= 0xFE; // Channel mask KO\n        }\n\n        // channel mask applies to first 16 channels\n        if (adr_settings.ch_mask_ctrl == 0 ||\n            adr_settings.ch_mask_ctrl == 6) {\n\n            for (uint8_t i = 0; i < phy_params.max_channel_cnt; i++) {\n\n                // turn on all channels if channel mask control is 6\n                if (adr_settings.ch_mask_ctrl == 6) {\n                    if (phy_params.channels.channel_list[i].frequency != 0) {\n                        mask_bit_set(temp_channel_mask, i);\n                    }\n\n                    continue;\n                }\n\n                // if channel mask control is 0, we test the bits and\n                // frequencies and change the status if we find a discrepancy\n                if ((mask_bit_test(temp_channel_mask, i)) &&\n                    (phy_params.channels.channel_list[i].frequency == 0)) {\n                    // Trying to enable an undefined channel\n                    status &= 0xFE; // Channel mask KO\n                }\n            }\n        } else {\n            // Channel mask control applies to RFUs\n            status &= 0xFE; // Channel mask KO\n        }\n    }\n\n    verify_params.status = status;\n\n    verify_params.adr_enabled = link_adr_req->adr_enabled;\n    verify_params.current_datarate = link_adr_req->current_datarate;\n    verify_params.current_tx_power = link_adr_req->current_tx_power;\n    verify_params.current_nb_rep = link_adr_req->current_nb_rep;\n\n    verify_params.datarate = adr_settings.datarate;\n    verify_params.tx_power = adr_settings.tx_power;\n    verify_params.nb_rep = adr_settings.nb_rep;\n\n\n    verify_params.channel_mask = temp_channel_mask;\n\n    // Verify the parameters and update, if necessary\n    status = verify_link_ADR_req(&verify_params, &adr_settings.datarate,\n                                 &adr_settings.tx_power, &adr_settings.nb_rep);\n\n    // Update channelsMask if everything is correct\n    if (status == 0x07) {\n        // Set the channels mask to a default value\n        memset(phy_params.channels.mask, 0,\n               sizeof(uint16_t)*phy_params.channels.mask_size);\n\n        // Update the channels mask\n        copy_channel_mask(phy_params.channels.mask, temp_channel_mask,\n                          phy_params.channels.mask_size);\n    }\n\n    // Update status variables\n    *dr_out = adr_settings.datarate;\n    *tx_power_out = adr_settings.tx_power;\n    *nb_rep_out = adr_settings.nb_rep;\n    *nb_bytes_processed = bytes_processed;\n\n    return status;\n}\n\nuint8_t LoRaPHY::accept_rx_param_setup_req(rx_param_setup_req_t* params)\n{\n    uint8_t status = 0x07;\n\n    // Verify radio frequency\n    if (_radio->check_rf_frequency(params->frequency) == false) {\n        status &= 0xFE; // Channel frequency KO\n    }\n\n    // Verify datarate\n    if (val_in_range(params->datarate, phy_params.min_rx_datarate,\n                     phy_params.max_rx_datarate) == 0) {\n        status &= 0xFD; // Datarate KO\n    }\n\n    // Verify datarate offset\n    if (val_in_range(params->dr_offset, phy_params.min_rx1_dr_offset,\n                     phy_params.max_rx1_dr_offset) == 0) {\n        status &= 0xFB; // Rx1DrOffset range KO\n    }\n\n    return status;\n}\n\nbool LoRaPHY::accept_tx_param_setup_req(tx_param_setup_req_t *params)\n{\n    if (phy_params.accept_tx_param_setup_req) {\n        phy_params.ul_dwell_time_setting = params->ul_dwell_time;\n        phy_params.dl_dwell_time_setting = params->dl_dwell_time;\n    }\n\n    return phy_params.accept_tx_param_setup_req;\n}\n\nbool LoRaPHY::verify_frequency(uint32_t freq)\n{\n    band_t *bands_table = (band_t *)phy_params.bands.table;\n\n    // check all sub bands (if there are sub-bands) to check if the given\n    // frequency falls into any of the frequency ranges\n\n    for (uint8_t i=0; i<phy_params.bands.size; i++) {\n        if (freq <= bands_table[i].higher_band_freq\n                 && freq >= bands_table[i].lower_band_freq) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nuint8_t LoRaPHY::dl_channel_request(dl_channel_req_params_t* params)\n{\n    if (!phy_params.dl_channel_req_supported) {\n        return 0;\n    }\n\n    uint8_t status = 0x03;\n\n    // Verify if the frequency is supported\n    if (verify_frequency(params->rx1_frequency) == false) {\n        status &= 0xFE;\n    }\n\n    // Verify if an uplink frequency exists\n    if (phy_params.channels.channel_list[params->channel_id].frequency == 0) {\n        status &= 0xFD;\n    }\n\n    // Apply Rx1 frequency, if the status is OK\n    if (status == 0x03) {\n        phy_params.channels.channel_list[params->channel_id].rx1_frequency = params->rx1_frequency;\n    }\n\n    return status;\n}\n\n/**\n * Alternate datarate algorithm for join requests.\n *  - We check from the PHY and take note of total\n *    number of data rates available upto the default data rate for\n *    default channels.\n *\n *  - Application sets a total number of re-trials for a Join Request, i.e.,\n *    MBED_CONF_LORA_NB_TRIALS. So MAC layer will send us a counter\n *    nb_trials < MBED_CONF_LORA_NB_TRIALS which is the current number of trial.\n *\n *  - We roll over total available datarates and pick one according to the\n *    number of trial sequentially.\n *\n *  - We always start from the Default Data rate and and set the next lower\n *    data rate for every iteration.\n *\n *  - MAC layer will stop when maximum number of re-trials, i.e.,\n *    MBED_CONF_LORA_NB_TRIALS is achieved.\n *\n * So essentially MBED_CONF_LORA_NB_TRIALS should be a multiple of range of\n * data rates available. For example, in EU868 band, default max. data rate is\n * DR_5 and min. data rate is DR_0, so total data rates available are 6.\n *\n * Hence MBED_CONF_LORA_NB_TRIALS should be a multiple of 6. Setting,\n * MBED_CONF_LORA_NB_TRIALS = 6 would mean that every data rate will be tried\n * exactly once starting from the largest and finishing at the smallest.\n *\n * PHY layers which do not have datarates scheme similar to EU band will ofcourse\n * override this method.\n */\nint8_t LoRaPHY::get_alternate_DR(uint8_t nb_trials)\n{\n    int8_t datarate = 0;\n    uint8_t total_nb_datrates = (phy_params.default_max_datarate - phy_params.min_tx_datarate) + 1;\n\n    uint8_t res = nb_trials % total_nb_datrates;\n\n    if (res == 0) {\n        datarate = phy_params.min_tx_datarate;\n    } else if (res == 1) {\n        datarate = phy_params.default_max_datarate;\n    } else {\n        datarate = (phy_params.default_max_datarate - res) + 1;\n    }\n\n    return datarate;\n}\n\nvoid LoRaPHY::calculate_backoff(backoff_params_t* calc_backoff)\n{\n    band_t *band_table = (band_t *) phy_params.bands.table;\n    channel_params_t *channel_list = phy_params.channels.channel_list;\n\n    uint8_t band_idx = channel_list[calc_backoff->channel].band;\n    uint16_t duty_cycle = band_table[band_idx].duty_cycle;\n    uint16_t join_duty_cycle = 0;\n\n    // Reset time-off to initial value.\n    band_table[band_idx].off_time = 0;\n\n    if (calc_backoff->joined == false) {\n        // Get the join duty cycle\n        if (calc_backoff->elapsed_time < 3600000) {\n            join_duty_cycle = BACKOFF_DC_1_HOUR;\n        } else if (calc_backoff->elapsed_time < (3600000 + 36000000)) {\n            join_duty_cycle = BACKOFF_DC_10_HOURS;\n        } else {\n            join_duty_cycle = BACKOFF_DC_24_HOURS;\n        }\n\n        // Apply the most restricting duty cycle\n        duty_cycle = MAX(duty_cycle, join_duty_cycle);\n    }\n\n    // No back-off if the last frame was not a join request and when the\n    // duty cycle is not enabled\n    if (calc_backoff->dc_enabled == false &&\n        calc_backoff->last_tx_was_join_req == false) {\n        band_table[band_idx].off_time = 0;\n    } else {\n        // Apply band time-off.\n        band_table[band_idx].off_time = calc_backoff->tx_toa * duty_cycle - calc_backoff->tx_toa;\n    }\n}\n\nbool LoRaPHY::set_next_channel(channel_selection_params_t* params,\n                               uint8_t* channel, lorawan_time_t* time,\n                               lorawan_time_t* aggregate_timeoff)\n{\n    uint8_t channel_count = 0;\n    uint8_t delay_tx = 0;\n\n    // Note here that the PHY layer implementations which have more than\n    // 16 channels at their disposal, override this function. That's why\n    // it is safe to assume that we are dealing with a block of 16 channels\n    // i.e., EU like implementations. So rather than dynamically allocating\n    // memory we chose to use a magic number of 16\n    uint8_t enabled_channels[16];\n\n    memset(enabled_channels, 0xFF, sizeof(uint8_t)*16);\n\n    lorawan_time_t next_tx_delay = 0;\n    band_t *band_table = (band_t *) phy_params.bands.table;\n\n    if (num_active_channels(phy_params.channels.mask, 0,\n                            phy_params.channels.mask_size) == 0) {\n\n        // Reactivate default channels\n        copy_channel_mask(phy_params.channels.mask,\n                          phy_params.channels.default_mask,\n                          phy_params.channels.mask_size);\n    }\n\n    if (params->aggregate_timeoff\n            <= _lora_time.get_elapsed_time(params->last_aggregate_tx_time)) {\n        // Reset Aggregated time off\n        *aggregate_timeoff = 0;\n\n        // Update bands Time OFF\n        next_tx_delay = update_band_timeoff(params->joined,\n                                          params->dc_enabled,\n                                          band_table, phy_params.bands.size);\n\n        // Search how many channels are enabled\n        channel_count = enabled_channel_count(params->joined, params->current_datarate,\n                                                  phy_params.channels.mask,\n                                                  enabled_channels, &delay_tx);\n    } else {\n        delay_tx++;\n        next_tx_delay = params->aggregate_timeoff\n                - _lora_time.get_elapsed_time(params->last_aggregate_tx_time);\n    }\n\n    if (channel_count > 0) {\n        // We found a valid channel\n        *channel = enabled_channels[get_random(0, channel_count - 1)];\n        *time = 0;\n        return true;\n    }\n\n    if (delay_tx > 0) {\n        // Delay transmission due to AggregatedTimeOff or to a band time off\n        *time = next_tx_delay;\n        return true;\n    }\n\n    // Datarate not supported by any channel, restore defaults\n    copy_channel_mask(phy_params.channels.mask,\n                      phy_params.channels.default_mask,\n                      phy_params.channels.mask_size);\n    *time = 0;\n    return false;\n}\n\nlorawan_status_t LoRaPHY::add_channel(channel_params_t* new_channel, uint8_t id)\n{\n    bool dr_invalid = false;\n    bool freq_invalid = false;\n\n    if (!phy_params.custom_channelplans_supported\n            || id >= phy_params.max_channel_cnt) {\n\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    // Validate the datarate range\n    if (val_in_range(new_channel->dr_range.fields.min,\n                     phy_params.min_tx_datarate,\n                     phy_params.max_tx_datarate) == 0) {\n        dr_invalid = true;\n    }\n\n    if (val_in_range(new_channel->dr_range.fields.max, phy_params.min_tx_datarate,\n                     phy_params.max_tx_datarate) == 0) {\n        dr_invalid = true;\n    }\n\n    if (new_channel->dr_range.fields.min > new_channel->dr_range.fields.max) {\n        dr_invalid = true;\n    }\n\n    // Default channels don't accept all values\n    if (id < phy_params.default_channel_cnt) {\n        // Validate the datarate range for min: must be DR_0\n        if (new_channel->dr_range.fields.min > phy_params.min_tx_datarate) {\n            dr_invalid = true;\n        }\n\n        // Validate the datarate range for max: must be DR_5 <= Max <= TX_MAX_DATARATE\n        if (val_in_range(new_channel->dr_range.fields.max,\n                         phy_params.default_max_datarate,\n                         phy_params.max_tx_datarate) == 0) {\n            dr_invalid = true;\n        }\n\n        // We are not allowed to change the frequency\n        if (new_channel->frequency != phy_params.channels.channel_list[id].frequency) {\n            freq_invalid = true;\n        }\n    }\n\n    // Check frequency\n    if (!freq_invalid) {\n        if (verify_frequency(new_channel->frequency) == false) {\n            freq_invalid = true;\n        }\n    }\n\n    // Check status\n    if (dr_invalid && freq_invalid) {\n        return LORAWAN_STATUS_FREQ_AND_DR_INVALID;\n    }\n\n    if (dr_invalid) {\n        return LORAWAN_STATUS_DATARATE_INVALID;\n    }\n\n    if (freq_invalid) {\n        return LORAWAN_STATUS_FREQUENCY_INVALID;\n    }\n\n    memcpy(&(phy_params.channels.channel_list[id]), new_channel, sizeof(channel_params_t));\n\n    phy_params.channels.channel_list[id].band = new_channel->band;\n\n    mask_bit_set(phy_params.channels.mask, id);\n\n    return LORAWAN_STATUS_OK;\n}\n\nbool LoRaPHY::remove_channel(uint8_t channel_id)\n{\n    // upper layers are checking if the custom channel planning is supported or\n    // not. So we don't need to worry about that\n    if (mask_bit_test(phy_params.channels.default_mask, channel_id)) {\n        return false;\n    }\n\n\n    // Remove the channel from the list of channels\n    const channel_params_t empty_channel = { 0, 0, { 0 }, 0 };\n    phy_params.channels.channel_list[channel_id] = empty_channel;\n\n    return disable_channel(phy_params.channels.mask, channel_id,\n                           phy_params.max_channel_cnt);\n}\n\nvoid LoRaPHY::set_tx_cont_mode(cw_mode_params_t* params, uint32_t given_frequency)\n{\n    band_t *bands_table = (band_t *) phy_params.bands.table;\n    channel_params_t *channels = phy_params.channels.channel_list;\n\n    if (params->tx_power > bands_table[channels[params->channel].band].max_tx_pwr) {\n        params->tx_power = bands_table[channels[params->channel].band].max_tx_pwr;\n    }\n\n    int8_t phy_tx_power = 0;\n    uint32_t frequency  = 0;\n\n    if (given_frequency == 0) {\n       frequency = channels[params->channel].frequency;\n    } else {\n        frequency = given_frequency;\n    }\n\n    // Calculate physical TX power\n    if (params->max_eirp > 0 && params->antenna_gain > 0) {\n        phy_tx_power = compute_tx_power(params->tx_power, params->max_eirp,\n                                    params->antenna_gain );\n    } else {\n        phy_tx_power = params->tx_power;\n    }\n\n    _radio->lock();\n    _radio->set_tx_continuous_wave(frequency, phy_tx_power, params->timeout);\n    _radio->unlock();\n}\n\nuint8_t LoRaPHY::apply_DR_offset(int8_t dr, int8_t dr_offset)\n{\n    int8_t datarate = dr - dr_offset;\n\n    if (datarate < 0) {\n        datarate = phy_params.min_tx_datarate;\n    }\n\n    return datarate;\n}\n\n\n","/**\n *  @file LoRaPHYEU868.cpp\n *\n *  @brief Implements LoRaPHY for European 868 MHz band\n *\n *  \\code\n *   ______                              _\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *   (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n */\n\n#include \"LoRaPHYEU868.h\"\n#include \"lora_phy_ds.h\"\n\n/*!\n * Number of default channels\n */\n#define EU868_NUMB_DEFAULT_CHANNELS                 3\n\n/*!\n * Number of channels to apply for the CF list\n */\n#define EU868_NUMB_CHANNELS_CF_LIST                 5\n\n/*!\n * Minimal datarate that can be used by the node\n */\n#define EU868_TX_MIN_DATARATE                       DR_0\n\n/*!\n * Maximal datarate that can be used by the node\n */\n#define EU868_TX_MAX_DATARATE                       DR_7\n\n/*!\n * Minimal datarate that can be used by the node\n */\n#define EU868_RX_MIN_DATARATE                       DR_0\n\n/*!\n * Maximal datarate that can be used by the node\n */\n#define EU868_RX_MAX_DATARATE                       DR_7\n\n/*!\n * Default datarate used by the node\n */\n#define EU868_DEFAULT_DATARATE                      DR_0\n\n#define EU868_DEFAULT_MAX_DATARATE                  DR_5\n\n/*!\n * Minimal Rx1 receive datarate offset\n */\n#define EU868_MIN_RX1_DR_OFFSET                     0\n\n/*!\n * Maximal Rx1 receive datarate offset\n */\n#define EU868_MAX_RX1_DR_OFFSET                     5\n\n/*!\n * Default Rx1 receive datarate offset\n */\n#define EU868_DEFAULT_RX1_DR_OFFSET                 0\n\n/*!\n * Minimal Tx output power that can be used by the node\n */\n#define EU868_MIN_TX_POWER                          TX_POWER_7\n\n/*!\n * Maximal Tx output power that can be used by the node\n */\n#define EU868_MAX_TX_POWER                          TX_POWER_0\n\n/*!\n * Default Tx output power used by the node\n */\n#define EU868_DEFAULT_TX_POWER                      TX_POWER_0\n\n/*!\n * Default Max EIRP\n */\n#define EU868_DEFAULT_MAX_EIRP                      16.0f\n\n/*!\n * Default antenna gain\n */\n#define EU868_DEFAULT_ANTENNA_GAIN                  2.15f\n\n/*!\n * ADR Ack limit\n */\n#define EU868_ADR_ACK_LIMIT                         64\n\n/*!\n * ADR Ack delay\n */\n#define EU868_ADR_ACK_DELAY                         32\n\n/*!\n * Enabled or disabled the duty cycle\n */\n#define EU868_DUTY_CYCLE_ENABLED                    1\n\n/*!\n * Maximum RX window duration\n */\n#define EU868_MAX_RX_WINDOW                         3000\n\n/*!\n * Receive delay 1\n */\n#define EU868_RECEIVE_DELAY1                        1000\n\n/*!\n * Receive delay 2\n */\n#define EU868_RECEIVE_DELAY2                        2000\n\n/*!\n * Join accept delay 1\n */\n#define EU868_JOIN_ACCEPT_DELAY1                    5000\n\n/*!\n * Join accept delay 2\n */\n#define EU868_JOIN_ACCEPT_DELAY2                    6000\n\n/*!\n * Maximum frame counter gap\n */\n#define EU868_MAX_FCNT_GAP                          16384\n\n/*!\n * Ack timeout\n */\n#define EU868_ACKTIMEOUT                            2000\n\n/*!\n * Random ack timeout limits\n */\n#define EU868_ACK_TIMEOUT_RND     1000\n\n#if ( EU868_DEFAULT_DATARATE > DR_5 )\n#error \"A default DR higher than DR_5 may lead to connectivity loss.\"\n#endif\n\n/*!\n * Second reception window channel frequency definition.\n */\n#define EU868_RX_WND_2_FREQ       869525000\n\n/*!\n * Second reception window channel datarate definition.\n */\n#define EU868_RX_WND_2_DR          DR_0\n\n/*!\n * Band 0 definition\n * { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND0 = {100 , EU868_MAX_TX_POWER, 0, 0, 0,865000000, 868000000}; //  1.0 %\n/*!\n * Band 1 definition\n * { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND1 = {100 , EU868_MAX_TX_POWER, 0, 0, 0, 868100000, 868600000}; //  1.0 %\n\n/*!\n * Band 2 definition\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND2 = {1000, EU868_MAX_TX_POWER, 0, 0, 0, 868700000, 869200000}; //  0.1 %\n\n/*!\n * Band 3 definition\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND3 = {10  , EU868_MAX_TX_POWER, 0, 0, 0, 869400000, 869650000}; // 10.0 %\n\n/*!\n * Band 4 definition\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND4 = {100 , EU868_MAX_TX_POWER, 0, 0, 0, 869700000, 870000000}; //  1.0 %\n\n/*!\n * Band 5 definition - It's actually a sub part of Band 2\n * Band = { DutyCycle, TxMaxPower, LastJoinTxDoneTime, LastTxDoneTime, TimeOff }\n */\nstatic const band_t EU868_BAND5 = {1000, EU868_MAX_TX_POWER, 0, 0, 0, 863000000, 865000000}; //  0.1 %\n\n/*!\n * LoRaMac default channel 1\n * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }\n */\nstatic const channel_params_t EU868_LC1 = {868100000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1};\n\n/*!\n * LoRaMac default channel 2\n * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }\n */\nstatic const channel_params_t EU868_LC2 = {868300000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1};\n\n/*!\n * LoRaMac default channel 3\n * Channel = { Frequency [Hz], RX1 Frequency [Hz], { ( ( DrMax << 4 ) | DrMin ) }, Band }\n */\nstatic const channel_params_t EU868_LC3 = {868500000, 0, { ( ( DR_5 << 4 ) | DR_0 ) }, 1};\n\n/*!\n * LoRaMac channels which are allowed for the join procedure\n */\n#define EU868_JOIN_CHANNELS        (uint16_t)(LC(1) | LC(2) | LC(3))\n\n/*!\n * Data rates table definition\n */\nstatic const uint8_t datarates_EU868[]  = {12, 11, 10,  9,  8,  7,  7, 50};\n\n/*!\n * Bandwidths table definition in Hz\n */\nstatic const uint32_t bandwidths_EU868[] = {125000, 125000, 125000, 125000, 125000, 125000, 250000, 0};\n\n/*!\n * Maximum payload with respect to the datarate index. Cannot operate with repeater.\n */\nstatic const uint8_t max_payloads_EU868[] = {51, 51, 51, 115, 242, 242, 242, 242};\n\n/*!\n * Maximum payload with respect to the datarate index. Can operate with repeater.\n */\nstatic const uint8_t max_payloads_repeater_EU868[] = {51, 51, 51, 115, 222, 222, 222, 222};\n\nLoRaPHYEU868::LoRaPHYEU868(LoRaWANTimeHandler &lora_time)\n    : LoRaPHY(lora_time)\n{\n    bands[0] = EU868_BAND0;\n    bands[1] = EU868_BAND1;\n    bands[2] = EU868_BAND2;\n    bands[3] = EU868_BAND3;\n    bands[4] = EU868_BAND4;\n    bands[5] = EU868_BAND5;\n\n    // Default Channels are always enabled, rest will be added later\n    channels[0] = EU868_LC1;\n    channels[1] = EU868_LC2;\n    channels[2] = EU868_LC3;\n\n    // Initialize the channels default mask\n    default_channel_mask[0] = LC(1) + LC(2) + LC(3);\n    // Update the channels mask\n    copy_channel_mask(channel_mask, default_channel_mask, 1);\n\n    // set default channels\n    phy_params.channels.channel_list = channels;\n    phy_params.channels.channel_list_size = EU868_MAX_NB_CHANNELS;\n    phy_params.channels.mask = channel_mask;\n    phy_params.channels.default_mask = default_channel_mask;\n    phy_params.channels.mask_size = EU868_CHANNEL_MASK_SIZE;\n\n    // set bands for EU868 spectrum\n    phy_params.bands.table = (void *) bands;\n    phy_params.bands.size = EU868_MAX_NB_BANDS;\n\n    // set bandwidths available in EU868 spectrum\n    phy_params.bandwidths.table = (void *) bandwidths_EU868;\n    phy_params.bandwidths.size = 8;\n\n    // set data rates available in EU868 spectrum\n    phy_params.datarates.table = (void *) datarates_EU868;\n    phy_params.datarates.size = 8;\n\n    // set payload sizes with respect to data rates\n    phy_params.payloads.table = (void *) max_payloads_EU868;\n    phy_params.payloads.size = 8;\n    phy_params.payloads_with_repeater.table = (void *) max_payloads_repeater_EU868;\n    phy_params.payloads_with_repeater.size = 8;\n\n    // dwell time setting\n    phy_params.ul_dwell_time_setting = 0;\n    phy_params.dl_dwell_time_setting = 0;\n\n    // set initial and default parameters\n    phy_params.duty_cycle_enabled = EU868_DUTY_CYCLE_ENABLED;\n    phy_params.accept_tx_param_setup_req = true;\n    phy_params.fsk_supported = true;\n    phy_params.cflist_supported = true;\n    phy_params.dl_channel_req_supported = true;\n    phy_params.custom_channelplans_supported = true;\n    phy_params.default_channel_cnt = EU868_NUMB_DEFAULT_CHANNELS;\n    phy_params.max_channel_cnt = EU868_MAX_NB_CHANNELS;\n    phy_params.cflist_channel_cnt = EU868_NUMB_CHANNELS_CF_LIST;\n    phy_params.min_tx_datarate = EU868_TX_MIN_DATARATE;\n    phy_params.max_tx_datarate = EU868_TX_MAX_DATARATE;\n    phy_params.min_rx_datarate = EU868_RX_MIN_DATARATE;\n    phy_params.max_rx_datarate = EU868_RX_MAX_DATARATE;\n    phy_params.default_datarate = EU868_DEFAULT_DATARATE;\n    phy_params.default_max_datarate = EU868_DEFAULT_MAX_DATARATE;\n    phy_params.min_rx1_dr_offset = EU868_MIN_RX1_DR_OFFSET;\n    phy_params.max_rx1_dr_offset = EU868_MAX_RX1_DR_OFFSET;\n    phy_params.default_rx1_dr_offset = EU868_DEFAULT_RX1_DR_OFFSET;\n    phy_params.min_tx_power = EU868_MIN_TX_POWER;\n    phy_params.max_tx_power = EU868_MAX_TX_POWER;\n    phy_params.default_tx_power = EU868_DEFAULT_TX_POWER;\n    phy_params.default_max_eirp = EU868_DEFAULT_MAX_EIRP;\n    phy_params.default_antenna_gain = EU868_DEFAULT_ANTENNA_GAIN;\n    phy_params.adr_ack_limit = EU868_ADR_ACK_LIMIT;\n    phy_params.adr_ack_delay = EU868_ADR_ACK_DELAY;\n    phy_params.max_rx_window = EU868_MAX_RX_WINDOW;\n    phy_params.recv_delay1 = EU868_RECEIVE_DELAY1;\n    phy_params.recv_delay2 = EU868_RECEIVE_DELAY2;\n    phy_params.join_channel_mask = EU868_JOIN_CHANNELS;\n    phy_params.join_accept_delay1 = EU868_JOIN_ACCEPT_DELAY1;\n    phy_params.join_accept_delay2 = EU868_JOIN_ACCEPT_DELAY2;\n    phy_params.max_fcnt_gap = EU868_MAX_FCNT_GAP;\n    phy_params.ack_timeout = EU868_ACKTIMEOUT;\n    phy_params.ack_timeout_rnd = EU868_ACK_TIMEOUT_RND;\n    phy_params.rx_window2_datarate = EU868_RX_WND_2_DR;\n    phy_params.rx_window2_frequency = EU868_RX_WND_2_FREQ;\n}\n\nLoRaPHYEU868::~LoRaPHYEU868()\n{\n}\n\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n\nDescription: Timer objects and scheduling management\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis and Gregory Cristian\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"lorawan/system/LoRaWANTimer.h\"\n\nLoRaWANTimeHandler::LoRaWANTimeHandler()\n    : _queue(NULL)\n{\n}\n\nLoRaWANTimeHandler::~LoRaWANTimeHandler()\n{\n}\n\nvoid LoRaWANTimeHandler::activate_timer_subsystem(events::EventQueue *queue)\n{\n    _queue = queue;\n}\n\nlorawan_time_t LoRaWANTimeHandler::get_current_time( void )\n{\n    const uint32_t current_time = _queue->tick();\n    return (lorawan_time_t)current_time;\n}\n\nlorawan_time_t LoRaWANTimeHandler::get_elapsed_time(lorawan_time_t saved_time)\n{\n    return get_current_time() - saved_time;\n}\n\nvoid LoRaWANTimeHandler::init(timer_event_t &obj, mbed::Callback<void()> callback)\n{\n    obj.callback = callback;\n    obj.timer_id = 0;\n}\n\nvoid LoRaWANTimeHandler::start(timer_event_t &obj, const uint32_t timeout)\n{\n    obj.timer_id = _queue->call_in(timeout, obj.callback);\n    MBED_ASSERT(obj.timer_id != 0);\n}\n\nvoid LoRaWANTimeHandler::stop(timer_event_t &obj)\n{\n    _queue->cancel(obj.timer_id);\n    obj.timer_id = 0;\n}\n","/**\n * \\file cipher.c\n *\n * \\brief Generic cipher wrapper for mbed TLS\n *\n * \\author Adriaan de Jong <dejong@fox-it.com>\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CIPHER_C)\n\n#include \"mbedtls/cipher.h\"\n#include \"mbedtls/cipher_internal.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(MBEDTLS_GCM_C)\n#include \"mbedtls/gcm.h\"\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n#include \"mbedtls/ccm.h\"\n#endif\n\n#if defined(MBEDTLS_CMAC_C)\n#include \"mbedtls/cmac.h\"\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#define mbedtls_calloc calloc\n#define mbedtls_free   free\n#endif\n\n#if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)\n#define MBEDTLS_CIPHER_MODE_STREAM\n#endif\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;\n}\n\nstatic int supported_init = 0;\n\nconst int *mbedtls_cipher_list( void )\n{\n    const mbedtls_cipher_definition_t *def;\n    int *type;\n\n    if( ! supported_init )\n    {\n        def = mbedtls_cipher_definitions;\n        type = mbedtls_cipher_supported;\n\n        while( def->type != 0 )\n            *type++ = (*def++).type;\n\n        *type = 0;\n\n        supported_init = 1;\n    }\n\n    return( mbedtls_cipher_supported );\n}\n\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )\n        if( def->type == cipher_type )\n            return( def->info );\n\n    return( NULL );\n}\n\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    if( NULL == cipher_name )\n        return( NULL );\n\n    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )\n        if( !  strcmp( def->info->name, cipher_name ) )\n            return( def->info );\n\n    return( NULL );\n}\n\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,\n                                              int key_bitlen,\n                                              const mbedtls_cipher_mode_t mode )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )\n        if( def->info->base->cipher == cipher_id &&\n            def->info->key_bitlen == (unsigned) key_bitlen &&\n            def->info->mode == mode )\n            return( def->info );\n\n    return( NULL );\n}\n\nvoid mbedtls_cipher_init( mbedtls_cipher_context_t *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );\n}\n\nvoid mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n#if defined(MBEDTLS_CMAC_C)\n    if( ctx->cmac_ctx )\n    {\n       mbedtls_zeroize( ctx->cmac_ctx, sizeof( mbedtls_cmac_context_t ) );\n       mbedtls_free( ctx->cmac_ctx );\n    }\n#endif\n\n    if( ctx->cipher_ctx )\n        ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );\n\n    mbedtls_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );\n}\n\nint mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info )\n{\n    if( NULL == cipher_info || NULL == ctx )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );\n\n    if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )\n        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );\n\n    ctx->cipher_info = cipher_info;\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n    /*\n     * Ignore possible errors caused by a cipher mode that doesn't use padding\n     */\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );\n#else\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );\n#endif\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n    return( 0 );\n}\n\nint mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx, const unsigned char *key,\n        int key_bitlen, const mbedtls_operation_t operation )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&\n        (int) ctx->cipher_info->key_bitlen != key_bitlen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    ctx->key_bitlen = key_bitlen;\n    ctx->operation = operation;\n\n    /*\n     * For CFB and CTR mode always use the encryption key schedule\n     */\n    if( MBEDTLS_ENCRYPT == operation ||\n        MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_CTR == ctx->cipher_info->mode )\n    {\n        return ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,\n                ctx->key_bitlen );\n    }\n\n    if( MBEDTLS_DECRYPT == operation )\n        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,\n                ctx->key_bitlen );\n\n    return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n}\n\nint mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,\n                   const unsigned char *iv, size_t iv_len )\n{\n    size_t actual_iv_size;\n\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == iv )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    /* avoid buffer overflow in ctx->iv */\n    if( iv_len > MBEDTLS_MAX_IV_LENGTH )\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n\n    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )\n        actual_iv_size = iv_len;\n    else\n    {\n        actual_iv_size = ctx->cipher_info->iv_size;\n\n        /* avoid reading past the end of input buffer */\n        if( actual_iv_size > iv_len )\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    memcpy( ctx->iv, iv, actual_iv_size );\n    ctx->iv_size = actual_iv_size;\n\n    return( 0 );\n}\n\nint mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    ctx->unprocessed_len = 0;\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_GCM_C)\nint mbedtls_cipher_update_ad( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *ad, size_t ad_len )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        return mbedtls_gcm_starts( (mbedtls_gcm_context *) ctx->cipher_ctx, ctx->operation,\n                           ctx->iv, ctx->iv_size, ad, ad_len );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_GCM_C */\n\nint mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t block_size = 0;\n\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    *olen = 0;\n    block_size = mbedtls_cipher_get_block_size( ctx );\n\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )\n    {\n        if( ilen != block_size )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        *olen = ilen;\n\n        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,\n                    ctx->operation, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_GCM_C)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )\n    {\n        *olen = ilen;\n        return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,\n                           output );\n    }\n#endif\n\n    if ( 0 == block_size )\n    {\n        return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;\n    }\n\n    if( input == output &&\n       ( ctx->unprocessed_len != 0 || ilen % block_size ) )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )\n    {\n        size_t copy_len = 0;\n\n        /*\n         * If there is not enough data for a full block, cache it.\n         */\n        if( ( ctx->operation == MBEDTLS_DECRYPT &&\n                ilen <= block_size - ctx->unprocessed_len ) ||\n             ( ctx->operation == MBEDTLS_ENCRYPT &&\n                ilen < block_size - ctx->unprocessed_len ) )\n        {\n            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,\n                    ilen );\n\n            ctx->unprocessed_len += ilen;\n            return( 0 );\n        }\n\n        /*\n         * Process cached data first\n         */\n        if( 0 != ctx->unprocessed_len )\n        {\n            copy_len = block_size - ctx->unprocessed_len;\n\n            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,\n                    copy_len );\n\n            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                    ctx->operation, block_size, ctx->iv,\n                    ctx->unprocessed_data, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += block_size;\n            output += block_size;\n            ctx->unprocessed_len = 0;\n\n            input += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Cache final, incomplete block\n         */\n        if( 0 != ilen )\n        {\n            if( 0 == block_size )\n            {\n                return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;\n            }\n\n            copy_len = ilen % block_size;\n            if( copy_len == 0 && ctx->operation == MBEDTLS_DECRYPT )\n                copy_len = block_size;\n\n            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),\n                    copy_len );\n\n            ctx->unprocessed_len += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Process remaining full blocks\n         */\n        if( ilen )\n        {\n            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                    ctx->operation, ilen, ctx->iv, input, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += ilen;\n        }\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CFB )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,\n                ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,\n                input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_CTR )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,\n                ilen, &ctx->unprocessed_len, ctx->iv,\n                ctx->unprocessed_data, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    if( ctx->cipher_info->mode == MBEDTLS_MODE_STREAM )\n    {\n        if( 0 != ( ret = ctx->cipher_info->base->stream_func( ctx->cipher_ctx,\n                                                    ilen, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_STREAM */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n/*\n * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len\n */\nstatic void add_pkcs_padding( unsigned char *output, size_t output_len,\n        size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i;\n\n    for( i = 0; i < padding_len; i++ )\n        output[data_len + i] = (unsigned char) padding_len;\n}\n\nstatic int get_pkcs_padding( unsigned char *input, size_t input_len,\n        size_t *data_len )\n{\n    size_t i, pad_idx;\n    unsigned char padding_len, bad = 0;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    padding_len = input[input_len - 1];\n    *data_len = input_len - padding_len;\n\n    /* Avoid logical || since it results in a branch */\n    bad |= padding_len > input_len;\n    bad |= padding_len == 0;\n\n    /* The number of bytes checked must be independent of padding_len,\n     * so pick input_len, which is usually 8 or 16 (one block) */\n    pad_idx = input_len - padding_len;\n    for( i = 0; i < input_len; i++ )\n        bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n}\n#endif /* MBEDTLS_CIPHER_PADDING_PKCS7 */\n\n#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)\n/*\n * One and zeros padding: fill with 80 00 ... 00\n */\nstatic void add_one_and_zeros_padding( unsigned char *output,\n                                       size_t output_len, size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i = 0;\n\n    output[data_len] = 0x80;\n    for( i = 1; i < padding_len; i++ )\n        output[data_len + i] = 0x00;\n}\n\nstatic int get_one_and_zeros_padding( unsigned char *input, size_t input_len,\n                                      size_t *data_len )\n{\n    size_t i;\n    unsigned char done = 0, prev_done, bad;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    bad = 0x80;\n    *data_len = 0;\n    for( i = input_len; i > 0; i-- )\n    {\n        prev_done = done;\n        done |= ( input[i - 1] != 0 );\n        *data_len |= ( i - 1 ) * ( done != prev_done );\n        bad ^= input[i - 1] * ( done != prev_done );\n    }\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n\n}\n#endif /* MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS */\n\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)\n/*\n * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length\n */\nstatic void add_zeros_and_len_padding( unsigned char *output,\n                                       size_t output_len, size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i = 0;\n\n    for( i = 1; i < padding_len; i++ )\n        output[data_len + i - 1] = 0x00;\n    output[output_len - 1] = (unsigned char) padding_len;\n}\n\nstatic int get_zeros_and_len_padding( unsigned char *input, size_t input_len,\n                                      size_t *data_len )\n{\n    size_t i, pad_idx;\n    unsigned char padding_len, bad = 0;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    padding_len = input[input_len - 1];\n    *data_len = input_len - padding_len;\n\n    /* Avoid logical || since it results in a branch */\n    bad |= padding_len > input_len;\n    bad |= padding_len == 0;\n\n    /* The number of bytes checked must be independent of padding_len */\n    pad_idx = input_len - padding_len;\n    for( i = 0; i < input_len - 1; i++ )\n        bad |= input[i] * ( i >= pad_idx );\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n}\n#endif /* MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN */\n\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)\n/*\n * Zero padding: fill with 00 ... 00\n */\nstatic void add_zeros_padding( unsigned char *output,\n                               size_t output_len, size_t data_len )\n{\n    size_t i;\n\n    for( i = data_len; i < output_len; i++ )\n        output[i] = 0x00;\n}\n\nstatic int get_zeros_padding( unsigned char *input, size_t input_len,\n                              size_t *data_len )\n{\n    size_t i;\n    unsigned char done = 0, prev_done;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *data_len = 0;\n    for( i = input_len; i > 0; i-- )\n    {\n        prev_done = done;\n        done |= ( input[i-1] != 0 );\n        *data_len |= i * ( done != prev_done );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_PADDING_ZEROS */\n\n/*\n * No padding: don't pad :)\n *\n * There is no add_padding function (check for NULL in mbedtls_cipher_finish)\n * but a trivial get_padding function\n */\nstatic int get_no_padding( unsigned char *input, size_t input_len,\n                              size_t *data_len )\n{\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *data_len = input_len;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\nint mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,\n                   unsigned char *output, size_t *olen )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *olen = 0;\n\n    if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||\n        MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )\n    {\n        return( 0 );\n    }\n\n    if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )\n    {\n        if( ctx->unprocessed_len != 0 )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( MBEDTLS_MODE_CBC == ctx->cipher_info->mode )\n    {\n        int ret = 0;\n\n        if( MBEDTLS_ENCRYPT == ctx->operation )\n        {\n            /* check for 'no padding' mode */\n            if( NULL == ctx->add_padding )\n            {\n                if( 0 != ctx->unprocessed_len )\n                    return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n                return( 0 );\n            }\n\n            ctx->add_padding( ctx->unprocessed_data, mbedtls_cipher_get_iv_size( ctx ),\n                    ctx->unprocessed_len );\n        }\n        else if( mbedtls_cipher_get_block_size( ctx ) != ctx->unprocessed_len )\n        {\n            /*\n             * For decrypt operations, expect a full block,\n             * or an empty block if no padding\n             */\n            if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )\n                return( 0 );\n\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n        }\n\n        /* cipher block */\n        if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,\n                ctx->operation, mbedtls_cipher_get_block_size( ctx ), ctx->iv,\n                ctx->unprocessed_data, output ) ) )\n        {\n            return( ret );\n        }\n\n        /* Set output size for decryption */\n        if( MBEDTLS_DECRYPT == ctx->operation )\n            return ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),\n                                     olen );\n\n        /* Set output size for encryption */\n        *olen = mbedtls_cipher_get_block_size( ctx );\n        return( 0 );\n    }\n#else\n    ((void) output);\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\nint mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode )\n{\n    if( NULL == ctx ||\n        MBEDTLS_MODE_CBC != ctx->cipher_info->mode )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    switch( mode )\n    {\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    case MBEDTLS_PADDING_PKCS7:\n        ctx->add_padding = add_pkcs_padding;\n        ctx->get_padding = get_pkcs_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)\n    case MBEDTLS_PADDING_ONE_AND_ZEROS:\n        ctx->add_padding = add_one_and_zeros_padding;\n        ctx->get_padding = get_one_and_zeros_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)\n    case MBEDTLS_PADDING_ZEROS_AND_LEN:\n        ctx->add_padding = add_zeros_and_len_padding;\n        ctx->get_padding = get_zeros_and_len_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)\n    case MBEDTLS_PADDING_ZEROS:\n        ctx->add_padding = add_zeros_padding;\n        ctx->get_padding = get_zeros_padding;\n        break;\n#endif\n    case MBEDTLS_PADDING_NONE:\n        ctx->add_padding = NULL;\n        ctx->get_padding = get_no_padding;\n        break;\n\n    default:\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n#if defined(MBEDTLS_GCM_C)\nint mbedtls_cipher_write_tag( mbedtls_cipher_context_t *ctx,\n                      unsigned char *tag, size_t tag_len )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info || NULL == tag )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( MBEDTLS_ENCRYPT != ctx->operation )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n        return mbedtls_gcm_finish( (mbedtls_gcm_context *) ctx->cipher_ctx, tag, tag_len );\n\n    return( 0 );\n}\n\nint mbedtls_cipher_check_tag( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *tag, size_t tag_len )\n{\n    int ret;\n\n    if( NULL == ctx || NULL == ctx->cipher_info ||\n        MBEDTLS_DECRYPT != ctx->operation )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        unsigned char check_tag[16];\n        size_t i;\n        int diff;\n\n        if( tag_len > sizeof( check_tag ) )\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n        if( 0 != ( ret = mbedtls_gcm_finish( (mbedtls_gcm_context *) ctx->cipher_ctx,\n                                     check_tag, tag_len ) ) )\n        {\n            return( ret );\n        }\n\n        /* Check the tag in \"constant-time\" */\n        for( diff = 0, i = 0; i < tag_len; i++ )\n            diff |= tag[i] ^ check_tag[i];\n\n        if( diff != 0 )\n            return( MBEDTLS_ERR_CIPHER_AUTH_FAILED );\n\n        return( 0 );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_GCM_C */\n\n/*\n * Packet-oriented wrapper for non-AEAD modes\n */\nint mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t finish_olen;\n\n    if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, &finish_olen ) ) != 0 )\n        return( ret );\n\n    *olen += finish_olen;\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_AEAD)\n/*\n * Packet-oriented encryption for AEAD modes\n */\nint mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         unsigned char *tag, size_t tag_len )\n{\n#if defined(MBEDTLS_GCM_C)\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        *olen = ilen;\n        return( mbedtls_gcm_crypt_and_tag( ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT, ilen,\n                                   iv, iv_len, ad, ad_len, input, output,\n                                   tag_len, tag ) );\n    }\n#endif /* MBEDTLS_GCM_C */\n#if defined(MBEDTLS_CCM_C)\n    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )\n    {\n        *olen = ilen;\n        return( mbedtls_ccm_encrypt_and_tag( ctx->cipher_ctx, ilen,\n                                     iv, iv_len, ad, ad_len, input, output,\n                                     tag, tag_len ) );\n    }\n#endif /* MBEDTLS_CCM_C */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n\n/*\n * Packet-oriented decryption for AEAD modes\n */\nint mbedtls_cipher_auth_decrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         const unsigned char *tag, size_t tag_len )\n{\n#if defined(MBEDTLS_GCM_C)\n    if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )\n    {\n        int ret;\n\n        *olen = ilen;\n        ret = mbedtls_gcm_auth_decrypt( ctx->cipher_ctx, ilen,\n                                iv, iv_len, ad, ad_len,\n                                tag, tag_len, input, output );\n\n        if( ret == MBEDTLS_ERR_GCM_AUTH_FAILED )\n            ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;\n\n        return( ret );\n    }\n#endif /* MBEDTLS_GCM_C */\n#if defined(MBEDTLS_CCM_C)\n    if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )\n    {\n        int ret;\n\n        *olen = ilen;\n        ret = mbedtls_ccm_auth_decrypt( ctx->cipher_ctx, ilen,\n                                iv, iv_len, ad, ad_len,\n                                input, output, tag, tag_len );\n\n        if( ret == MBEDTLS_ERR_CCM_AUTH_FAILED )\n            ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;\n\n        return( ret );\n    }\n#endif /* MBEDTLS_CCM_C */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}\n#endif /* MBEDTLS_CIPHER_MODE_AEAD */\n\n#endif /* MBEDTLS_CIPHER_C */\n","/**\n * \\file cipher.h\n *\n * \\brief The generic cipher wrapper.\n *\n * \\author Adriaan de Jong <dejong@fox-it.com>\n */\n/*\n *  Copyright (C) 2006-2018, Arm Limited (or its affiliates), All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of Mbed TLS (https://tls.mbed.org)\n */\n\n#ifndef MBEDTLS_CIPHER_H\n#define MBEDTLS_CIPHER_H\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#include <stddef.h>\n\n#if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CCM_C)\n#define MBEDTLS_CIPHER_MODE_AEAD\n#endif\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n#define MBEDTLS_CIPHER_MODE_WITH_PADDING\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n#define MBEDTLS_CIPHER_MODE_STREAM\n#endif\n\n#if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) && \\\n    !defined(inline) && !defined(__cplusplus)\n#define inline __inline\n#endif\n\n#define MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE  -0x6080  /**< The selected feature is not available. */\n#define MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA       -0x6100  /**< Bad input parameters. */\n#define MBEDTLS_ERR_CIPHER_ALLOC_FAILED         -0x6180  /**< Failed to allocate memory. */\n#define MBEDTLS_ERR_CIPHER_INVALID_PADDING      -0x6200  /**< Input data contains invalid padding and is rejected. */\n#define MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED  -0x6280  /**< Decryption of block requires a full block. */\n#define MBEDTLS_ERR_CIPHER_AUTH_FAILED          -0x6300  /**< Authentication failed (for AEAD modes). */\n#define MBEDTLS_ERR_CIPHER_INVALID_CONTEXT      -0x6380  /**< The context is invalid. For example, because it was freed. */\n#define MBEDTLS_ERR_CIPHER_HW_ACCEL_FAILED      -0x6400  /**< Cipher hardware accelerator failed. */\n\n#define MBEDTLS_CIPHER_VARIABLE_IV_LEN     0x01    /**< Cipher accepts IVs of variable length. */\n#define MBEDTLS_CIPHER_VARIABLE_KEY_LEN    0x02    /**< Cipher accepts keys of variable length. */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\brief     An enumeration of supported ciphers.\n *\n * \\warning   ARC4 and DES are considered weak ciphers and their use\n *            constitutes a security risk. We recommend considering stronger\n *            ciphers instead.\n */\ntypedef enum {\n    MBEDTLS_CIPHER_ID_NONE = 0,\n    MBEDTLS_CIPHER_ID_NULL,\n    MBEDTLS_CIPHER_ID_AES,\n    MBEDTLS_CIPHER_ID_DES,\n    MBEDTLS_CIPHER_ID_3DES,\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    MBEDTLS_CIPHER_ID_BLOWFISH,\n    MBEDTLS_CIPHER_ID_ARC4,\n} mbedtls_cipher_id_t;\n\n/**\n * \\brief     An enumeration of supported (cipher, mode) pairs.\n *\n * \\warning   ARC4 and DES are considered weak ciphers and their use\n *            constitutes a security risk. We recommend considering stronger\n *            ciphers instead.\n */\ntypedef enum {\n    MBEDTLS_CIPHER_NONE = 0,\n    MBEDTLS_CIPHER_NULL,\n    MBEDTLS_CIPHER_AES_128_ECB,\n    MBEDTLS_CIPHER_AES_192_ECB,\n    MBEDTLS_CIPHER_AES_256_ECB,\n    MBEDTLS_CIPHER_AES_128_CBC,\n    MBEDTLS_CIPHER_AES_192_CBC,\n    MBEDTLS_CIPHER_AES_256_CBC,\n    MBEDTLS_CIPHER_AES_128_CFB128,\n    MBEDTLS_CIPHER_AES_192_CFB128,\n    MBEDTLS_CIPHER_AES_256_CFB128,\n    MBEDTLS_CIPHER_AES_128_CTR,\n    MBEDTLS_CIPHER_AES_192_CTR,\n    MBEDTLS_CIPHER_AES_256_CTR,\n    MBEDTLS_CIPHER_AES_128_GCM,\n    MBEDTLS_CIPHER_AES_192_GCM,\n    MBEDTLS_CIPHER_AES_256_GCM,\n    MBEDTLS_CIPHER_CAMELLIA_128_ECB,\n    MBEDTLS_CIPHER_CAMELLIA_192_ECB,\n    MBEDTLS_CIPHER_CAMELLIA_256_ECB,\n    MBEDTLS_CIPHER_CAMELLIA_128_CBC,\n    MBEDTLS_CIPHER_CAMELLIA_192_CBC,\n    MBEDTLS_CIPHER_CAMELLIA_256_CBC,\n    MBEDTLS_CIPHER_CAMELLIA_128_CFB128,\n    MBEDTLS_CIPHER_CAMELLIA_192_CFB128,\n    MBEDTLS_CIPHER_CAMELLIA_256_CFB128,\n    MBEDTLS_CIPHER_CAMELLIA_128_CTR,\n    MBEDTLS_CIPHER_CAMELLIA_192_CTR,\n    MBEDTLS_CIPHER_CAMELLIA_256_CTR,\n    MBEDTLS_CIPHER_CAMELLIA_128_GCM,\n    MBEDTLS_CIPHER_CAMELLIA_192_GCM,\n    MBEDTLS_CIPHER_CAMELLIA_256_GCM,\n    MBEDTLS_CIPHER_DES_ECB,\n    MBEDTLS_CIPHER_DES_CBC,\n    MBEDTLS_CIPHER_DES_EDE_ECB,\n    MBEDTLS_CIPHER_DES_EDE_CBC,\n    MBEDTLS_CIPHER_DES_EDE3_ECB,\n    MBEDTLS_CIPHER_DES_EDE3_CBC,\n    MBEDTLS_CIPHER_BLOWFISH_ECB,\n    MBEDTLS_CIPHER_BLOWFISH_CBC,\n    MBEDTLS_CIPHER_BLOWFISH_CFB64,\n    MBEDTLS_CIPHER_BLOWFISH_CTR,\n    MBEDTLS_CIPHER_ARC4_128,\n    MBEDTLS_CIPHER_AES_128_CCM,\n    MBEDTLS_CIPHER_AES_192_CCM,\n    MBEDTLS_CIPHER_AES_256_CCM,\n    MBEDTLS_CIPHER_CAMELLIA_128_CCM,\n    MBEDTLS_CIPHER_CAMELLIA_192_CCM,\n    MBEDTLS_CIPHER_CAMELLIA_256_CCM,\n} mbedtls_cipher_type_t;\n\n/** Supported cipher modes. */\ntypedef enum {\n    MBEDTLS_MODE_NONE = 0,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_MODE_CFB,\n    MBEDTLS_MODE_OFB, /* Unused! */\n    MBEDTLS_MODE_CTR,\n    MBEDTLS_MODE_GCM,\n    MBEDTLS_MODE_STREAM,\n    MBEDTLS_MODE_CCM,\n} mbedtls_cipher_mode_t;\n\n/** Supported cipher padding types. */\ntypedef enum {\n    MBEDTLS_PADDING_PKCS7 = 0,     /**< PKCS7 padding (default).        */\n    MBEDTLS_PADDING_ONE_AND_ZEROS, /**< ISO/IEC 7816-4 padding.         */\n    MBEDTLS_PADDING_ZEROS_AND_LEN, /**< ANSI X.923 padding.             */\n    MBEDTLS_PADDING_ZEROS,         /**< zero padding (not reversible). */\n    MBEDTLS_PADDING_NONE,          /**< never pad (full blocks only).   */\n} mbedtls_cipher_padding_t;\n\n/** Type of operation. */\ntypedef enum {\n    MBEDTLS_OPERATION_NONE = -1,\n    MBEDTLS_DECRYPT = 0,\n    MBEDTLS_ENCRYPT,\n} mbedtls_operation_t;\n\nenum {\n    /** Undefined key length. */\n    MBEDTLS_KEY_LENGTH_NONE = 0,\n    /** Key length, in bits (including parity), for DES keys. */\n    MBEDTLS_KEY_LENGTH_DES  = 64,\n    /** Key length in bits, including parity, for DES in two-key EDE. */\n    MBEDTLS_KEY_LENGTH_DES_EDE = 128,\n    /** Key length in bits, including parity, for DES in three-key EDE. */\n    MBEDTLS_KEY_LENGTH_DES_EDE3 = 192,\n};\n\n/** Maximum length of any IV, in Bytes. */\n#define MBEDTLS_MAX_IV_LENGTH      16\n/** Maximum block size of any cipher, in Bytes. */\n#define MBEDTLS_MAX_BLOCK_LENGTH   16\n\n/**\n * Base cipher information (opaque struct).\n */\ntypedef struct mbedtls_cipher_base_t mbedtls_cipher_base_t;\n\n/**\n * CMAC context (opaque struct).\n */\ntypedef struct mbedtls_cmac_context_t mbedtls_cmac_context_t;\n\n/**\n * Cipher information. Allows calling cipher functions\n * in a generic way.\n */\ntypedef struct {\n    /** Full cipher identifier. For example,\n     * MBEDTLS_CIPHER_AES_256_CBC.\n     */\n    mbedtls_cipher_type_t type;\n\n    /** The cipher mode. For example, MBEDTLS_MODE_CBC. */\n    mbedtls_cipher_mode_t mode;\n\n    /** The cipher key length, in bits. This is the\n     * default length for variable sized ciphers.\n     * Includes parity bits for ciphers like DES.\n     */\n    unsigned int key_bitlen;\n\n    /** Name of the cipher. */\n    const char * name;\n\n    /** IV or nonce size, in Bytes.\n     * For ciphers that accept variable IV sizes,\n     * this is the recommended size.\n     */\n    unsigned int iv_size;\n\n    /** Flags to set. For example, if the cipher supports variable IV sizes or variable key sizes. */\n    int flags;\n\n    /** The block size, in Bytes. */\n    unsigned int block_size;\n\n    /** Struct for base cipher information and functions. */\n    const mbedtls_cipher_base_t *base;\n\n} mbedtls_cipher_info_t;\n\n/**\n * Generic cipher context.\n */\ntypedef struct {\n    /** Information about the associated cipher. */\n    const mbedtls_cipher_info_t *cipher_info;\n\n    /** Key length to use. */\n    int key_bitlen;\n\n    /** Operation that the key of the context has been\n     * initialized for.\n     */\n    mbedtls_operation_t operation;\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n    /** Padding functions to use, if relevant for\n     * the specific cipher mode.\n     */\n    void (*add_padding)( unsigned char *output, size_t olen, size_t data_len );\n    int (*get_padding)( unsigned char *input, size_t ilen, size_t *data_len );\n#endif\n\n    /** Buffer for input that has not been processed yet. */\n    unsigned char unprocessed_data[MBEDTLS_MAX_BLOCK_LENGTH];\n\n    /** Number of Bytes that have not been processed yet. */\n    size_t unprocessed_len;\n\n    /** Current IV or NONCE_COUNTER for CTR-mode. */\n    unsigned char iv[MBEDTLS_MAX_IV_LENGTH];\n\n    /** IV size in Bytes, for ciphers with variable-length IVs. */\n    size_t iv_size;\n\n    /** The cipher-specific context. */\n    void *cipher_ctx;\n\n#if defined(MBEDTLS_CMAC_C)\n    /** CMAC-specific context. */\n    mbedtls_cmac_context_t *cmac_ctx;\n#endif\n} mbedtls_cipher_context_t;\n\n/**\n * \\brief This function retrieves the list of ciphers supported by the generic\n * cipher module.\n *\n * \\return      A statically-allocated array of ciphers. The last entry\n *              is zero.\n */\nconst int *mbedtls_cipher_list( void );\n\n/**\n * \\brief               This function retrieves the cipher-information\n *                      structure associated with the given cipher name.\n *\n * \\param cipher_name   Name of the cipher to search for.\n *\n * \\return              The cipher information structure associated with the\n *                      given \\p cipher_name, or NULL if not found.\n */\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name );\n\n/**\n * \\brief               This function retrieves the cipher-information\n *                      structure associated with the given cipher type.\n *\n * \\param cipher_type   Type of the cipher to search for.\n *\n * \\return              The cipher information structure associated with the\n *                      given \\p cipher_type, or NULL if not found.\n */\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type );\n\n/**\n * \\brief               This function retrieves the cipher-information\n *                      structure associated with the given cipher ID,\n *                      key size and mode.\n *\n * \\param cipher_id     The ID of the cipher to search for. For example,\n *                      #MBEDTLS_CIPHER_ID_AES.\n * \\param key_bitlen    The length of the key in bits.\n * \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.\n *\n * \\return              The cipher information structure associated with the\n *                      given \\p cipher_id, or NULL if not found.\n */\nconst mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,\n                                              int key_bitlen,\n                                              const mbedtls_cipher_mode_t mode );\n\n/**\n * \\brief               This function initializes a \\p cipher_context as NONE.\n */\nvoid mbedtls_cipher_init( mbedtls_cipher_context_t *ctx );\n\n/**\n * \\brief               This function frees and clears the cipher-specific\n *                      context of \\p ctx. Freeing \\p ctx itself remains the\n *                      responsibility of the caller.\n */\nvoid mbedtls_cipher_free( mbedtls_cipher_context_t *ctx );\n\n\n/**\n * \\brief               This function initializes and fills the cipher-context\n *                      structure with the appropriate values. It also clears\n *                      the structure.\n *\n * \\param ctx           The context to initialize. May not be NULL.\n * \\param cipher_info   The cipher to use.\n *\n * \\return              \\c 0 on success,\n *                      #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on parameter failure,\n *                      #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the\n *                      cipher-specific context failed.\n *\n * \\internal Currently, the function also clears the structure.\n * In future versions, the caller will be required to call\n * mbedtls_cipher_init() on the structure first.\n */\nint mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info );\n\n/**\n * \\brief        This function returns the block size of the given cipher.\n *\n * \\param ctx    The context of the cipher. Must be initialized.\n *\n * \\return       The size of the blocks of the cipher, or zero if \\p ctx\n *               has not been initialized.\n */\nstatic inline unsigned int mbedtls_cipher_get_block_size( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return 0;\n\n    return ctx->cipher_info->block_size;\n}\n\n/**\n * \\brief        This function returns the mode of operation for\n *               the cipher. For example, MBEDTLS_MODE_CBC.\n *\n * \\param ctx    The context of the cipher. Must be initialized.\n *\n * \\return       The mode of operation, or #MBEDTLS_MODE_NONE if\n *               \\p ctx has not been initialized.\n */\nstatic inline mbedtls_cipher_mode_t mbedtls_cipher_get_cipher_mode( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_MODE_NONE;\n\n    return ctx->cipher_info->mode;\n}\n\n/**\n * \\brief       This function returns the size of the IV or nonce\n *              of the cipher, in Bytes.\n *\n * \\param ctx   The context of the cipher. Must be initialized.\n *\n * \\return      <ul><li>If no IV has been set: the recommended IV size.\n *              0 for ciphers not using IV or nonce.</li>\n *              <li>If IV has already been set: the actual size.</li></ul>\n */\nstatic inline int mbedtls_cipher_get_iv_size( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return 0;\n\n    if( ctx->iv_size != 0 )\n        return (int) ctx->iv_size;\n\n    return (int) ctx->cipher_info->iv_size;\n}\n\n/**\n * \\brief               This function returns the type of the given cipher.\n *\n * \\param ctx           The context of the cipher. Must be initialized.\n *\n * \\return              The type of the cipher, or #MBEDTLS_CIPHER_NONE if\n *                      \\p ctx has not been initialized.\n */\nstatic inline mbedtls_cipher_type_t mbedtls_cipher_get_type( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_CIPHER_NONE;\n\n    return ctx->cipher_info->type;\n}\n\n/**\n * \\brief               This function returns the name of the given cipher\n *                      as a string.\n *\n * \\param ctx           The context of the cipher. Must be initialized.\n *\n * \\return              The name of the cipher, or NULL if \\p ctx has not\n *                      been not initialized.\n */\nstatic inline const char *mbedtls_cipher_get_name( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return 0;\n\n    return ctx->cipher_info->name;\n}\n\n/**\n * \\brief               This function returns the key length of the cipher.\n *\n * \\param ctx           The context of the cipher. Must be initialized.\n *\n * \\return              The key length of the cipher in bits, or\n *                      #MBEDTLS_KEY_LENGTH_NONE if ctx \\p has not been\n *                      initialized.\n */\nstatic inline int mbedtls_cipher_get_key_bitlen( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_KEY_LENGTH_NONE;\n\n    return (int) ctx->cipher_info->key_bitlen;\n}\n\n/**\n * \\brief          This function returns the operation of the given cipher.\n *\n * \\param ctx      The context of the cipher. Must be initialized.\n *\n * \\return         The type of operation: #MBEDTLS_ENCRYPT or\n *                 #MBEDTLS_DECRYPT, or #MBEDTLS_OPERATION_NONE if \\p ctx\n *                 has not been initialized.\n */\nstatic inline mbedtls_operation_t mbedtls_cipher_get_operation( const mbedtls_cipher_context_t *ctx )\n{\n    if( NULL == ctx || NULL == ctx->cipher_info )\n        return MBEDTLS_OPERATION_NONE;\n\n    return ctx->operation;\n}\n\n/**\n * \\brief               This function sets the key to use with the given context.\n *\n * \\param ctx           The generic cipher context. May not be NULL. Must have\n *                      been initialized using mbedtls_cipher_info_from_type()\n *                      or mbedtls_cipher_info_from_string().\n * \\param key           The key to use.\n * \\param key_bitlen    The key length to use, in bits.\n * \\param operation     The operation that the key will be used for:\n *                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.\n *\n * \\returns             \\c 0 on success, #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if\n *                      parameter verification fails, or a cipher-specific\n *                      error code.\n */\nint mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx, const unsigned char *key,\n                   int key_bitlen, const mbedtls_operation_t operation );\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n/**\n * \\brief               This function sets the padding mode, for cipher modes\n *                      that use padding.\n *\n *                      The default passing mode is PKCS7 padding.\n *\n * \\param ctx           The generic cipher context.\n * \\param mode          The padding mode.\n *\n * \\returns             \\c 0 on success, #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE\n *                      if the selected padding mode is not supported, or\n *                      #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode\n *                      does not support padding.\n */\nint mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode );\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n/**\n * \\brief           This function sets the initialization vector (IV)\n *                  or nonce.\n *\n * \\param ctx       The generic cipher context.\n * \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len    The IV length for ciphers with variable-size IV.\n *                  This parameter is discarded by ciphers with fixed-size IV.\n *\n * \\returns         \\c 0 on success, or #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA\n *\n * \\note            Some ciphers do not use IVs nor nonce. For these\n *                  ciphers, this function has no effect.\n */\nint mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,\n                   const unsigned char *iv, size_t iv_len );\n\n/**\n * \\brief         This function resets the cipher state.\n *\n * \\param ctx     The generic cipher context.\n *\n * \\returns       \\c 0 on success, #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA\n *                if parameter verification fails.\n */\nint mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx );\n\n#if defined(MBEDTLS_GCM_C)\n/**\n * \\brief               This function adds additional data for AEAD ciphers.\n *                      Only supported with GCM. Must be called\n *                      exactly once, after mbedtls_cipher_reset().\n *\n * \\param ctx           The generic cipher context.\n * \\param ad            The additional data to use.\n * \\param ad_len        the Length of \\p ad.\n *\n * \\return              \\c 0 on success, or a specific error code on failure.\n */\nint mbedtls_cipher_update_ad( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *ad, size_t ad_len );\n#endif /* MBEDTLS_GCM_C */\n\n/**\n * \\brief               The generic cipher update function. It encrypts or\n *                      decrypts using the given cipher context. Writes as\n *                      many block-sized blocks of data as possible to output.\n *                      Any data that cannot be written immediately is either\n *                      added to the next block, or flushed when\n *                      mbedtls_cipher_finish() is called.\n *                      Exception: For MBEDTLS_MODE_ECB, expects a single block\n *                      in size. For example, 16 Bytes for AES.\n *\n * \\param ctx           The generic cipher context.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data. Must be able to hold at\n *                      least \\p ilen + block_size. Must not be the same buffer\n *                      as input.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n *\n * \\returns             \\c 0 on success, #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if\n *                      parameter verification fails,\n *                      #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an\n *                      unsupported mode for a cipher, or a cipher-specific\n *                      error code.\n *\n * \\note                If the underlying cipher is GCM, all calls to this\n *                      function, except the last one before\n *                      mbedtls_cipher_finish(). Must have \\p ilen as a\n *                      multiple of the block_size.\n */\nint mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen );\n\n/**\n * \\brief               The generic cipher finalization function. If data still\n *                      needs to be flushed from an incomplete block, the data\n *                      contained in it is padded to the size of\n *                      the last block, and written to the \\p output buffer.\n *\n * \\param ctx           The generic cipher context.\n * \\param output        The buffer to write data to. Needs block_size available.\n * \\param olen          The length of the data written to the \\p output buffer.\n *\n * \\returns             \\c 0 on success, #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if\n *                      parameter verification fails,\n *                      #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED if decryption\n *                      expected a full block but was not provided one,\n *                      #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n *                      while decrypting, or a cipher-specific error code\n *                      on failure for any other reason.\n */\nint mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,\n                   unsigned char *output, size_t *olen );\n\n#if defined(MBEDTLS_GCM_C)\n/**\n * \\brief               This function writes a tag for AEAD ciphers.\n *                      Only supported with GCM.\n *                      Must be called after mbedtls_cipher_finish().\n *\n * \\param ctx           The generic cipher context.\n * \\param tag           The buffer to write the tag to.\n * \\param tag_len       The length of the tag to write.\n *\n * \\return              \\c 0 on success, or a specific error code on failure.\n */\nint mbedtls_cipher_write_tag( mbedtls_cipher_context_t *ctx,\n                      unsigned char *tag, size_t tag_len );\n\n/**\n * \\brief               This function checks the tag for AEAD ciphers.\n *                      Only supported with GCM.\n *                      Must be called after mbedtls_cipher_finish().\n *\n * \\param ctx           The generic cipher context.\n * \\param tag           The buffer holding the tag.\n * \\param tag_len       The length of the tag to check.\n *\n * \\return              \\c 0 on success, or a specific error code on failure.\n */\nint mbedtls_cipher_check_tag( mbedtls_cipher_context_t *ctx,\n                      const unsigned char *tag, size_t tag_len );\n#endif /* MBEDTLS_GCM_C */\n\n/**\n * \\brief               The generic all-in-one encryption/decryption function,\n *                      for all ciphers except AEAD constructs.\n *\n * \\param ctx           The generic cipher context.\n * \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len        The IV length for ciphers with variable-size IV.\n *                      This parameter is discarded by ciphers with fixed-size\n *                      IV.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data. Must be able to hold at\n *                      least \\p ilen + block_size. Must not be the same buffer\n *                      as input.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n *\n * \\note                Some ciphers do not use IVs nor nonce. For these\n *                      ciphers, use \\p iv = NULL and \\p iv_len = 0.\n *\n * \\returns             \\c 0 on success, or\n *                      #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA, or\n *                      #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED if decryption\n *                      expected a full block but was not provided one, or\n *                      #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n *                      while decrypting, or a cipher-specific error code on\n *                      failure for any other reason.\n */\nint mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen );\n\n#if defined(MBEDTLS_CIPHER_MODE_AEAD)\n/**\n * \\brief               The generic autenticated encryption (AEAD) function.\n *\n * \\param ctx           The generic cipher context.\n * \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len        The IV length for ciphers with variable-size IV.\n *                      This parameter is discarded by ciphers with fixed-size IV.\n * \\param ad            The additional data to authenticate.\n * \\param ad_len        The length of \\p ad.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data.\n *                      Must be able to hold at least \\p ilen.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n * \\param tag           The buffer for the authentication tag.\n * \\param tag_len       The desired length of the authentication tag.\n *\n * \\returns             \\c 0 on success, or\n *                      #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA, or\n *                      a cipher-specific error code.\n */\nint mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         unsigned char *tag, size_t tag_len );\n\n/**\n * \\brief               The generic autenticated decryption (AEAD) function.\n *\n * \\param ctx           The generic cipher context.\n * \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n * \\param iv_len        The IV length for ciphers with variable-size IV.\n *                      This parameter is discarded by ciphers with fixed-size IV.\n * \\param ad            The additional data to be authenticated.\n * \\param ad_len        The length of \\p ad.\n * \\param input         The buffer holding the input data.\n * \\param ilen          The length of the input data.\n * \\param output        The buffer for the output data.\n *                      Must be able to hold at least \\p ilen.\n * \\param olen          The length of the output data, to be updated with the\n *                      actual number of Bytes written.\n * \\param tag           The buffer holding the authentication tag.\n * \\param tag_len       The length of the authentication tag.\n *\n * \\returns             \\c 0 on success, or\n *                      #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA, or\n *                      #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic,\n *                      or a cipher-specific error code on failure for any other reason.\n *\n * \\note                If the data is not authentic, then the output buffer\n *                      is zeroed out to prevent the unauthentic plaintext being\n *                      used, making this interface safer.\n */\nint mbedtls_cipher_auth_decrypt( mbedtls_cipher_context_t *ctx,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *ad, size_t ad_len,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output, size_t *olen,\n                         const unsigned char *tag, size_t tag_len );\n#endif /* MBEDTLS_CIPHER_MODE_AEAD */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* MBEDTLS_CIPHER_H */\n","/**\n * \\file cipher_wrap.c\n *\n * \\brief Generic cipher wrapper for mbed TLS\n *\n * \\author Adriaan de Jong <dejong@fox-it.com>\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CIPHER_C)\n\n#include \"mbedtls/cipher_internal.h\"\n\n#if defined(MBEDTLS_AES_C)\n#include \"mbedtls/aes.h\"\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n#include \"mbedtls/arc4.h\"\n#endif\n\n#if defined(MBEDTLS_CAMELLIA_C)\n#include \"mbedtls/camellia.h\"\n#endif\n\n#if defined(MBEDTLS_DES_C)\n#include \"mbedtls/des.h\"\n#endif\n\n#if defined(MBEDTLS_BLOWFISH_C)\n#include \"mbedtls/blowfish.h\"\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n#include \"mbedtls/gcm.h\"\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n#include \"mbedtls/ccm.h\"\n#endif\n\n#if defined(MBEDTLS_CIPHER_NULL_CIPHER)\n#include <string.h>\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc    calloc\n#define mbedtls_free       free\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n/* shared by all GCM ciphers */\nstatic void *gcm_ctx_alloc( void )\n{\n    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_gcm_context ) );\n\n    if( ctx != NULL )\n        mbedtls_gcm_init( (mbedtls_gcm_context *) ctx );\n\n    return( ctx );\n}\n\nstatic void gcm_ctx_free( void *ctx )\n{\n    mbedtls_gcm_free( ctx );\n    mbedtls_free( ctx );\n}\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\n/* shared by all CCM ciphers */\nstatic void *ccm_ctx_alloc( void )\n{\n    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ccm_context ) );\n\n    if( ctx != NULL )\n        mbedtls_ccm_init( (mbedtls_ccm_context *) ctx );\n\n    return( ctx );\n}\n\nstatic void ccm_ctx_free( void *ctx )\n{\n    mbedtls_ccm_free( ctx );\n    mbedtls_free( ctx );\n}\n#endif /* MBEDTLS_CCM_C */\n\n#if defined(MBEDTLS_AES_C)\n\nstatic int aes_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_ecb( (mbedtls_aes_context *) ctx, operation, input, output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int aes_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,\n        unsigned char *iv, const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_cbc( (mbedtls_aes_context *) ctx, operation, length, iv, input,\n                          output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int aes_crypt_cfb128_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_cfb128( (mbedtls_aes_context *) ctx, operation, length, iv_off, iv,\n                             input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int aes_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_aes_crypt_ctr( (mbedtls_aes_context *) ctx, length, nc_off, nonce_counter,\n                          stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int aes_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_aes_setkey_dec( (mbedtls_aes_context *) ctx, key, key_bitlen );\n}\n\nstatic int aes_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_aes_setkey_enc( (mbedtls_aes_context *) ctx, key, key_bitlen );\n}\n\nstatic void * aes_ctx_alloc( void )\n{\n    mbedtls_aes_context *aes = mbedtls_calloc( 1, sizeof( mbedtls_aes_context ) );\n\n    if( aes == NULL )\n        return( NULL );\n\n    mbedtls_aes_init( aes );\n\n    return( aes );\n}\n\nstatic void aes_ctx_free( void *ctx )\n{\n    mbedtls_aes_free( (mbedtls_aes_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t aes_info = {\n    MBEDTLS_CIPHER_ID_AES,\n    aes_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    aes_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    aes_crypt_cfb128_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    aes_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    aes_setkey_enc_wrap,\n    aes_setkey_dec_wrap,\n    aes_ctx_alloc,\n    aes_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t aes_128_ecb_info = {\n    MBEDTLS_CIPHER_AES_128_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"AES-128-ECB\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_ecb_info = {\n    MBEDTLS_CIPHER_AES_192_ECB,\n    MBEDTLS_MODE_ECB,\n    192,\n    \"AES-192-ECB\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_ecb_info = {\n    MBEDTLS_CIPHER_AES_256_ECB,\n    MBEDTLS_MODE_ECB,\n    256,\n    \"AES-256-ECB\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t aes_128_cbc_info = {\n    MBEDTLS_CIPHER_AES_128_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"AES-128-CBC\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_cbc_info = {\n    MBEDTLS_CIPHER_AES_192_CBC,\n    MBEDTLS_MODE_CBC,\n    192,\n    \"AES-192-CBC\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_cbc_info = {\n    MBEDTLS_CIPHER_AES_256_CBC,\n    MBEDTLS_MODE_CBC,\n    256,\n    \"AES-256-CBC\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t aes_128_cfb128_info = {\n    MBEDTLS_CIPHER_AES_128_CFB128,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"AES-128-CFB128\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_cfb128_info = {\n    MBEDTLS_CIPHER_AES_192_CFB128,\n    MBEDTLS_MODE_CFB,\n    192,\n    \"AES-192-CFB128\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_cfb128_info = {\n    MBEDTLS_CIPHER_AES_256_CFB128,\n    MBEDTLS_MODE_CFB,\n    256,\n    \"AES-256-CFB128\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t aes_128_ctr_info = {\n    MBEDTLS_CIPHER_AES_128_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"AES-128-CTR\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_ctr_info = {\n    MBEDTLS_CIPHER_AES_192_CTR,\n    MBEDTLS_MODE_CTR,\n    192,\n    \"AES-192-CTR\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_ctr_info = {\n    MBEDTLS_CIPHER_AES_256_CTR,\n    MBEDTLS_MODE_CTR,\n    256,\n    \"AES-256-CTR\",\n    16,\n    0,\n    16,\n    &aes_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_GCM_C)\nstatic int gcm_aes_setkey_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_AES,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t gcm_aes_info = {\n    MBEDTLS_CIPHER_ID_AES,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    gcm_aes_setkey_wrap,\n    gcm_aes_setkey_wrap,\n    gcm_ctx_alloc,\n    gcm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t aes_128_gcm_info = {\n    MBEDTLS_CIPHER_AES_128_GCM,\n    MBEDTLS_MODE_GCM,\n    128,\n    \"AES-128-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_gcm_info = {\n    MBEDTLS_CIPHER_AES_192_GCM,\n    MBEDTLS_MODE_GCM,\n    192,\n    \"AES-192-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_gcm_info = {\n    MBEDTLS_CIPHER_AES_256_GCM,\n    MBEDTLS_MODE_GCM,\n    256,\n    \"AES-256-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_aes_info\n};\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\nstatic int ccm_aes_setkey_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_AES,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t ccm_aes_info = {\n    MBEDTLS_CIPHER_ID_AES,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    ccm_aes_setkey_wrap,\n    ccm_aes_setkey_wrap,\n    ccm_ctx_alloc,\n    ccm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t aes_128_ccm_info = {\n    MBEDTLS_CIPHER_AES_128_CCM,\n    MBEDTLS_MODE_CCM,\n    128,\n    \"AES-128-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_192_ccm_info = {\n    MBEDTLS_CIPHER_AES_192_CCM,\n    MBEDTLS_MODE_CCM,\n    192,\n    \"AES-192-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aes_info\n};\n\nstatic const mbedtls_cipher_info_t aes_256_ccm_info = {\n    MBEDTLS_CIPHER_AES_256_CCM,\n    MBEDTLS_MODE_CCM,\n    256,\n    \"AES-256-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_aes_info\n};\n#endif /* MBEDTLS_CCM_C */\n\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n\nstatic int camellia_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_ecb( (mbedtls_camellia_context *) ctx, operation, input,\n                               output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int camellia_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_cbc( (mbedtls_camellia_context *) ctx, operation, length, iv,\n                               input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int camellia_crypt_cfb128_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_cfb128( (mbedtls_camellia_context *) ctx, operation, length,\n                                  iv_off, iv, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int camellia_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_camellia_crypt_ctr( (mbedtls_camellia_context *) ctx, length, nc_off,\n                               nonce_counter, stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int camellia_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_camellia_setkey_dec( (mbedtls_camellia_context *) ctx, key, key_bitlen );\n}\n\nstatic int camellia_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_camellia_setkey_enc( (mbedtls_camellia_context *) ctx, key, key_bitlen );\n}\n\nstatic void * camellia_ctx_alloc( void )\n{\n    mbedtls_camellia_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_camellia_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_camellia_init( ctx );\n\n    return( ctx );\n}\n\nstatic void camellia_ctx_free( void *ctx )\n{\n    mbedtls_camellia_free( (mbedtls_camellia_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t camellia_info = {\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    camellia_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    camellia_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    camellia_crypt_cfb128_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    camellia_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    camellia_setkey_enc_wrap,\n    camellia_setkey_dec_wrap,\n    camellia_ctx_alloc,\n    camellia_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t camellia_128_ecb_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"CAMELLIA-128-ECB\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_ecb_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_ECB,\n    MBEDTLS_MODE_ECB,\n    192,\n    \"CAMELLIA-192-ECB\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_ecb_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_ECB,\n    MBEDTLS_MODE_ECB,\n    256,\n    \"CAMELLIA-256-ECB\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t camellia_128_cbc_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"CAMELLIA-128-CBC\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_cbc_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CBC,\n    MBEDTLS_MODE_CBC,\n    192,\n    \"CAMELLIA-192-CBC\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_cbc_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CBC,\n    MBEDTLS_MODE_CBC,\n    256,\n    \"CAMELLIA-256-CBC\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t camellia_128_cfb128_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CFB128,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"CAMELLIA-128-CFB128\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_cfb128_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CFB128,\n    MBEDTLS_MODE_CFB,\n    192,\n    \"CAMELLIA-192-CFB128\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_cfb128_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CFB128,\n    MBEDTLS_MODE_CFB,\n    256,\n    \"CAMELLIA-256-CFB128\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t camellia_128_ctr_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"CAMELLIA-128-CTR\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_ctr_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CTR,\n    MBEDTLS_MODE_CTR,\n    192,\n    \"CAMELLIA-192-CTR\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_ctr_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CTR,\n    MBEDTLS_MODE_CTR,\n    256,\n    \"CAMELLIA-256-CTR\",\n    16,\n    0,\n    16,\n    &camellia_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_GCM_C)\nstatic int gcm_camellia_setkey_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_CAMELLIA,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t gcm_camellia_info = {\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    gcm_camellia_setkey_wrap,\n    gcm_camellia_setkey_wrap,\n    gcm_ctx_alloc,\n    gcm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t camellia_128_gcm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_GCM,\n    MBEDTLS_MODE_GCM,\n    128,\n    \"CAMELLIA-128-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_gcm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_GCM,\n    MBEDTLS_MODE_GCM,\n    192,\n    \"CAMELLIA-192-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_gcm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_GCM,\n    MBEDTLS_MODE_GCM,\n    256,\n    \"CAMELLIA-256-GCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &gcm_camellia_info\n};\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_CCM_C)\nstatic int ccm_camellia_setkey_wrap( void *ctx, const unsigned char *key,\n                                     unsigned int key_bitlen )\n{\n    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_CAMELLIA,\n                     key, key_bitlen );\n}\n\nstatic const mbedtls_cipher_base_t ccm_camellia_info = {\n    MBEDTLS_CIPHER_ID_CAMELLIA,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    ccm_camellia_setkey_wrap,\n    ccm_camellia_setkey_wrap,\n    ccm_ctx_alloc,\n    ccm_ctx_free,\n};\n\nstatic const mbedtls_cipher_info_t camellia_128_ccm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_128_CCM,\n    MBEDTLS_MODE_CCM,\n    128,\n    \"CAMELLIA-128-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_192_ccm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_192_CCM,\n    MBEDTLS_MODE_CCM,\n    192,\n    \"CAMELLIA-192-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_camellia_info\n};\n\nstatic const mbedtls_cipher_info_t camellia_256_ccm_info = {\n    MBEDTLS_CIPHER_CAMELLIA_256_CCM,\n    MBEDTLS_MODE_CCM,\n    256,\n    \"CAMELLIA-256-CCM\",\n    12,\n    MBEDTLS_CIPHER_VARIABLE_IV_LEN,\n    16,\n    &ccm_camellia_info\n};\n#endif /* MBEDTLS_CCM_C */\n\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_DES_C)\n\nstatic int des_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    ((void) operation);\n    return mbedtls_des_crypt_ecb( (mbedtls_des_context *) ctx, input, output );\n}\n\nstatic int des3_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    ((void) operation);\n    return mbedtls_des3_crypt_ecb( (mbedtls_des3_context *) ctx, input, output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int des_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,\n        unsigned char *iv, const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_des_crypt_cbc( (mbedtls_des_context *) ctx, operation, length, iv, input,\n                          output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int des3_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation, size_t length,\n        unsigned char *iv, const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_des3_crypt_cbc( (mbedtls_des3_context *) ctx, operation, length, iv, input,\n                           output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\nstatic int des_setkey_dec_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des_setkey_dec( (mbedtls_des_context *) ctx, key );\n}\n\nstatic int des_setkey_enc_wrap( void *ctx, const unsigned char *key,\n                                unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des_setkey_enc( (mbedtls_des_context *) ctx, key );\n}\n\nstatic int des3_set2key_dec_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set2key_dec( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic int des3_set2key_enc_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set2key_enc( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic int des3_set3key_dec_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set3key_dec( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic int des3_set3key_enc_wrap( void *ctx, const unsigned char *key,\n                                  unsigned int key_bitlen )\n{\n    ((void) key_bitlen);\n\n    return mbedtls_des3_set3key_enc( (mbedtls_des3_context *) ctx, key );\n}\n\nstatic void * des_ctx_alloc( void )\n{\n    mbedtls_des_context *des = mbedtls_calloc( 1, sizeof( mbedtls_des_context ) );\n\n    if( des == NULL )\n        return( NULL );\n\n    mbedtls_des_init( des );\n\n    return( des );\n}\n\nstatic void des_ctx_free( void *ctx )\n{\n    mbedtls_des_free( (mbedtls_des_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic void * des3_ctx_alloc( void )\n{\n    mbedtls_des3_context *des3;\n    des3 = mbedtls_calloc( 1, sizeof( mbedtls_des3_context ) );\n\n    if( des3 == NULL )\n        return( NULL );\n\n    mbedtls_des3_init( des3 );\n\n    return( des3 );\n}\n\nstatic void des3_ctx_free( void *ctx )\n{\n    mbedtls_des3_free( (mbedtls_des3_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t des_info = {\n    MBEDTLS_CIPHER_ID_DES,\n    des_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    des_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    des_setkey_enc_wrap,\n    des_setkey_dec_wrap,\n    des_ctx_alloc,\n    des_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t des_ecb_info = {\n    MBEDTLS_CIPHER_DES_ECB,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_KEY_LENGTH_DES,\n    \"DES-ECB\",\n    8,\n    0,\n    8,\n    &des_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t des_cbc_info = {\n    MBEDTLS_CIPHER_DES_CBC,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_KEY_LENGTH_DES,\n    \"DES-CBC\",\n    8,\n    0,\n    8,\n    &des_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\nstatic const mbedtls_cipher_base_t des_ede_info = {\n    MBEDTLS_CIPHER_ID_DES,\n    des3_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    des3_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    des3_set2key_enc_wrap,\n    des3_set2key_dec_wrap,\n    des3_ctx_alloc,\n    des3_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t des_ede_ecb_info = {\n    MBEDTLS_CIPHER_DES_EDE_ECB,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_KEY_LENGTH_DES_EDE,\n    \"DES-EDE-ECB\",\n    8,\n    0,\n    8,\n    &des_ede_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t des_ede_cbc_info = {\n    MBEDTLS_CIPHER_DES_EDE_CBC,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_KEY_LENGTH_DES_EDE,\n    \"DES-EDE-CBC\",\n    8,\n    0,\n    8,\n    &des_ede_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\nstatic const mbedtls_cipher_base_t des_ede3_info = {\n    MBEDTLS_CIPHER_ID_3DES,\n    des3_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    des3_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    des3_set3key_enc_wrap,\n    des3_set3key_dec_wrap,\n    des3_ctx_alloc,\n    des3_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t des_ede3_ecb_info = {\n    MBEDTLS_CIPHER_DES_EDE3_ECB,\n    MBEDTLS_MODE_ECB,\n    MBEDTLS_KEY_LENGTH_DES_EDE3,\n    \"DES-EDE3-ECB\",\n    8,\n    0,\n    8,\n    &des_ede3_info\n};\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t des_ede3_cbc_info = {\n    MBEDTLS_CIPHER_DES_EDE3_CBC,\n    MBEDTLS_MODE_CBC,\n    MBEDTLS_KEY_LENGTH_DES_EDE3,\n    \"DES-EDE3-CBC\",\n    8,\n    0,\n    8,\n    &des_ede3_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_BLOWFISH_C)\n\nstatic int blowfish_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_ecb( (mbedtls_blowfish_context *) ctx, operation, input,\n                               output );\n}\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic int blowfish_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, unsigned char *iv, const unsigned char *input,\n        unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_cbc( (mbedtls_blowfish_context *) ctx, operation, length, iv,\n                               input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic int blowfish_crypt_cfb64_wrap( void *ctx, mbedtls_operation_t operation,\n        size_t length, size_t *iv_off, unsigned char *iv,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_cfb64( (mbedtls_blowfish_context *) ctx, operation, length,\n                                 iv_off, iv, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic int blowfish_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,\n        unsigned char *nonce_counter, unsigned char *stream_block,\n        const unsigned char *input, unsigned char *output )\n{\n    return mbedtls_blowfish_crypt_ctr( (mbedtls_blowfish_context *) ctx, length, nc_off,\n                               nonce_counter, stream_block, input, output );\n}\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\nstatic int blowfish_setkey_wrap( void *ctx, const unsigned char *key,\n                                 unsigned int key_bitlen )\n{\n    return mbedtls_blowfish_setkey( (mbedtls_blowfish_context *) ctx, key, key_bitlen );\n}\n\nstatic void * blowfish_ctx_alloc( void )\n{\n    mbedtls_blowfish_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_blowfish_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_blowfish_init( ctx );\n\n    return( ctx );\n}\n\nstatic void blowfish_ctx_free( void *ctx )\n{\n    mbedtls_blowfish_free( (mbedtls_blowfish_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t blowfish_info = {\n    MBEDTLS_CIPHER_ID_BLOWFISH,\n    blowfish_crypt_ecb_wrap,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    blowfish_crypt_cbc_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    blowfish_crypt_cfb64_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    blowfish_crypt_ctr_wrap,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    NULL,\n#endif\n    blowfish_setkey_wrap,\n    blowfish_setkey_wrap,\n    blowfish_ctx_alloc,\n    blowfish_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t blowfish_ecb_info = {\n    MBEDTLS_CIPHER_BLOWFISH_ECB,\n    MBEDTLS_MODE_ECB,\n    128,\n    \"BLOWFISH-ECB\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\nstatic const mbedtls_cipher_info_t blowfish_cbc_info = {\n    MBEDTLS_CIPHER_BLOWFISH_CBC,\n    MBEDTLS_MODE_CBC,\n    128,\n    \"BLOWFISH-CBC\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\nstatic const mbedtls_cipher_info_t blowfish_cfb64_info = {\n    MBEDTLS_CIPHER_BLOWFISH_CFB64,\n    MBEDTLS_MODE_CFB,\n    128,\n    \"BLOWFISH-CFB64\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\nstatic const mbedtls_cipher_info_t blowfish_ctr_info = {\n    MBEDTLS_CIPHER_BLOWFISH_CTR,\n    MBEDTLS_MODE_CTR,\n    128,\n    \"BLOWFISH-CTR\",\n    8,\n    MBEDTLS_CIPHER_VARIABLE_KEY_LEN,\n    8,\n    &blowfish_info\n};\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_ARC4_C)\nstatic int arc4_crypt_stream_wrap( void *ctx, size_t length,\n                                   const unsigned char *input,\n                                   unsigned char *output )\n{\n    return( mbedtls_arc4_crypt( (mbedtls_arc4_context *) ctx, length, input, output ) );\n}\n\nstatic int arc4_setkey_wrap( void *ctx, const unsigned char *key,\n                             unsigned int key_bitlen )\n{\n    /* we get key_bitlen in bits, arc4 expects it in bytes */\n    if( key_bitlen % 8 != 0 )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    mbedtls_arc4_setup( (mbedtls_arc4_context *) ctx, key, key_bitlen / 8 );\n    return( 0 );\n}\n\nstatic void * arc4_ctx_alloc( void )\n{\n    mbedtls_arc4_context *ctx;\n    ctx = mbedtls_calloc( 1, sizeof( mbedtls_arc4_context ) );\n\n    if( ctx == NULL )\n        return( NULL );\n\n    mbedtls_arc4_init( ctx );\n\n    return( ctx );\n}\n\nstatic void arc4_ctx_free( void *ctx )\n{\n    mbedtls_arc4_free( (mbedtls_arc4_context *) ctx );\n    mbedtls_free( ctx );\n}\n\nstatic const mbedtls_cipher_base_t arc4_base_info = {\n    MBEDTLS_CIPHER_ID_ARC4,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    arc4_crypt_stream_wrap,\n#endif\n    arc4_setkey_wrap,\n    arc4_setkey_wrap,\n    arc4_ctx_alloc,\n    arc4_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t arc4_128_info = {\n    MBEDTLS_CIPHER_ARC4_128,\n    MBEDTLS_MODE_STREAM,\n    128,\n    \"ARC4-128\",\n    0,\n    0,\n    1,\n    &arc4_base_info\n};\n#endif /* MBEDTLS_ARC4_C */\n\n#if defined(MBEDTLS_CIPHER_NULL_CIPHER)\nstatic int null_crypt_stream( void *ctx, size_t length,\n                              const unsigned char *input,\n                              unsigned char *output )\n{\n    ((void) ctx);\n    memmove( output, input, length );\n    return( 0 );\n}\n\nstatic int null_setkey( void *ctx, const unsigned char *key,\n                        unsigned int key_bitlen )\n{\n    ((void) ctx);\n    ((void) key);\n    ((void) key_bitlen);\n\n    return( 0 );\n}\n\nstatic void * null_ctx_alloc( void )\n{\n    return( (void *) 1 );\n}\n\nstatic void null_ctx_free( void *ctx )\n{\n    ((void) ctx);\n}\n\nstatic const mbedtls_cipher_base_t null_base_info = {\n    MBEDTLS_CIPHER_ID_NULL,\n    NULL,\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    NULL,\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    null_crypt_stream,\n#endif\n    null_setkey,\n    null_setkey,\n    null_ctx_alloc,\n    null_ctx_free\n};\n\nstatic const mbedtls_cipher_info_t null_cipher_info = {\n    MBEDTLS_CIPHER_NULL,\n    MBEDTLS_MODE_STREAM,\n    0,\n    \"NULL\",\n    0,\n    0,\n    1,\n    &null_base_info\n};\n#endif /* defined(MBEDTLS_CIPHER_NULL_CIPHER) */\n\nconst mbedtls_cipher_definition_t mbedtls_cipher_definitions[] =\n{\n#if defined(MBEDTLS_AES_C)\n    { MBEDTLS_CIPHER_AES_128_ECB,          &aes_128_ecb_info },\n    { MBEDTLS_CIPHER_AES_192_ECB,          &aes_192_ecb_info },\n    { MBEDTLS_CIPHER_AES_256_ECB,          &aes_256_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_AES_128_CBC,          &aes_128_cbc_info },\n    { MBEDTLS_CIPHER_AES_192_CBC,          &aes_192_cbc_info },\n    { MBEDTLS_CIPHER_AES_256_CBC,          &aes_256_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_AES_128_CFB128,       &aes_128_cfb128_info },\n    { MBEDTLS_CIPHER_AES_192_CFB128,       &aes_192_cfb128_info },\n    { MBEDTLS_CIPHER_AES_256_CFB128,       &aes_256_cfb128_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_AES_128_CTR,          &aes_128_ctr_info },\n    { MBEDTLS_CIPHER_AES_192_CTR,          &aes_192_ctr_info },\n    { MBEDTLS_CIPHER_AES_256_CTR,          &aes_256_ctr_info },\n#endif\n#if defined(MBEDTLS_GCM_C)\n    { MBEDTLS_CIPHER_AES_128_GCM,          &aes_128_gcm_info },\n    { MBEDTLS_CIPHER_AES_192_GCM,          &aes_192_gcm_info },\n    { MBEDTLS_CIPHER_AES_256_GCM,          &aes_256_gcm_info },\n#endif\n#if defined(MBEDTLS_CCM_C)\n    { MBEDTLS_CIPHER_AES_128_CCM,          &aes_128_ccm_info },\n    { MBEDTLS_CIPHER_AES_192_CCM,          &aes_192_ccm_info },\n    { MBEDTLS_CIPHER_AES_256_CCM,          &aes_256_ccm_info },\n#endif\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_ARC4_C)\n    { MBEDTLS_CIPHER_ARC4_128,             &arc4_128_info },\n#endif\n\n#if defined(MBEDTLS_BLOWFISH_C)\n    { MBEDTLS_CIPHER_BLOWFISH_ECB,         &blowfish_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_BLOWFISH_CBC,         &blowfish_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_BLOWFISH_CFB64,       &blowfish_cfb64_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_BLOWFISH_CTR,         &blowfish_ctr_info },\n#endif\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n    { MBEDTLS_CIPHER_CAMELLIA_128_ECB,     &camellia_128_ecb_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_ECB,     &camellia_192_ecb_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_ECB,     &camellia_256_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CBC,     &camellia_128_cbc_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CBC,     &camellia_192_cbc_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CBC,     &camellia_256_cbc_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CFB128,  &camellia_128_cfb128_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CFB128,  &camellia_192_cfb128_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CFB128,  &camellia_256_cfb128_info },\n#endif\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CTR,     &camellia_128_ctr_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CTR,     &camellia_192_ctr_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CTR,     &camellia_256_ctr_info },\n#endif\n#if defined(MBEDTLS_GCM_C)\n    { MBEDTLS_CIPHER_CAMELLIA_128_GCM,     &camellia_128_gcm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_GCM,     &camellia_192_gcm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_GCM,     &camellia_256_gcm_info },\n#endif\n#if defined(MBEDTLS_CCM_C)\n    { MBEDTLS_CIPHER_CAMELLIA_128_CCM,     &camellia_128_ccm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_192_CCM,     &camellia_192_ccm_info },\n    { MBEDTLS_CIPHER_CAMELLIA_256_CCM,     &camellia_256_ccm_info },\n#endif\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_DES_C)\n    { MBEDTLS_CIPHER_DES_ECB,              &des_ecb_info },\n    { MBEDTLS_CIPHER_DES_EDE_ECB,          &des_ede_ecb_info },\n    { MBEDTLS_CIPHER_DES_EDE3_ECB,         &des_ede3_ecb_info },\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    { MBEDTLS_CIPHER_DES_CBC,              &des_cbc_info },\n    { MBEDTLS_CIPHER_DES_EDE_CBC,          &des_ede_cbc_info },\n    { MBEDTLS_CIPHER_DES_EDE3_CBC,         &des_ede3_cbc_info },\n#endif\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_CIPHER_NULL_CIPHER)\n    { MBEDTLS_CIPHER_NULL,                 &null_cipher_info },\n#endif /* MBEDTLS_CIPHER_NULL_CIPHER */\n\n    { MBEDTLS_CIPHER_NONE, NULL }\n};\n\n#define NUM_CIPHERS sizeof mbedtls_cipher_definitions / sizeof mbedtls_cipher_definitions[0]\nint mbedtls_cipher_supported[NUM_CIPHERS];\n\n#endif /* MBEDTLS_CIPHER_C */\n","/**\n * \\file cmac.c\n *\n * \\brief NIST SP800-38B compliant CMAC implementation for AES and 3DES\n *\n *  Copyright (C) 2006-2016, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n/*\n * References:\n *\n * - NIST SP 800-38B Recommendation for Block Cipher Modes of Operation: The\n *      CMAC Mode for Authentication\n *   http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf\n *\n * - RFC 4493 - The AES-CMAC Algorithm\n *   https://tools.ietf.org/html/rfc4493\n *\n * - RFC 4615 - The Advanced Encryption Standard-Cipher-based Message\n *      Authentication Code-Pseudo-Random Function-128 (AES-CMAC-PRF-128)\n *      Algorithm for the Internet Key Exchange Protocol (IKE)\n *   https://tools.ietf.org/html/rfc4615\n *\n *   Additional test vectors: ISO/IEC 9797-1\n *\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CMAC_C)\n\n#include \"mbedtls/cmac.h\"\n\n#include <string.h>\n\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc     calloc\n#define mbedtls_free       free\n#if defined(MBEDTLS_SELF_TEST)\n#include <stdio.h>\n#define mbedtls_printf     printf\n#endif /* MBEDTLS_SELF_TEST */\n#endif /* MBEDTLS_PLATFORM_C */\n\n#if !defined(MBEDTLS_CMAC_ALT) || defined(MBEDTLS_SELF_TEST)\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;\n}\n\n/*\n * Multiplication by u in the Galois field of GF(2^n)\n *\n * As explained in NIST SP 800-38B, this can be computed:\n *\n *   If MSB(p) = 0, then p = (p << 1)\n *   If MSB(p) = 1, then p = (p << 1) ^ R_n\n *   with R_64 = 0x1B and  R_128 = 0x87\n *\n * Input and output MUST NOT point to the same buffer\n * Block size must be 8 bytes or 16 bytes - the block sizes for DES and AES.\n */\nstatic int cmac_multiply_by_u( unsigned char *output,\n                               const unsigned char *input,\n                               size_t blocksize )\n{\n    const unsigned char R_128 = 0x87;\n    const unsigned char R_64 = 0x1B;\n    unsigned char R_n, mask;\n    unsigned char overflow = 0x00;\n    int i;\n\n    if( blocksize == MBEDTLS_AES_BLOCK_SIZE )\n    {\n        R_n = R_128;\n    }\n    else if( blocksize == MBEDTLS_DES3_BLOCK_SIZE )\n    {\n        R_n = R_64;\n    }\n    else\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    for( i = (int)blocksize - 1; i >= 0; i-- )\n    {\n        output[i] = input[i] << 1 | overflow;\n        overflow = input[i] >> 7;\n    }\n\n    /* mask = ( input[0] >> 7 ) ? 0xff : 0x00\n     * using bit operations to avoid branches */\n\n    /* MSVC has a warning about unary minus on unsigned, but this is\n     * well-defined and precisely what we want to do here */\n#if defined(_MSC_VER)\n#pragma warning( push )\n#pragma warning( disable : 4146 )\n#endif\n    mask = - ( input[0] >> 7 );\n#if defined(_MSC_VER)\n#pragma warning( pop )\n#endif\n\n    output[ blocksize - 1 ] ^= R_n & mask;\n\n    return( 0 );\n}\n\n/*\n * Generate subkeys\n *\n * - as specified by RFC 4493, section 2.3 Subkey Generation Algorithm\n */\nstatic int cmac_generate_subkeys( mbedtls_cipher_context_t *ctx,\n                                  unsigned char* K1, unsigned char* K2 )\n{\n    int ret;\n    unsigned char L[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    size_t olen, block_size;\n\n    mbedtls_zeroize( L, sizeof( L ) );\n\n    block_size = ctx->cipher_info->block_size;\n\n    /* Calculate Ek(0) */\n    if( ( ret = mbedtls_cipher_update( ctx, L, block_size, L, &olen ) ) != 0 )\n        goto exit;\n\n    /*\n     * Generate K1 and K2\n     */\n    if( ( ret = cmac_multiply_by_u( K1, L , block_size ) ) != 0 )\n        goto exit;\n\n    if( ( ret = cmac_multiply_by_u( K2, K1 , block_size ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_zeroize( L, sizeof( L ) );\n\n    return( ret );\n}\n#endif /* !defined(MBEDTLS_CMAC_ALT) || defined(MBEDTLS_SELF_TEST) */\n\n#if !defined(MBEDTLS_CMAC_ALT)\nstatic void cmac_xor_block( unsigned char *output, const unsigned char *input1,\n                            const unsigned char *input2,\n                            const size_t block_size )\n{\n    size_t idx;\n\n    for( idx = 0; idx < block_size; idx++ )\n        output[ idx ] = input1[ idx ] ^ input2[ idx ];\n}\n\n/*\n * Create padded last block from (partial) last block.\n *\n * We can't use the padding option from the cipher layer, as it only works for\n * CBC and we use ECB mode, and anyway we need to XOR K1 or K2 in addition.\n */\nstatic void cmac_pad( unsigned char padded_block[MBEDTLS_CIPHER_BLKSIZE_MAX],\n                      size_t padded_block_len,\n                      const unsigned char *last_block,\n                      size_t last_block_len )\n{\n    size_t j;\n\n    for( j = 0; j < padded_block_len; j++ )\n    {\n        if( j < last_block_len )\n            padded_block[j] = last_block[j];\n        else if( j == last_block_len )\n            padded_block[j] = 0x80;\n        else\n            padded_block[j] = 0x00;\n    }\n}\n\nint mbedtls_cipher_cmac_starts( mbedtls_cipher_context_t *ctx,\n                                const unsigned char *key, size_t keybits )\n{\n    mbedtls_cipher_type_t type;\n    mbedtls_cmac_context_t *cmac_ctx;\n    int retval;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || key == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( ( retval = mbedtls_cipher_setkey( ctx, key, (int)keybits,\n                                          MBEDTLS_ENCRYPT ) ) != 0 )\n        return( retval );\n\n    type = ctx->cipher_info->type;\n\n    switch( type )\n    {\n        case MBEDTLS_CIPHER_AES_128_ECB:\n        case MBEDTLS_CIPHER_AES_192_ECB:\n        case MBEDTLS_CIPHER_AES_256_ECB:\n        case MBEDTLS_CIPHER_DES_EDE3_ECB:\n            break;\n        default:\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    /* Allocated and initialise in the cipher context memory for the CMAC\n     * context */\n    cmac_ctx = mbedtls_calloc( 1, sizeof( mbedtls_cmac_context_t ) );\n    if( cmac_ctx == NULL )\n        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );\n\n    ctx->cmac_ctx = cmac_ctx;\n\n    mbedtls_zeroize( cmac_ctx->state, sizeof( cmac_ctx->state ) );\n\n    return 0;\n}\n\nint mbedtls_cipher_cmac_update( mbedtls_cipher_context_t *ctx,\n                                const unsigned char *input, size_t ilen )\n{\n    mbedtls_cmac_context_t* cmac_ctx;\n    unsigned char *state;\n    int ret = 0;\n    size_t n, j, olen, block_size;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||\n        ctx->cmac_ctx == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cmac_ctx = ctx->cmac_ctx;\n    block_size = ctx->cipher_info->block_size;\n    state = ctx->cmac_ctx->state;\n\n    /* Is there data still to process from the last call, that's greater in\n     * size than a block? */\n    if( cmac_ctx->unprocessed_len > 0 &&\n        ilen > block_size - cmac_ctx->unprocessed_len )\n    {\n        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],\n                input,\n                block_size - cmac_ctx->unprocessed_len );\n\n        cmac_xor_block( state, cmac_ctx->unprocessed_block, state, block_size );\n\n        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,\n                                           &olen ) ) != 0 )\n        {\n           goto exit;\n        }\n\n        input += block_size - cmac_ctx->unprocessed_len;\n        ilen -= block_size - cmac_ctx->unprocessed_len;\n        cmac_ctx->unprocessed_len = 0;\n    }\n\n    /* n is the number of blocks including any final partial block */\n    n = ( ilen + block_size - 1 ) / block_size;\n\n    /* Iterate across the input data in block sized chunks, excluding any\n     * final partial or complete block */\n    for( j = 1; j < n; j++ )\n    {\n        cmac_xor_block( state, input, state, block_size );\n\n        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,\n                                           &olen ) ) != 0 )\n           goto exit;\n\n        ilen -= block_size;\n        input += block_size;\n    }\n\n    /* If there is data left over that wasn't aligned to a block */\n    if( ilen > 0 )\n    {\n        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],\n                input,\n                ilen );\n        cmac_ctx->unprocessed_len += ilen;\n    }\n\nexit:\n    return( ret );\n}\n\nint mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx,\n                                unsigned char *output )\n{\n    mbedtls_cmac_context_t* cmac_ctx;\n    unsigned char *state, *last_block;\n    unsigned char K1[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char M_last[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    int ret;\n    size_t olen, block_size;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL ||\n        output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cmac_ctx = ctx->cmac_ctx;\n    block_size = ctx->cipher_info->block_size;\n    state = cmac_ctx->state;\n\n    mbedtls_zeroize( K1, sizeof( K1 ) );\n    mbedtls_zeroize( K2, sizeof( K2 ) );\n    cmac_generate_subkeys( ctx, K1, K2 );\n\n    last_block = cmac_ctx->unprocessed_block;\n\n    /* Calculate last block */\n    if( cmac_ctx->unprocessed_len < block_size )\n    {\n        cmac_pad( M_last, block_size, last_block, cmac_ctx->unprocessed_len );\n        cmac_xor_block( M_last, M_last, K2, block_size );\n    }\n    else\n    {\n        /* Last block is complete block */\n        cmac_xor_block( M_last, last_block, K1, block_size );\n    }\n\n\n    cmac_xor_block( state, M_last, state, block_size );\n    if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,\n                                       &olen ) ) != 0 )\n    {\n        goto exit;\n    }\n\n    memcpy( output, state, block_size );\n\nexit:\n    /* Wipe the generated keys on the stack, and any other transients to avoid\n     * side channel leakage */\n    mbedtls_zeroize( K1, sizeof( K1 ) );\n    mbedtls_zeroize( K2, sizeof( K2 ) );\n\n    cmac_ctx->unprocessed_len = 0;\n    mbedtls_zeroize( cmac_ctx->unprocessed_block,\n                     sizeof( cmac_ctx->unprocessed_block ) );\n\n    mbedtls_zeroize( state, MBEDTLS_CIPHER_BLKSIZE_MAX );\n    return( ret );\n}\n\nint mbedtls_cipher_cmac_reset( mbedtls_cipher_context_t *ctx )\n{\n    mbedtls_cmac_context_t* cmac_ctx;\n\n    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cmac_ctx = ctx->cmac_ctx;\n\n    /* Reset the internal state */\n    cmac_ctx->unprocessed_len = 0;\n    mbedtls_zeroize( cmac_ctx->unprocessed_block,\n                     sizeof( cmac_ctx->unprocessed_block ) );\n    mbedtls_zeroize( cmac_ctx->state,\n                     sizeof( cmac_ctx->state ) );\n\n    return( 0 );\n}\n\nint mbedtls_cipher_cmac( const mbedtls_cipher_info_t *cipher_info,\n                         const unsigned char *key, size_t keylen,\n                         const unsigned char *input, size_t ilen,\n                         unsigned char *output )\n{\n    mbedtls_cipher_context_t ctx;\n    int ret;\n\n    if( cipher_info == NULL || key == NULL || input == NULL || output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    mbedtls_cipher_init( &ctx );\n\n    if( ( ret = mbedtls_cipher_setup( &ctx, cipher_info ) ) != 0 )\n        goto exit;\n\n    ret = mbedtls_cipher_cmac_starts( &ctx, key, keylen );\n    if( ret != 0 )\n        goto exit;\n\n    ret = mbedtls_cipher_cmac_update( &ctx, input, ilen );\n    if( ret != 0 )\n        goto exit;\n\n    ret = mbedtls_cipher_cmac_finish( &ctx, output );\n\nexit:\n    mbedtls_cipher_free( &ctx );\n\n    return( ret );\n}\n\n#if defined(MBEDTLS_AES_C)\n/*\n * Implementation of AES-CMAC-PRF-128 defined in RFC 4615\n */\nint mbedtls_aes_cmac_prf_128( const unsigned char *key, size_t key_length,\n                              const unsigned char *input, size_t in_len,\n                              unsigned char *output )\n{\n    int ret;\n    const mbedtls_cipher_info_t *cipher_info;\n    unsigned char zero_key[MBEDTLS_AES_BLOCK_SIZE];\n    unsigned char int_key[MBEDTLS_AES_BLOCK_SIZE];\n\n    if( key == NULL || input == NULL || output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cipher_info = mbedtls_cipher_info_from_type( MBEDTLS_CIPHER_AES_128_ECB );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;\n        goto exit;\n    }\n\n    if( key_length == MBEDTLS_AES_BLOCK_SIZE )\n    {\n        /* Use key as is */\n        memcpy( int_key, key, MBEDTLS_AES_BLOCK_SIZE );\n    }\n    else\n    {\n        memset( zero_key, 0, MBEDTLS_AES_BLOCK_SIZE );\n\n        ret = mbedtls_cipher_cmac( cipher_info, zero_key, 128, key,\n                                   key_length, int_key );\n        if( ret != 0 )\n            goto exit;\n    }\n\n    ret = mbedtls_cipher_cmac( cipher_info, int_key, 128, input, in_len,\n                               output );\n\nexit:\n    mbedtls_zeroize( int_key, sizeof( int_key ) );\n\n    return( ret );\n}\n#endif /* MBEDTLS_AES_C */\n\n#endif /* !MBEDTLS_CMAC_ALT */\n\n#if defined(MBEDTLS_SELF_TEST)\n/*\n * CMAC test data for SP800-38B\n * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/AES_CMAC.pdf\n * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/TDES_CMAC.pdf\n *\n * AES-CMAC-PRF-128 test data from RFC 4615\n * https://tools.ietf.org/html/rfc4615#page-4\n */\n\n#define NB_CMAC_TESTS_PER_KEY 4\n#define NB_PRF_TESTS 3\n\n#if defined(MBEDTLS_AES_C) || defined(MBEDTLS_DES_C)\n/* All CMAC test inputs are truncated from the same 64 byte buffer. */\nstatic const unsigned char test_message[] = {\n    /* PT */\n    0x6b, 0xc1, 0xbe, 0xe2,     0x2e, 0x40, 0x9f, 0x96,\n    0xe9, 0x3d, 0x7e, 0x11,     0x73, 0x93, 0x17, 0x2a,\n    0xae, 0x2d, 0x8a, 0x57,     0x1e, 0x03, 0xac, 0x9c,\n    0x9e, 0xb7, 0x6f, 0xac,     0x45, 0xaf, 0x8e, 0x51,\n    0x30, 0xc8, 0x1c, 0x46,     0xa3, 0x5c, 0xe4, 0x11,\n    0xe5, 0xfb, 0xc1, 0x19,     0x1a, 0x0a, 0x52, 0xef,\n    0xf6, 0x9f, 0x24, 0x45,     0xdf, 0x4f, 0x9b, 0x17,\n    0xad, 0x2b, 0x41, 0x7b,     0xe6, 0x6c, 0x37, 0x10\n};\n#endif /* MBEDTLS_AES_C || MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n/* Truncation point of message for AES CMAC tests  */\nstatic const  unsigned int  aes_message_lengths[NB_CMAC_TESTS_PER_KEY] = {\n    /* Mlen */\n    0,\n    16,\n    20,\n    64\n};\n\n/* CMAC-AES128 Test Data */\nstatic const unsigned char aes_128_key[16] = {\n    0x2b, 0x7e, 0x15, 0x16,     0x28, 0xae, 0xd2, 0xa6,\n    0xab, 0xf7, 0x15, 0x88,     0x09, 0xcf, 0x4f, 0x3c\n};\nstatic const unsigned char aes_128_subkeys[2][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* K1 */\n        0xfb, 0xee, 0xd6, 0x18,     0x35, 0x71, 0x33, 0x66,\n        0x7c, 0x85, 0xe0, 0x8f,     0x72, 0x36, 0xa8, 0xde\n    },\n    {\n        /* K2 */\n        0xf7, 0xdd, 0xac, 0x30,     0x6a, 0xe2, 0x66, 0xcc,\n        0xf9, 0x0b, 0xc1, 0x1e,     0xe4, 0x6d, 0x51, 0x3b\n    }\n};\nstatic const unsigned char aes_128_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* Example #1 */\n        0xbb, 0x1d, 0x69, 0x29,     0xe9, 0x59, 0x37, 0x28,\n        0x7f, 0xa3, 0x7d, 0x12,     0x9b, 0x75, 0x67, 0x46\n    },\n    {\n        /* Example #2 */\n        0x07, 0x0a, 0x16, 0xb4,     0x6b, 0x4d, 0x41, 0x44,\n        0xf7, 0x9b, 0xdd, 0x9d,     0xd0, 0x4a, 0x28, 0x7c\n    },\n    {\n        /* Example #3 */\n        0x7d, 0x85, 0x44, 0x9e,     0xa6, 0xea, 0x19, 0xc8,\n        0x23, 0xa7, 0xbf, 0x78,     0x83, 0x7d, 0xfa, 0xde\n    },\n    {\n        /* Example #4 */\n        0x51, 0xf0, 0xbe, 0xbf,     0x7e, 0x3b, 0x9d, 0x92,\n        0xfc, 0x49, 0x74, 0x17,     0x79, 0x36, 0x3c, 0xfe\n    }\n};\n\n/* CMAC-AES192 Test Data */\nstatic const unsigned char aes_192_key[24] = {\n    0x8e, 0x73, 0xb0, 0xf7,     0xda, 0x0e, 0x64, 0x52,\n    0xc8, 0x10, 0xf3, 0x2b,     0x80, 0x90, 0x79, 0xe5,\n    0x62, 0xf8, 0xea, 0xd2,     0x52, 0x2c, 0x6b, 0x7b\n};\nstatic const unsigned char aes_192_subkeys[2][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* K1 */\n        0x44, 0x8a, 0x5b, 0x1c,     0x93, 0x51, 0x4b, 0x27,\n        0x3e, 0xe6, 0x43, 0x9d,     0xd4, 0xda, 0xa2, 0x96\n    },\n    {\n        /* K2 */\n        0x89, 0x14, 0xb6, 0x39,     0x26, 0xa2, 0x96, 0x4e,\n        0x7d, 0xcc, 0x87, 0x3b,     0xa9, 0xb5, 0x45, 0x2c\n    }\n};\nstatic const unsigned char aes_192_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* Example #1 */\n        0xd1, 0x7d, 0xdf, 0x46,     0xad, 0xaa, 0xcd, 0xe5,\n        0x31, 0xca, 0xc4, 0x83,     0xde, 0x7a, 0x93, 0x67\n    },\n    {\n        /* Example #2 */\n        0x9e, 0x99, 0xa7, 0xbf,     0x31, 0xe7, 0x10, 0x90,\n        0x06, 0x62, 0xf6, 0x5e,     0x61, 0x7c, 0x51, 0x84\n    },\n    {\n        /* Example #3 */\n        0x3d, 0x75, 0xc1, 0x94,     0xed, 0x96, 0x07, 0x04,\n        0x44, 0xa9, 0xfa, 0x7e,     0xc7, 0x40, 0xec, 0xf8\n    },\n    {\n        /* Example #4 */\n        0xa1, 0xd5, 0xdf, 0x0e,     0xed, 0x79, 0x0f, 0x79,\n        0x4d, 0x77, 0x58, 0x96,     0x59, 0xf3, 0x9a, 0x11\n    }\n};\n\n/* CMAC-AES256 Test Data */\nstatic const unsigned char aes_256_key[32] = {\n    0x60, 0x3d, 0xeb, 0x10,     0x15, 0xca, 0x71, 0xbe,\n    0x2b, 0x73, 0xae, 0xf0,     0x85, 0x7d, 0x77, 0x81,\n    0x1f, 0x35, 0x2c, 0x07,     0x3b, 0x61, 0x08, 0xd7,\n    0x2d, 0x98, 0x10, 0xa3,     0x09, 0x14, 0xdf, 0xf4\n};\nstatic const unsigned char aes_256_subkeys[2][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* K1 */\n        0xca, 0xd1, 0xed, 0x03,     0x29, 0x9e, 0xed, 0xac,\n        0x2e, 0x9a, 0x99, 0x80,     0x86, 0x21, 0x50, 0x2f\n    },\n    {\n        /* K2 */\n        0x95, 0xa3, 0xda, 0x06,     0x53, 0x3d, 0xdb, 0x58,\n        0x5d, 0x35, 0x33, 0x01,     0x0c, 0x42, 0xa0, 0xd9\n    }\n};\nstatic const unsigned char aes_256_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_AES_BLOCK_SIZE] = {\n    {\n        /* Example #1 */\n        0x02, 0x89, 0x62, 0xf6,     0x1b, 0x7b, 0xf8, 0x9e,\n        0xfc, 0x6b, 0x55, 0x1f,     0x46, 0x67, 0xd9, 0x83\n    },\n    {\n        /* Example #2 */\n        0x28, 0xa7, 0x02, 0x3f,     0x45, 0x2e, 0x8f, 0x82,\n        0xbd, 0x4b, 0xf2, 0x8d,     0x8c, 0x37, 0xc3, 0x5c\n    },\n    {\n        /* Example #3 */\n        0x15, 0x67, 0x27, 0xdc,     0x08, 0x78, 0x94, 0x4a,\n        0x02, 0x3c, 0x1f, 0xe0,     0x3b, 0xad, 0x6d, 0x93\n    },\n    {\n        /* Example #4 */\n        0xe1, 0x99, 0x21, 0x90,     0x54, 0x9f, 0x6e, 0xd5,\n        0x69, 0x6a, 0x2c, 0x05,     0x6c, 0x31, 0x54, 0x10\n    }\n};\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_DES_C)\n/* Truncation point of message for 3DES CMAC tests  */\nstatic const unsigned int des3_message_lengths[NB_CMAC_TESTS_PER_KEY] = {\n    0,\n    16,\n    20,\n    32\n};\n\n/* CMAC-TDES (Generation) - 2 Key Test Data */\nstatic const unsigned char des3_2key_key[24] = {\n    /* Key1 */\n    0x01, 0x23, 0x45, 0x67,     0x89, 0xab, 0xcd, 0xef,\n    /* Key2 */\n    0x23, 0x45, 0x67, 0x89,     0xab, 0xcd, 0xEF, 0x01,\n    /* Key3 */\n    0x01, 0x23, 0x45, 0x67,     0x89, 0xab, 0xcd, 0xef\n};\nstatic const unsigned char des3_2key_subkeys[2][8] = {\n    {\n        /* K1 */\n        0x0d, 0xd2, 0xcb, 0x7a,     0x3d, 0x88, 0x88, 0xd9\n    },\n    {\n        /* K2 */\n        0x1b, 0xa5, 0x96, 0xf4,     0x7b, 0x11, 0x11, 0xb2\n    }\n};\nstatic const unsigned char des3_2key_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_DES3_BLOCK_SIZE] = {\n    {\n        /* Sample #1 */\n        0x79, 0xce, 0x52, 0xa7,     0xf7, 0x86, 0xa9, 0x60\n    },\n    {\n        /* Sample #2 */\n        0xcc, 0x18, 0xa0, 0xb7,     0x9a, 0xf2, 0x41, 0x3b\n    },\n    {\n        /* Sample #3 */\n        0xc0, 0x6d, 0x37, 0x7e,     0xcd, 0x10, 0x19, 0x69\n    },\n    {\n        /* Sample #4 */\n        0x9c, 0xd3, 0x35, 0x80,     0xf9, 0xb6, 0x4d, 0xfb\n    }\n};\n\n/* CMAC-TDES (Generation) - 3 Key Test Data */\nstatic const unsigned char des3_3key_key[24] = {\n    /* Key1 */\n    0x01, 0x23, 0x45, 0x67,     0x89, 0xaa, 0xcd, 0xef,\n    /* Key2 */\n    0x23, 0x45, 0x67, 0x89,     0xab, 0xcd, 0xef, 0x01,\n    /* Key3 */\n    0x45, 0x67, 0x89, 0xab,     0xcd, 0xef, 0x01, 0x23\n};\nstatic const unsigned char des3_3key_subkeys[2][8] = {\n    {\n        /* K1 */\n        0x9d, 0x74, 0xe7, 0x39,     0x33, 0x17, 0x96, 0xc0\n    },\n    {\n        /* K2 */\n        0x3a, 0xe9, 0xce, 0x72,     0x66, 0x2f, 0x2d, 0x9b\n    }\n};\nstatic const unsigned char des3_3key_expected_result[NB_CMAC_TESTS_PER_KEY][MBEDTLS_DES3_BLOCK_SIZE] = {\n    {\n        /* Sample #1 */\n        0x7d, 0xb0, 0xd3, 0x7d,     0xf9, 0x36, 0xc5, 0x50\n    },\n    {\n        /* Sample #2 */\n        0x30, 0x23, 0x9c, 0xf1,     0xf5, 0x2e, 0x66, 0x09\n    },\n    {\n        /* Sample #3 */\n        0x6c, 0x9f, 0x3e, 0xe4,     0x92, 0x3f, 0x6b, 0xe2\n    },\n    {\n        /* Sample #4 */\n        0x99, 0x42, 0x9b, 0xd0,     0xbF, 0x79, 0x04, 0xe5\n    }\n};\n\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n/* AES AES-CMAC-PRF-128 Test Data */\nstatic const unsigned char PRFK[] = {\n    /* Key */\n    0x00, 0x01, 0x02, 0x03,     0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b,     0x0c, 0x0d, 0x0e, 0x0f,\n    0xed, 0xcb\n};\n\n/* Sizes in bytes */\nstatic const size_t PRFKlen[NB_PRF_TESTS] = {\n    18,\n    16,\n    10\n};\n\n/* Message */\nstatic const unsigned char PRFM[] = {\n    0x00, 0x01, 0x02, 0x03,     0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b,     0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13\n};\n\nstatic const unsigned char PRFT[NB_PRF_TESTS][16] = {\n    {\n        0x84, 0xa3, 0x48, 0xa4,     0xa4, 0x5d, 0x23, 0x5b,\n        0xab, 0xff, 0xfc, 0x0d,     0x2b, 0x4d, 0xa0, 0x9a\n    },\n    {\n        0x98, 0x0a, 0xe8, 0x7b,     0x5f, 0x4c, 0x9c, 0x52,\n        0x14, 0xf5, 0xb6, 0xa8,     0x45, 0x5e, 0x4c, 0x2d\n    },\n    {\n        0x29, 0x0d, 0x9e, 0x11,     0x2e, 0xdb, 0x09, 0xee,\n        0x14, 0x1f, 0xcf, 0x64,     0xc0, 0xb7, 0x2f, 0x3d\n    }\n};\n#endif /* MBEDTLS_AES_C */\n\nstatic int cmac_test_subkeys( int verbose,\n                              const char* testname,\n                              const unsigned char* key,\n                              int keybits,\n                              const unsigned char* subkeys,\n                              mbedtls_cipher_type_t cipher_type,\n                              int block_size,\n                              int num_tests )\n{\n    int i, ret;\n    mbedtls_cipher_context_t ctx;\n    const mbedtls_cipher_info_t *cipher_info;\n    unsigned char K1[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];\n\n    cipher_info = mbedtls_cipher_info_from_type( cipher_type );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    for( i = 0; i < num_tests; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  %s CMAC subkey #%u: \", testname, i + 1 );\n\n        mbedtls_cipher_init( &ctx );\n\n        if( ( ret = mbedtls_cipher_setup( &ctx, cipher_info ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"test execution failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( ( ret = mbedtls_cipher_setkey( &ctx, key, keybits,\n                                       MBEDTLS_ENCRYPT ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"test execution failed\\n\" );\n\n            goto cleanup;\n        }\n\n        ret = cmac_generate_subkeys( &ctx, K1, K2 );\n        if( ret != 0 )\n        {\n           if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( ( ret = memcmp( K1, subkeys, block_size ) ) != 0  ||\n            ( ret = memcmp( K2, &subkeys[block_size], block_size ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n\n        mbedtls_cipher_free( &ctx );\n    }\n\n    goto exit;\n\ncleanup:\n    mbedtls_cipher_free( &ctx );\n\nexit:\n    return( ret );\n}\n\nstatic int cmac_test_wth_cipher( int verbose,\n                                 const char* testname,\n                                 const unsigned char* key,\n                                 int keybits,\n                                 const unsigned char* messages,\n                                 const unsigned int message_lengths[4],\n                                 const unsigned char* expected_result,\n                                 mbedtls_cipher_type_t cipher_type,\n                                 int block_size,\n                                 int num_tests )\n{\n    const mbedtls_cipher_info_t *cipher_info;\n    int i, ret;\n    unsigned char output[MBEDTLS_CIPHER_BLKSIZE_MAX];\n\n    cipher_info = mbedtls_cipher_info_from_type( cipher_type );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;\n        goto exit;\n    }\n\n    for( i = 0; i < num_tests; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  %s CMAC #%u: \", testname, i + 1 );\n\n        if( ( ret = mbedtls_cipher_cmac( cipher_info, key, keybits, messages,\n                                         message_lengths[i], output ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n            goto exit;\n        }\n\n        if( ( ret = memcmp( output, &expected_result[i * block_size], block_size ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n            goto exit;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\nexit:\n    return( ret );\n}\n\n#if defined(MBEDTLS_AES_C)\nstatic int test_aes128_cmac_prf( int verbose )\n{\n    int i;\n    int ret;\n    unsigned char output[MBEDTLS_AES_BLOCK_SIZE];\n\n    for( i = 0; i < NB_PRF_TESTS; i++ )\n    {\n        mbedtls_printf( \"  AES CMAC 128 PRF #%u: \", i );\n        ret = mbedtls_aes_cmac_prf_128( PRFK, PRFKlen[i], PRFM, 20, output );\n        if( ret != 0 ||\n            memcmp( output, PRFT[i], MBEDTLS_AES_BLOCK_SIZE ) != 0 )\n        {\n\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            return( ret );\n        }\n        else if( verbose != 0 )\n        {\n            mbedtls_printf( \"passed\\n\" );\n        }\n    }\n    return( ret );\n}\n#endif /* MBEDTLS_AES_C */\n\nint mbedtls_cmac_self_test( int verbose )\n{\n    int ret;\n\n#if defined(MBEDTLS_AES_C)\n    /* AES-128 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 128\",\n                                   aes_128_key,\n                                   128,\n                                   (const unsigned char*)aes_128_subkeys,\n                                   MBEDTLS_CIPHER_AES_128_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"AES 128\",\n                                      aes_128_key,\n                                      128,\n                                      test_message,\n                                      aes_message_lengths,\n                                      (const unsigned char*)aes_128_expected_result,\n                                      MBEDTLS_CIPHER_AES_128_ECB,\n                                      MBEDTLS_AES_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* AES-192 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 192\",\n                                   aes_192_key,\n                                   192,\n                                   (const unsigned char*)aes_192_subkeys,\n                                   MBEDTLS_CIPHER_AES_192_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"AES 192\",\n                                      aes_192_key,\n                                      192,\n                                      test_message,\n                                      aes_message_lengths,\n                                      (const unsigned char*)aes_192_expected_result,\n                                      MBEDTLS_CIPHER_AES_192_ECB,\n                                      MBEDTLS_AES_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* AES-256 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 256\",\n                                   aes_256_key,\n                                   256,\n                                   (const unsigned char*)aes_256_subkeys,\n                                   MBEDTLS_CIPHER_AES_256_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher ( verbose,\n                                       \"AES 256\",\n                                       aes_256_key,\n                                       256,\n                                       test_message,\n                                       aes_message_lengths,\n                                       (const unsigned char*)aes_256_expected_result,\n                                       MBEDTLS_CIPHER_AES_256_ECB,\n                                       MBEDTLS_AES_BLOCK_SIZE,\n                                       NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_DES_C)\n    /* 3DES 2 key */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"3DES 2 key\",\n                                   des3_2key_key,\n                                   192,\n                                   (const unsigned char*)des3_2key_subkeys,\n                                   MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                   MBEDTLS_DES3_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"3DES 2 key\",\n                                      des3_2key_key,\n                                      192,\n                                      test_message,\n                                      des3_message_lengths,\n                                      (const unsigned char*)des3_2key_expected_result,\n                                      MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                      MBEDTLS_DES3_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* 3DES 3 key */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"3DES 3 key\",\n                                   des3_3key_key,\n                                   192,\n                                   (const unsigned char*)des3_3key_subkeys,\n                                   MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                   MBEDTLS_DES3_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"3DES 3 key\",\n                                      des3_3key_key,\n                                      192,\n                                      test_message,\n                                      des3_message_lengths,\n                                      (const unsigned char*)des3_3key_expected_result,\n                                      MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                      MBEDTLS_DES3_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n    if( ( ret = test_aes128_cmac_prf( verbose ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_AES_C */\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    return( 0 );\n}\n\n#endif /* MBEDTLS_SELF_TEST */\n\n#endif /* MBEDTLS_CMAC_C */\n","/*\n *  NIST SP800-38C compliant CCM implementation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n/*\n * Definition of CCM:\n * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf\n * RFC 3610 \"Counter with CBC-MAC (CCM)\"\n *\n * Related:\n * RFC 5116 \"An Interface and Algorithms for Authenticated Encryption\"\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_CCM_C)\n\n#include \"mbedtls/ccm.h\"\n\n#include <string.h>\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdio.h>\n#define mbedtls_printf printf\n#endif /* MBEDTLS_PLATFORM_C */\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#if !defined(MBEDTLS_CCM_ALT)\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;\n}\n\n#define CCM_ENCRYPT 0\n#define CCM_DECRYPT 1\n\n/*\n * Initialize context\n */\nvoid mbedtls_ccm_init( mbedtls_ccm_context *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_ccm_context ) );\n}\n\nint mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,\n                        mbedtls_cipher_id_t cipher,\n                        const unsigned char *key,\n                        unsigned int keybits )\n{\n    int ret;\n    const mbedtls_cipher_info_t *cipher_info;\n\n    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );\n    if( cipher_info == NULL )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    if( cipher_info->block_size != 16 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n\n    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,\n                               MBEDTLS_ENCRYPT ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}\n\n/*\n * Free context\n */\nvoid mbedtls_ccm_free( mbedtls_ccm_context *ctx )\n{\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n    mbedtls_zeroize( ctx, sizeof( mbedtls_ccm_context ) );\n}\n\n/*\n * Macros for common operations.\n * Results in smaller compiled code than static inline functions.\n */\n\n/*\n * Update the CBC-MAC state in y using a block in b\n * (Always using b as the source helps the compiler optimise a bit better.)\n */\n#define UPDATE_CBC_MAC                                                      \\\n    for( i = 0; i < 16; i++ )                                               \\\n        y[i] ^= b[i];                                                       \\\n                                                                            \\\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, y, 16, y, &olen ) ) != 0 ) \\\n        return( ret );\n\n/*\n * Encrypt or decrypt a partial block with CTR\n * Warning: using b for temporary storage! src and dst must not be b!\n * This avoids allocating one more 16 bytes buffer while allowing src == dst.\n */\n#define CTR_CRYPT( dst, src, len  )                                            \\\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctr, 16, b, &olen ) ) != 0 )  \\\n        return( ret );                                                         \\\n                                                                               \\\n    for( i = 0; i < len; i++ )                                                 \\\n        dst[i] = src[i] ^ b[i];\n\n/*\n * Authenticated encryption or decryption\n */\nstatic int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,\n                           const unsigned char *iv, size_t iv_len,\n                           const unsigned char *add, size_t add_len,\n                           const unsigned char *input, unsigned char *output,\n                           unsigned char *tag, size_t tag_len )\n{\n    int ret;\n    unsigned char i;\n    unsigned char q;\n    size_t len_left, olen;\n    unsigned char b[16];\n    unsigned char y[16];\n    unsigned char ctr[16];\n    const unsigned char *src;\n    unsigned char *dst;\n\n    /*\n     * Check length requirements: SP800-38C A.1\n     * Additional requirement: a < 2^16 - 2^8 to simplify the code.\n     * 'length' checked later (when writing it to the first block)\n     */\n    if( tag_len < 4 || tag_len > 16 || tag_len % 2 != 0 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    /* Also implies q is within bounds */\n    if( iv_len < 7 || iv_len > 13 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    if( add_len > 0xFF00 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n    q = 16 - 1 - (unsigned char) iv_len;\n\n    /*\n     * First block B_0:\n     * 0        .. 0        flags\n     * 1        .. iv_len   nonce (aka iv)\n     * iv_len+1 .. 15       length\n     *\n     * With flags as (bits):\n     * 7        0\n     * 6        add present?\n     * 5 .. 3   (t - 2) / 2\n     * 2 .. 0   q - 1\n     */\n    b[0] = 0;\n    b[0] |= ( add_len > 0 ) << 6;\n    b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;\n    b[0] |= q - 1;\n\n    memcpy( b + 1, iv, iv_len );\n\n    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )\n        b[15-i] = (unsigned char)( len_left & 0xFF );\n\n    if( len_left > 0 )\n        return( MBEDTLS_ERR_CCM_BAD_INPUT );\n\n\n    /* Start CBC-MAC with first block */\n    memset( y, 0, 16 );\n    UPDATE_CBC_MAC;\n\n    /*\n     * If there is additional data, update CBC-MAC with\n     * add_len, add, 0 (padding to a block boundary)\n     */\n    if( add_len > 0 )\n    {\n        size_t use_len;\n        len_left = add_len;\n        src = add;\n\n        memset( b, 0, 16 );\n        b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );\n        b[1] = (unsigned char)( ( add_len      ) & 0xFF );\n\n        use_len = len_left < 16 - 2 ? len_left : 16 - 2;\n        memcpy( b + 2, src, use_len );\n        len_left -= use_len;\n        src += use_len;\n\n        UPDATE_CBC_MAC;\n\n        while( len_left > 0 )\n        {\n            use_len = len_left > 16 ? 16 : len_left;\n\n            memset( b, 0, 16 );\n            memcpy( b, src, use_len );\n            UPDATE_CBC_MAC;\n\n            len_left -= use_len;\n            src += use_len;\n        }\n    }\n\n    /*\n     * Prepare counter block for encryption:\n     * 0        .. 0        flags\n     * 1        .. iv_len   nonce (aka iv)\n     * iv_len+1 .. 15       counter (initially 1)\n     *\n     * With flags as (bits):\n     * 7 .. 3   0\n     * 2 .. 0   q - 1\n     */\n    ctr[0] = q - 1;\n    memcpy( ctr + 1, iv, iv_len );\n    memset( ctr + 1 + iv_len, 0, q );\n    ctr[15] = 1;\n\n    /*\n     * Authenticate and {en,de}crypt the message.\n     *\n     * The only difference between encryption and decryption is\n     * the respective order of authentication and {en,de}cryption.\n     */\n    len_left = length;\n    src = input;\n    dst = output;\n\n    while( len_left > 0 )\n    {\n        size_t use_len = len_left > 16 ? 16 : len_left;\n\n        if( mode == CCM_ENCRYPT )\n        {\n            memset( b, 0, 16 );\n            memcpy( b, src, use_len );\n            UPDATE_CBC_MAC;\n        }\n\n        CTR_CRYPT( dst, src, use_len );\n\n        if( mode == CCM_DECRYPT )\n        {\n            memset( b, 0, 16 );\n            memcpy( b, dst, use_len );\n            UPDATE_CBC_MAC;\n        }\n\n        dst += use_len;\n        src += use_len;\n        len_left -= use_len;\n\n        /*\n         * Increment counter.\n         * No need to check for overflow thanks to the length check above.\n         */\n        for( i = 0; i < q; i++ )\n            if( ++ctr[15-i] != 0 )\n                break;\n    }\n\n    /*\n     * Authentication: reset counter and crypt/mask internal tag\n     */\n    for( i = 0; i < q; i++ )\n        ctr[15-i] = 0;\n\n    CTR_CRYPT( y, y, 16 );\n    memcpy( tag, y, tag_len );\n\n    return( 0 );\n}\n\n/*\n * Authenticated encryption\n */\nint mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,\n                         const unsigned char *iv, size_t iv_len,\n                         const unsigned char *add, size_t add_len,\n                         const unsigned char *input, unsigned char *output,\n                         unsigned char *tag, size_t tag_len )\n{\n    return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,\n                            add, add_len, input, output, tag, tag_len ) );\n}\n\n/*\n * Authenticated decryption\n */\nint mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,\n                      const unsigned char *iv, size_t iv_len,\n                      const unsigned char *add, size_t add_len,\n                      const unsigned char *input, unsigned char *output,\n                      const unsigned char *tag, size_t tag_len )\n{\n    int ret;\n    unsigned char check_tag[16];\n    unsigned char i;\n    int diff;\n\n    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,\n                                iv, iv_len, add, add_len,\n                                input, output, check_tag, tag_len ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* Check tag in \"constant-time\" */\n    for( diff = 0, i = 0; i < tag_len; i++ )\n        diff |= tag[i] ^ check_tag[i];\n\n    if( diff != 0 )\n    {\n        mbedtls_zeroize( output, length );\n        return( MBEDTLS_ERR_CCM_AUTH_FAILED );\n    }\n\n    return( 0 );\n}\n\n#endif /* !MBEDTLS_CCM_ALT */\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n/*\n * Examples 1 to 3 from SP800-38C Appendix C\n */\n\n#define NB_TESTS 3\n\n/*\n * The data is the same for all tests, only the used length changes\n */\nstatic const unsigned char key[] = {\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f\n};\n\nstatic const unsigned char iv[] = {\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b\n};\n\nstatic const unsigned char ad[] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13\n};\n\nstatic const unsigned char msg[] = {\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n};\n\nstatic const size_t iv_len [NB_TESTS] = { 7, 8,  12 };\nstatic const size_t add_len[NB_TESTS] = { 8, 16, 20 };\nstatic const size_t msg_len[NB_TESTS] = { 4, 16, 24 };\nstatic const size_t tag_len[NB_TESTS] = { 4, 6,  8  };\n\nstatic const unsigned char res[NB_TESTS][32] = {\n    {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },\n    {   0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,\n        0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,\n        0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd },\n    {   0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,\n        0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,\n        0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,\n        0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51 }\n};\n\nint mbedtls_ccm_self_test( int verbose )\n{\n    mbedtls_ccm_context ctx;\n    unsigned char out[32];\n    size_t i;\n    int ret;\n\n    mbedtls_ccm_init( &ctx );\n\n    if( mbedtls_ccm_setkey( &ctx, MBEDTLS_CIPHER_ID_AES, key, 8 * sizeof key ) != 0 )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  CCM: setup failed\" );\n\n        return( 1 );\n    }\n\n    for( i = 0; i < NB_TESTS; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  CCM-AES #%u: \", (unsigned int) i + 1 );\n\n        ret = mbedtls_ccm_encrypt_and_tag( &ctx, msg_len[i],\n                                   iv, iv_len[i], ad, add_len[i],\n                                   msg, out,\n                                   out + msg_len[i], tag_len[i] );\n\n        if( ret != 0 ||\n            memcmp( out, res[i], msg_len[i] + tag_len[i] ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        ret = mbedtls_ccm_auth_decrypt( &ctx, msg_len[i],\n                                iv, iv_len[i], ad, add_len[i],\n                                res[i], out,\n                                res[i] + msg_len[i], tag_len[i] );\n\n        if( ret != 0 ||\n            memcmp( out, msg, msg_len[i] ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    mbedtls_ccm_free( &ctx );\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    return( 0 );\n}\n\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#endif /* MBEDTLS_CCM_C */\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRa MAC layer implementation\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n#include \"LoRaMacCommand.h\"\n#include \"LoRaMac.h\"\n\n#if defined(FEATURE_COMMON_PAL)\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LMACC\"\n#else\n#define tr_debug(...) printf(\"[LMACC][DBG] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_info(...)  printf(\"[LMACC][INF] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_error(...) printf(\"[LMACC][ERR] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_warn(...) printf(\"[LMACC][WRN] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#endif //defined(FEATURE_COMMON_PAL)\n\n/**\n * LoRaMAC max EIRP (dBm) table.\n */\nstatic const uint8_t max_eirp_table[] = { 8, 10, 12, 13, 14, 16, 18, 20, 21, 24, 26, 27, 29, 30, 33, 36 };\n\n\nLoRaMacCommand::LoRaMacCommand()\n{\n    mac_cmd_in_next_tx = false;\n    sticky_mac_cmd = false;\n    mac_cmd_buf_idx = 0;\n    mac_cmd_buf_idx_to_repeat = 0;\n\n    memset(mac_cmd_buffer, 0, sizeof(mac_cmd_buffer));\n    memset(mac_cmd_buffer_to_repeat, 0, sizeof(mac_cmd_buffer_to_repeat));\n}\n\nLoRaMacCommand::~LoRaMacCommand()\n{\n}\n\nlorawan_status_t LoRaMacCommand::add_mac_command(uint8_t cmd, uint8_t p1,\n                                                 uint8_t p2)\n{\n    lorawan_status_t status = LORAWAN_STATUS_BUSY;\n    // The maximum buffer length must take MAC commands to re-send into account.\n    const uint8_t bufLen = LORA_MAC_COMMAND_MAX_LENGTH\n            - mac_cmd_buf_idx_to_repeat;\n\n    switch (cmd) {\n        case MOTE_MAC_LINK_CHECK_REQ:\n            if (mac_cmd_buf_idx < bufLen) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // No payload for this command\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_LINK_ADR_ANS:\n            if (mac_cmd_buf_idx < (bufLen - 1)) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // Margin\n                mac_cmd_buffer[mac_cmd_buf_idx++] = p1;\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_DUTY_CYCLE_ANS:\n            if (mac_cmd_buf_idx < bufLen) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // No payload for this answer\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_RX_PARAM_SETUP_ANS:\n            if (mac_cmd_buf_idx < (bufLen - 1)) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // Status: Datarate ACK, Channel ACK\n                mac_cmd_buffer[mac_cmd_buf_idx++] = p1;\n                // This is a sticky MAC command answer. Setup indication\n//                _lora_mac.set_mlme_schedule_ul_indication();\n                sticky_mac_cmd = true;\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_DEV_STATUS_ANS:\n            if (mac_cmd_buf_idx < (bufLen - 2)) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // 1st byte Battery\n                // 2nd byte Margin\n                mac_cmd_buffer[mac_cmd_buf_idx++] = p1;\n                mac_cmd_buffer[mac_cmd_buf_idx++] = p2;\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_NEW_CHANNEL_ANS:\n            if (mac_cmd_buf_idx < (bufLen - 1)) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // Status: Datarate range OK, Channel frequency OK\n                mac_cmd_buffer[mac_cmd_buf_idx++] = p1;\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_RX_TIMING_SETUP_ANS:\n            if (mac_cmd_buf_idx < bufLen) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // No payload for this answer\n                // This is a sticky MAC command answer. Setup indication\n//                _lora_mac.set_mlme_schedule_ul_indication();\n                sticky_mac_cmd = true;\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_TX_PARAM_SETUP_ANS:\n            if (mac_cmd_buf_idx < bufLen) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // No payload for this answer\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        case MOTE_MAC_DL_CHANNEL_ANS:\n            if (mac_cmd_buf_idx < bufLen) {\n                mac_cmd_buffer[mac_cmd_buf_idx++] = cmd;\n                // Status: Uplink frequency exists, Channel frequency OK\n                mac_cmd_buffer[mac_cmd_buf_idx++] = p1;\n                // This is a sticky MAC command answer. Setup indication\n//                _lora_mac.set_mlme_schedule_ul_indication();\n                sticky_mac_cmd = true;\n                status = LORAWAN_STATUS_OK;\n            }\n            break;\n        default:\n            return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n    if (status == LORAWAN_STATUS_OK) {\n        mac_cmd_in_next_tx = true;\n    }\n    return status;\n}\n\nvoid LoRaMacCommand::clear_command_buffer()\n{\n    mac_cmd_buf_idx = 0;\n}\n\nuint8_t LoRaMacCommand::get_mac_cmd_length() const\n{\n    return mac_cmd_buf_idx;\n}\n\nuint8_t *LoRaMacCommand::get_mac_commands_buffer()\n{\n    return mac_cmd_buffer;\n}\n\nvoid LoRaMacCommand::parse_mac_commands_to_repeat()\n{\n    uint8_t i = 0;\n    uint8_t cmd_cnt = 0;\n\n    for (i = 0; i < mac_cmd_buf_idx; i++) {\n        switch (mac_cmd_buffer[i]) {\n            // STICKY\n            case MOTE_MAC_DL_CHANNEL_ANS:\n            case MOTE_MAC_RX_PARAM_SETUP_ANS: { // 1 byte payload\n                mac_cmd_buffer_to_repeat[cmd_cnt++] = mac_cmd_buffer[i++];\n                mac_cmd_buffer_to_repeat[cmd_cnt++] = mac_cmd_buffer[i];\n                break;\n            }\n            case MOTE_MAC_RX_TIMING_SETUP_ANS: { // 0 byte payload\n                mac_cmd_buffer_to_repeat[cmd_cnt++] = mac_cmd_buffer[i];\n                break;\n            }\n                // NON-STICKY\n            case MOTE_MAC_DEV_STATUS_ANS: { // 2 bytes payload\n                i += 2;\n                break;\n            }\n            case MOTE_MAC_LINK_ADR_ANS:\n            case MOTE_MAC_NEW_CHANNEL_ANS: { // 1 byte payload\n                i++;\n                break;\n            }\n            case MOTE_MAC_TX_PARAM_SETUP_ANS:\n            case MOTE_MAC_DUTY_CYCLE_ANS:\n            case MOTE_MAC_LINK_CHECK_REQ: { // 0 byte payload\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    if (cmd_cnt > 0) {\n        mac_cmd_in_next_tx = true;\n    } else {\n        mac_cmd_in_next_tx = false;\n    }\n    mac_cmd_buf_idx_to_repeat = cmd_cnt;\n}\n\n\nvoid LoRaMacCommand::clear_repeat_buffer()\n{\n    mac_cmd_buf_idx_to_repeat = 0;\n}\n\nvoid LoRaMacCommand::copy_repeat_commands_to_buffer()\n{\n    memcpy(&mac_cmd_buffer[mac_cmd_buf_idx], mac_cmd_buffer_to_repeat, mac_cmd_buf_idx_to_repeat);\n    mac_cmd_buf_idx += mac_cmd_buf_idx_to_repeat;\n}\n\nuint8_t LoRaMacCommand::get_repeat_commands_length() const\n{\n    return mac_cmd_buf_idx_to_repeat;\n}\n\nvoid LoRaMacCommand::clear_mac_commands_in_next_tx()\n{\n    mac_cmd_in_next_tx = false;\n}\n\nbool LoRaMacCommand::is_mac_command_in_next_tx() const\n{\n    return mac_cmd_in_next_tx;\n}\n\nvoid LoRaMacCommand::clear_sticky_mac_cmd()\n{\n    sticky_mac_cmd = false;\n}\n\nbool LoRaMacCommand::has_sticky_mac_cmd() const\n{\n    return sticky_mac_cmd;\n}\n\nlorawan_status_t LoRaMacCommand::process_mac_commands(uint8_t *payload, uint8_t mac_index,\n                                                      uint8_t commands_size, uint8_t snr,\n                                                      loramac_mlme_confirm_t& mlme_conf,\n                                                      lora_mac_system_params_t &mac_sys_params,\n                                                      LoRaPHY &lora_phy)\n{\n    uint8_t status = 0;\n    lorawan_status_t ret_value = LORAWAN_STATUS_OK;\n\n    while (mac_index < commands_size) {\n        // Decode Frame MAC commands\n        switch (payload[mac_index++]) {\n            case SRV_MAC_LINK_CHECK_ANS:\n                mlme_conf.status = LORAMAC_EVENT_INFO_STATUS_OK;\n                mlme_conf.demod_margin = payload[mac_index++];\n                mlme_conf.nb_gateways = payload[mac_index++];\n                break;\n            case SRV_MAC_LINK_ADR_REQ: {\n                adr_req_params_t linkAdrReq;\n                int8_t linkAdrDatarate = DR_0;\n                int8_t linkAdrTxPower = TX_POWER_0;\n                uint8_t linkAdrNbRep = 0;\n                uint8_t linkAdrNbBytesParsed = 0;\n\n                // Fill parameter structure\n                linkAdrReq.payload = &payload[mac_index - 1];\n                linkAdrReq.payload_size = commands_size - (mac_index - 1);\n                linkAdrReq.adr_enabled = mac_sys_params.adr_on;\n                linkAdrReq.ul_dwell_time = mac_sys_params.uplink_dwell_time;\n                linkAdrReq.current_datarate = mac_sys_params.channel_data_rate;\n                linkAdrReq.current_tx_power = mac_sys_params.channel_tx_power;\n                linkAdrReq.current_nb_rep = mac_sys_params.retry_num;\n\n                // Process the ADR requests\n                status = lora_phy.link_ADR_request(&linkAdrReq,\n                                                   &linkAdrDatarate,\n                                                   &linkAdrTxPower,\n                                                   &linkAdrNbRep,\n                                                   &linkAdrNbBytesParsed);\n\n                if ((status & 0x07) == 0x07) {\n                    mac_sys_params.channel_data_rate = linkAdrDatarate;\n                    mac_sys_params.channel_tx_power = linkAdrTxPower;\n                    mac_sys_params.retry_num = linkAdrNbRep;\n                }\n\n                // Add the answers to the buffer\n                for (uint8_t i = 0; i < (linkAdrNbBytesParsed / 5); i++) {\n                    ret_value = add_mac_command(MOTE_MAC_LINK_ADR_ANS, status, 0);\n                }\n                // Update MAC index\n                mac_index += linkAdrNbBytesParsed - 1;\n            }\n                break;\n            case SRV_MAC_DUTY_CYCLE_REQ:\n                mac_sys_params.max_duty_cycle = payload[mac_index++];\n                mac_sys_params.aggregated_duty_cycle = 1 << mac_sys_params.max_duty_cycle;\n                ret_value = add_mac_command(MOTE_MAC_DUTY_CYCLE_ANS, 0, 0);\n                break;\n            case SRV_MAC_RX_PARAM_SETUP_REQ: {\n                rx_param_setup_req_t rxParamSetupReq;\n\n                rxParamSetupReq.dr_offset = (payload[mac_index] >> 4) & 0x07;\n                rxParamSetupReq.datarate = payload[mac_index] & 0x0F;\n                mac_index++;\n\n                rxParamSetupReq.frequency = (uint32_t) payload[mac_index++];\n                rxParamSetupReq.frequency |= (uint32_t) payload[mac_index++]\n                        << 8;\n                rxParamSetupReq.frequency |= (uint32_t) payload[mac_index++]\n                        << 16;\n                rxParamSetupReq.frequency *= 100;\n\n                // Perform request on region\n                status = lora_phy.accept_rx_param_setup_req(&rxParamSetupReq);\n\n                if ((status & 0x07) == 0x07) {\n                    mac_sys_params.rx2_channel.datarate =\n                            rxParamSetupReq.datarate;\n                    mac_sys_params.rx2_channel.frequency =\n                            rxParamSetupReq.frequency;\n                    mac_sys_params.rx1_dr_offset = rxParamSetupReq.dr_offset;\n                }\n                ret_value = add_mac_command(MOTE_MAC_RX_PARAM_SETUP_ANS, status,\n                                            0);\n            }\n                break;\n            case SRV_MAC_DEV_STATUS_REQ: {\n                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;\n                // we don't have a mechanism at the moment to measure\n                // battery levels\n                ret_value = add_mac_command(MOTE_MAC_DEV_STATUS_ANS,\n                                            batteryLevel, snr);\n                break;\n            }\n            case SRV_MAC_NEW_CHANNEL_REQ: {\n                new_channel_req_params_t newChannelReq;\n                channel_params_t chParam;\n\n                newChannelReq.channel_id = payload[mac_index++];\n                newChannelReq.new_channel = &chParam;\n\n                chParam.frequency = (uint32_t) payload[mac_index++];\n                chParam.frequency |= (uint32_t) payload[mac_index++] << 8;\n                chParam.frequency |= (uint32_t) payload[mac_index++] << 16;\n                chParam.frequency *= 100;\n                chParam.rx1_frequency = 0;\n                chParam.dr_range.value = payload[mac_index++];\n\n                status = lora_phy.request_new_channel(&newChannelReq);\n\n                ret_value = add_mac_command(MOTE_MAC_NEW_CHANNEL_ANS, status, 0);\n            }\n                break;\n            case SRV_MAC_RX_TIMING_SETUP_REQ: {\n                uint8_t delay = payload[mac_index++] & 0x0F;\n\n                if (delay == 0) {\n                    delay++;\n                }\n                mac_sys_params.recv_delay1 = delay * 1000;\n                mac_sys_params.recv_delay2 = mac_sys_params.recv_delay1 + 1000;\n                ret_value = add_mac_command(MOTE_MAC_RX_TIMING_SETUP_ANS, 0, 0);\n            }\n                break;\n            case SRV_MAC_TX_PARAM_SETUP_REQ: {\n                tx_param_setup_req_t txParamSetupReq;\n                uint8_t eirpDwellTime = payload[mac_index++];\n\n                txParamSetupReq.ul_dwell_time = 0;\n                txParamSetupReq.dl_dwell_time = 0;\n\n                if ((eirpDwellTime & 0x20) == 0x20) {\n                    txParamSetupReq.dl_dwell_time = 1;\n                }\n                if ((eirpDwellTime & 0x10) == 0x10) {\n                    txParamSetupReq.ul_dwell_time = 1;\n                }\n                txParamSetupReq.max_eirp = eirpDwellTime & 0x0F;\n\n                // Check the status for correctness\n                if (lora_phy.accept_tx_param_setup_req(&txParamSetupReq)) {\n                    // Accept command\n                    mac_sys_params.uplink_dwell_time =\n                            txParamSetupReq.ul_dwell_time;\n                    mac_sys_params.downlink_dwell_time =\n                            txParamSetupReq.dl_dwell_time;\n                    mac_sys_params.max_eirp =\n                            max_eirp_table[txParamSetupReq.max_eirp];\n                    // Add command response\n                    ret_value = add_mac_command(MOTE_MAC_TX_PARAM_SETUP_ANS, 0, 0);\n                }\n            }\n                break;\n            case SRV_MAC_DL_CHANNEL_REQ: {\n                dl_channel_req_params_t dlChannelReq;\n\n                dlChannelReq.channel_id = payload[mac_index++];\n                dlChannelReq.rx1_frequency = (uint32_t) payload[mac_index++];\n                dlChannelReq.rx1_frequency |= (uint32_t) payload[mac_index++] << 8;\n                dlChannelReq.rx1_frequency |= (uint32_t) payload[mac_index++] << 16;\n                dlChannelReq.rx1_frequency *= 100;\n\n                status = lora_phy.dl_channel_request(&dlChannelReq);\n\n                ret_value = add_mac_command(MOTE_MAC_DL_CHANNEL_ANS, status, 0);\n            }\n                break;\n            default:\n                // Unknown command. ABORT MAC commands processing\n                ret_value = LORAWAN_STATUS_UNSUPPORTED;\n        }\n    }\n    return ret_value;\n}\n\nbool LoRaMacCommand::is_sticky_mac_command_pending()\n{\n    if (mac_cmd_buf_idx_to_repeat > 0) {\n        return true;\n    }\n    return false;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_TICKER_H\n#define MBED_TICKER_H\n\n#include \"drivers/TimerEvent.h\"\n#include \"platform/Callback.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/mbed_power_mgmt.h\"\n#include \"hal/lp_ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A Ticker is used to call a function at a recurring interval\n *\n *  You can use as many separate Ticker objects as you require.\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle the blinking led after 5 seconds\n *\n * #include \"mbed.h\"\n *\n * Ticker timer;\n * DigitalOut led1(LED1);\n * DigitalOut led2(LED2);\n *\n * int flip = 0;\n *\n * void attime() {\n *     flip = !flip;\n * }\n *\n * int main() {\n *     timer.attach(&attime, 5);\n *     while(1) {\n *         if(flip == 0) {\n *             led1 = !led1;\n *         } else {\n *             led2 = !led2;\n *         }\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass Ticker : public TimerEvent, private NonCopyable<Ticker> {\n\npublic:\n    Ticker() : TimerEvent(), _function(0), _lock_deepsleep(true) {\n    }\n\n    // When low power ticker is in use, then do not disable deep-sleep.\n    Ticker(const ticker_data_t *data) : TimerEvent(data), _function(0), _lock_deepsleep(true)  {\n#if DEVICE_LOWPOWERTIMER\n        _lock_deepsleep = (data != get_lp_ticker_data());\n#endif\n    }\n\n    /** Attach a function to be called by the Ticker, specifying the interval in seconds\n     *\n     *  @param func pointer to the function to be called\n     *  @param t the time between calls in seconds\n     */\n    void attach(Callback<void()> func, float t) {\n        attach_us(func, t * 1000000.0f);\n    }\n\n    /** Attach a member function to be called by the Ticker, specifying the interval in seconds\n     *\n     *  @param obj pointer to the object to call the member function on\n     *  @param method pointer to the member function to be called\n     *  @param t the time between calls in seconds\n     *  @deprecated\n     *      The attach function does not support cv-qualifiers. Replaced by\n     *      attach(callback(obj, method), t).\n     */\n    template<typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach function does not support cv-qualifiers. Replaced by \"\n        \"attach(callback(obj, method), t).\")\n    void attach(T *obj, M method, float t) {\n        attach(callback(obj, method), t);\n    }\n\n    /** Attach a function to be called by the Ticker, specifying the interval in micro-seconds\n     *\n     *  @param func pointer to the function to be called\n     *  @param t the time between calls in micro-seconds\n     *\n     *  @note setting @a t to a value shorter that it takes to process the ticker callback\n     *  will cause the system to hang. Ticker callback will be called constantly with no time\n     *  for threads scheduling.\n     *\n     */\n    void attach_us(Callback<void()> func, us_timestamp_t t) {\n        core_util_critical_section_enter();\n        // lock only for the initial callback setup and this is not low power ticker\n#if DEVICE_SLEEP\n        if(!_function && _lock_deepsleep) {\n            sleep_manager_lock_deep_sleep();\n        }\n#endif\n        _function = func;\n        setup(t);\n        core_util_critical_section_exit();\n    }\n\n    /** Attach a member function to be called by the Ticker, specifying the interval in micro-seconds\n     *\n     *  @param obj pointer to the object to call the member function on\n     *  @param method pointer to the member function to be called\n     *  @param t the time between calls in micro-seconds\n     *  @deprecated\n     *      The attach_us function does not support cv-qualifiers. Replaced by\n     *      attach_us(callback(obj, method), t).\n     */\n    template<typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach_us function does not support cv-qualifiers. Replaced by \"\n        \"attach_us(callback(obj, method), t).\")\n    void attach_us(T *obj, M method, us_timestamp_t t) {\n        attach_us(Callback<void()>(obj, method), t);\n    }\n\n    virtual ~Ticker() {\n        detach();\n    }\n\n    /** Detach the function\n     */\n    void detach();\n\nprotected:\n    void setup(us_timestamp_t t);\n    virtual void handler();\n\nprotected:\n    us_timestamp_t         _delay;  /**< Time delay (in microseconds) for re-setting the multi-shot callback. */\n    Callback<void()>    _function;  /**< Callback. */\n    bool          _lock_deepsleep;  /**< Flag which indicates if deep-sleep should be disabled. */\n};\n\n} // namespace mbed\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdio.h>\n#include <math.h> //rint\n#include <string.h>\n#include \"mbed.h\"\n#include \"SX1276_LoRaRadio.h\"\n#include \"sx1276Regs-Fsk.h\"\n#include \"sx1276Regs-LoRa.h\"\n\n#define tr_debug(...) void(0) //dummies if feature common pal is not added\n#define tr_info(...)  printf(\"[RADIO][INF] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_error(...) printf(\"[RADIO][ERR] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_warn(...) printf(\"[RADIO][WRN] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n\n/*!\n * Sync word for Private LoRa networks\n */\n#define LORA_MAC_PRIVATE_SYNCWORD                   0x12\n\n/*!\n * Sync word for Public LoRa networks\n */\n#define LORA_MAC_PUBLIC_SYNCWORD                    0x34\n\n/*!\n * SX1276 definitions\n */\n#define XTAL_FREQ                                   32000000\n#define FREQ_STEP                                   61.03515625\n\n/*!\n * Constant values need to compute the RSSI value\n */\n#define RSSI_OFFSET_LF                              -164.0\n#define RSSI_OFFSET_HF                              -157.0\n#define RF_MID_BAND_THRESH                          525000000\n\n\n/*!\n * FSK bandwidth definition\n */\ntypedef struct\n{\n    uint32_t bandwidth;\n    uint8_t  register_value;\n} fsk_bw_t;\n\n/*!\n * Radio registers definition\n */\ntypedef struct\n{\n    uint8_t     modem;\n    uint8_t     addr;\n    uint8_t     value;\n} radio_registers_t;\n\n#define RADIO_INIT_REGISTERS_VALUE                \\\n{                                                 \\\n    { MODEM_FSK , REG_LNA                , 0x23 },\\\n    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\\\n    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\\\n    { MODEM_FSK , REG_AFCFEI             , 0x01 },\\\n    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\\\n    { MODEM_FSK , REG_OSC                , 0x07 },\\\n    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\\\n    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\\\n    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\\\n    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\\\n    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\\\n    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\\\n    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\\\n    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\\\n    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\\\n    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\\\n}\n\nstatic const fsk_bw_t fsk_bandwidths[] =\n{\n    { 2600  , 0x17 },\n    { 3100  , 0x0F },\n    { 3900  , 0x07 },\n    { 5200  , 0x16 },\n    { 6300  , 0x0E },\n    { 7800  , 0x06 },\n    { 10400 , 0x15 },\n    { 12500 , 0x0D },\n    { 15600 , 0x05 },\n    { 20800 , 0x14 },\n    { 25000 , 0x0C },\n    { 31300 , 0x04 },\n    { 41700 , 0x13 },\n    { 50000 , 0x0B },\n    { 62500 , 0x03 },\n    { 83333 , 0x12 },\n    { 100000, 0x0A },\n    { 125000, 0x02 },\n    { 166700, 0x11 },\n    { 200000, 0x09 },\n    { 250000, 0x01 },\n    { 300000, 0x00 }, // Invalid bandwidth\n};\n\n/**\n * SPI read/write masks\n */\n#define SPI_WRITE_CMD   0x80\n#define SPI_READ_CMD    0x7F\n\n/**\n * Signals\n */\n#define SIG_DIO0    0x01\n#define SIG_DIO1    0x02\n#define SIG_DIO2    0x04\n#define SIG_DIO3    0x08\n#define SIG_DIO4    0x10\n#define SIG_DIO5    0x20\n#define SIG_TIMOUT  0x40\n\n/**\n * Radio hardware registers initialization\n */\nstatic const radio_registers_t radio_reg_init[] = RADIO_INIT_REGISTERS_VALUE;\n\nenum RadioVariant {\n    SX1276UNDEFINED = 0,\n    SX1276MB1LAS,\n    SX1276MB1MAS\n};\n\n#ifdef MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#define SPI_FREQUENCY    MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#else\n#define SPI_FREQUENCY    8000000\n#endif\n\n/**\n * Constructor\n */\nSX1276_LoRaRadio::SX1276_LoRaRadio(PinName spi_mosi,\n                                   PinName spi_miso,\n                                   PinName spi_sclk,\n                                   PinName nss,\n                                   PinName reset,\n                                   PinName dio0,\n                                   PinName dio1,\n                                   PinName dio2,\n                                   PinName dio3,\n                                   PinName dio4,\n                                   PinName dio5,\n                                   PinName rf_switch_ctl1,\n                                   PinName rf_switch_ctl2,\n                                   PinName txctl,\n                                   PinName rxctl,\n                                   PinName antswitch,\n                                   PinName pwr_amp_ctl,\n                                   PinName tcxo)\n    :  _chip_select(nss, 1),\n        _reset_ctl(reset),\n        _dio0_ctl(dio0), _dio1_ctl(dio1), _dio2_ctl(dio2), _dio3_ctl(dio3), _dio4_ctl(dio4), _dio5_ctl(dio5),\n        _rf_switch_ctl1(rf_switch_ctl1, 0), _rf_switch_ctl2(rf_switch_ctl2, 0),\n        _txctl(txctl, 0), _rxctl(rxctl, 0),\n        _ant_switch(antswitch, PIN_INPUT, PullUp, 0),\n        _pwr_amp_ctl(pwr_amp_ctl),\n        _tcxo(tcxo)\n\n#ifdef MBED_CONF_RTOS_PRESENT\n        , irq_thread(osPriorityRealtime, 1024)\n#endif\n{\n    _rf_ctrls.ant_switch = antswitch;\n    _rf_ctrls.pwr_amp_ctl = pwr_amp_ctl;\n    _rf_ctrls.rf_switch_ctl1 = rf_switch_ctl1;\n    _rf_ctrls.rf_switch_ctl2 = rf_switch_ctl2;\n    _rf_ctrls.rxctl = rxctl;\n    _rf_ctrls.txctl = txctl;\n    _rf_ctrls.tcxo = tcxo;\n\n    _dio4_pin = dio4;\n    _dio5_pin = dio5;\n\n    _radio_events = NULL;\n\n    if (tcxo != NC) {\n        _tcxo = 1;\n    }\n\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.start(mbed::callback(this, &SX1276_LoRaRadio::rf_irq_task));\n#endif\n\n    EM_ASM_({\n        window.MbedJSHal.lora.init($0);\n    }, this);\n}\n\n/**\n * Destructor\n */\nSX1276_LoRaRadio::~SX1276_LoRaRadio()\n{\n\n}\n\n/*****************************************************************************\n * Public APIs                                                               *\n ****************************************************************************/\n/**\n * Acquire lock\n */\nvoid SX1276_LoRaRadio::lock(void)\n{\n    mutex.lock();\n}\n\n/**\n * Release lock\n */\nvoid SX1276_LoRaRadio::unlock(void)\n{\n    mutex.unlock();\n}\n\n/**\n * Initializes radio module\n */\nvoid SX1276_LoRaRadio::init_radio(radio_events_t *events)\n{\n    _radio_events = events;\n\n    // Reset the radio transceiver\n    radio_reset();\n\n    // set modem type - defaults to FSK here\n    set_modem(MODEM_FSK);\n\n    // set state to be idle\n    _rf_settings.state = RF_IDLE;\n}\n\n/**\n * Can be used by application/stack or the driver itself\n */\nvoid SX1276_LoRaRadio::radio_reset()\n{\n    tr_info(\"radio_reset\");\n}\n\n/**\n * TODO: The purpose of this API is unclear.\n *       Need to start an internal discussion.\n */\nbool SX1276_LoRaRadio::check_rf_frequency(uint32_t frequency)\n{\n    // Implement check. Currently all frequencies are supported ? What band ?\n    return true;\n}\n\n/**\n * Returns current status of the radio state machine\n */\nuint8_t SX1276_LoRaRadio::get_status(void)\n{\n    return _rf_settings.state;\n}\n\n/**\n * Sets up carrier frequency\n */\nvoid SX1276_LoRaRadio::set_channel(uint32_t freq)\n{\n    tr_info(\"set_channel (freq=%u)\", freq);\n    _rf_settings.channel = freq;\n    freq = (uint32_t) ((double) freq / (double) FREQ_STEP);\n}\n\n/**\n * Generates 32 bit random number based upon RSSI monitoring\n * Used for various calculation by the stack for example dev nonce\n *\n * When this API is used modem is set in LoRa mode and all interrupts are\n * masked. If the user had been using FSK mode, it should be noted that a\n * change of mode is required again because the registers have changed.\n * In addition to that RX and TX configuration APIs should be called again in\n * order to have correct desires setup.\n */\nuint32_t SX1276_LoRaRadio::random( void )\n{\n    uint32_t rnd = EM_ASM_INT({\n        return Math.random() * 0x8000000 | 0;\n    });\n\n    sleep();\n\n    return rnd;\n}\n\n/**\n * Sets up receiver related configurations\n *\n * Must be called before setting the radio in rx mode\n */\nvoid SX1276_LoRaRadio::set_rx_config(radio_modems_t modem, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint32_t bandwidth_afc,\n                                     uint16_t preamble_len,\n                                     uint16_t symb_timeout, bool fix_len,\n                                     uint8_t payload_len, bool crc_on,\n                                     bool freq_hop_on, uint8_t hop_period,\n                                     bool iq_inverted, bool rx_continuous)\n{\n    set_modem(modem);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.bandwidth_afc = bandwidth_afc;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.payload_len = payload_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.rx_continuous = rx_continuous;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.rx_single_timeout = symb_timeout\n                    * ((1.0 / (double) datarate) * 8.0) * 1e3;\n\n            datarate = (uint16_t) ((double) XTAL_FREQ / (double) datarate);\n\n            tr_info(\"set_rx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n                // TODO Return a proper error from here\n            }\n\n            // stupid hack. TODO think something better\n            bandwidth+=7;\n\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.payload_len = payload_len;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.rx_continuous = rx_continuous;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            tr_info(\"set_rx_config LORA\");\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Sets up transmitter related configuration\n *\n * Must be called before putting the radio module in Tx mode or trying\n * to send\n */\nvoid SX1276_LoRaRadio::set_tx_config(radio_modems_t modem, int8_t power,\n                                     uint32_t fdev, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint16_t preamble_len, bool fix_len,\n                                     bool crc_on, bool freq_hop_on,\n                                     uint8_t hop_period, bool iq_inverted,\n                                     uint32_t timeout)\n{\n    set_modem(modem);\n    set_rf_tx_power(power);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.power = power;\n            _rf_settings.fsk.f_dev = fdev;\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.tx_timeout = timeout;\n\n            fdev = (uint16_t) ((double) fdev / (double) FREQ_STEP);\n\n            tr_info(\"set_tx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n            _rf_settings.lora.power = power;\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n            }\n            bandwidth += 7;\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.tx_timeout = timeout;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            tr_info(\"set_rx_config LORA\");\n\n            break;\n    }\n}\n\n/**\n * Calculates time on Air i.e., dwell time for a single packet\n *\n * Crucial for the stack in order to calculate dwell time so as to control\n * duty cycling.\n */\nuint32_t SX1276_LoRaRadio::time_on_air(radio_modems_t modem, uint8_t pkt_len)\n{\n    uint32_t airTime = 0;\n\n    tr_info(\"time_on_air\");\n\n    switch (modem) {\n        case MODEM_FSK:\n            airTime = 1;\n\n            break;\n        case MODEM_LORA:\n            double bw = 0.0;\n            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n            switch (_rf_settings.lora.bandwidth) {\n                //case 0: // 7.8 kHz\n                //    bw = 78e2;\n                //    break;\n                //case 1: // 10.4 kHz\n                //    bw = 104e2;\n                //    break;\n                //case 2: // 15.6 kHz\n                //    bw = 156e2;\n                //    break;\n                //case 3: // 20.8 kHz\n                //    bw = 208e2;\n                //    break;\n                //case 4: // 31.2 kHz\n                //    bw = 312e2;\n                //    break;\n                //case 5: // 41.4 kHz\n                //    bw = 414e2;\n                //    break;\n                //case 6: // 62.5 kHz\n                //    bw = 625e2;\n                //    break;\n                case 7: // 125 kHz\n                    bw = 125e3;\n                    break;\n                case 8: // 250 kHz\n                    bw = 250e3;\n                    break;\n                case 9: // 500 kHz\n                    bw = 500e3;\n                    break;\n            }\n\n            // Symbol rate : time for one symbol (secs)\n            double rs = bw / (1 << _rf_settings.lora.datarate);\n            double ts = 1 / rs;\n            // time of preamble\n            double tPreamble = (_rf_settings.lora.preamble_len + 4.25) * ts;\n            // Symbol length of payload and time\n            double tmp = ceil((8 * pkt_len - 4 * _rf_settings.lora.datarate + 28\n                            + 16 * _rf_settings.lora.crc_on\n                            - (_rf_settings.lora.fix_len ? 20 : 0))\n                            / (double) (4\n                                    * (_rf_settings.lora.datarate\n                                            - ((_rf_settings.lora.low_datarate_optimize > 0)\n                                                    ? 2 : 0))))\n                            * (_rf_settings.lora.coderate + 4);\n            double nPayload = 8 + ((tmp > 0) ? tmp : 0);\n            double tPayload = nPayload * ts;\n            // Time on air\n            double tOnAir = tPreamble + tPayload;\n            // return ms secs\n            airTime = floor(tOnAir * 1e3 + 0.999);\n\n            break;\n    }\n\n    tr_info(\"time_on_air will be %u\", airTime);\n\n    return airTime;\n}\n\n/**\n * Prepares and sends the radio packet out in the air\n */\nvoid SX1276_LoRaRadio::send(uint8_t *buffer, uint8_t size)\n{\n    uint32_t tx_timeout = 0;\n\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendFsk($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.fsk.power, _rf_settings.fsk.bandwidth, _rf_settings.fsk.datarate, buffer, size);\n        break;\n\n        case MODEM_LORA:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendLoRa($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.lora.power, _rf_settings.lora.bandwidth, _rf_settings.lora.datarate, buffer, size);\n        break;\n    }\n\n    // tr_info(\"send (modem=%d)\", _rf_settings.modem);\n    // for (size_t ix = 0; ix < size; ix++) {\n    //     printf(\"%02x \", buffer[ix]);\n    // }\n    // printf(\"\\n\");\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = size;\n\n    //         if (_rf_settings.fsk.fix_len == false) {\n    //             write_fifo((uint8_t*) &size, 1);\n    //         } else {\n    //             write_to_register(REG_PAYLOADLENGTH, size);\n    //         }\n\n    //         if ((size > 0) && (size <= 64)) {\n    //             _rf_settings.fsk_packet_handler.chunk_size = size;\n    //         } else {\n    //             memcpy(_data_buffer, buffer, size);\n    //             _rf_settings.fsk_packet_handler.chunk_size = 32;\n    //         }\n\n    //         // Write payload buffer\n    //         write_fifo(buffer, _rf_settings.fsk_packet_handler.chunk_size);\n    //         _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                 _rf_settings.fsk_packet_handler.chunk_size;\n    //         tx_timeout = _rf_settings.fsk.tx_timeout;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register(REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_ON));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         _rf_settings.lora_packet_handler.size = size;\n\n    //         // Initializes the payload size\n    //         write_to_register(REG_LR_PAYLOADLENGTH, size);\n\n    //         // Full buffer used for Tx\n    //         write_to_register(REG_LR_FIFOTXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         // FIFO operations can not take place in Sleep mode\n    //         if ((read_register( REG_OPMODE) & ~RF_OPMODE_MASK) == RF_OPMODE_SLEEP) {\n    //             standby();\n    //             wait_ms(1);\n    //         }\n    //         // write_to_register payload buffer\n    //         write_fifo(buffer, size);\n    //         tx_timeout = _rf_settings.lora.tx_timeout;\n\n    //         break;\n    // }\n\n    transmit(tx_timeout);\n}\n\n/**\n * sets the radio module to sleep\n */\n\nvoid SX1276_LoRaRadio::sleep()\n{\n    tr_info(\"sleep\");\n\n    // stop timers\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    // put module in sleep mode\n    set_operation_mode(RF_OPMODE_SLEEP);\n}\n\n/**\n * Put radio in Standby mode\n */\nvoid SX1276_LoRaRadio::standby( void )\n{\n    tr_info(\"standby\");\n\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    set_operation_mode(RF_OPMODE_STANDBY);\n    _rf_settings.state = RF_IDLE;\n}\n\nvoid SX1276_LoRaRadio::rx_frame(uint8_t* data, uint32_t size) {\n    tr_info(\"rx_frame %u bytes\", size);\n\n    memcpy(_data_buffer, data, size);\n    _rf_settings.lora_packet_handler.size = size;\n    _rf_settings.lora_packet_handler.rssi_value = -35;\n    _rf_settings.lora_packet_handler.snr_value = -5;\n    _rf_settings.lora_packet_handler.pending = true;\n}\n\n/**\n * Sets the radio module in receive mode\n *\n * A DIO4 interrupt let's the state machine know that a preamble is detected\n * and finally a DIO0 interrupt let's the state machine know that a packet is\n * ready to be read from the FIFO\n */\nvoid SX1276_LoRaRadio::receive(uint32_t timeout)\n{\n    tr_info(\"receive (timeout=%u). has_pending=%d\", timeout, _rf_settings.lora_packet_handler.pending);\n\n    _rf_settings.state = RF_RX_RUNNING;\n\n    // q:\n    if (_rf_settings.lora_packet_handler.pending) {\n        _rf_settings.lora_packet_handler.pending = false;\n\n        // after 200 ms. we send the rx_done event\n        rx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::rx_done_irq), 200 * 1e3);\n        return;\n    }\n\n    if (timeout != 0) {\n        rx_timeout_timer.attach_us(\n                callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                timeout * 1e3);\n    }\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         if (timeout == 0 && _rf_settings.fsk.rx_continuous == false) {\n    //              // user messed up probably timeout was 0 but mode was not\n    //              // continuous, force it to be continuous\n    //              _rf_settings.fsk.rx_continuous = true;\n    //          }\n\n    //         // DIO0=PayloadReady\n    //         // DIO1=FifoLevel\n    //         // DIO2=SyncAddr\n    //         // DIO3=FifoEmpty\n    //         // DIO4=Preamble\n    //         // DIO5=ModeReady\n    //         write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                 & RF_DIOMAPPING1_DIO0_MASK\n    //                 & RF_DIOMAPPING1_DIO1_MASK\n    //                 & RF_DIOMAPPING1_DIO2_MASK)\n    //                           | RF_DIOMAPPING1_DIO0_00\n    //                           | RF_DIOMAPPING1_DIO1_00\n    //                           | RF_DIOMAPPING1_DIO2_11);\n\n    //         write_to_register(REG_DIOMAPPING2, (read_register( REG_DIOMAPPING2)\n    //                 & RF_DIOMAPPING2_DIO4_MASK\n    //                 & RF_DIOMAPPING2_MAP_MASK)\n    //                           | RF_DIOMAPPING2_DIO4_11\n    //                           | RF_DIOMAPPING2_MAP_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.fifo_thresh =\n    //                 read_register(REG_FIFOTHRESH) & 0x3F;\n\n    //         write_to_register(REG_RXCONFIG, RF_RXCONFIG_AFCAUTO_ON\n    //                           | RF_RXCONFIG_AGCAUTO_ON\n    //                           | RF_RXCONFIG_RXTRIGER_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = 0;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (timeout == 0 && _rf_settings.lora.rx_continuous == false) {\n    //             // user messed up probably timeout was 0 but mode was not\n    //             // continuous, force it to be continuous\n    //             _rf_settings.lora.rx_continuous = true;\n    //         }\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal\n    //         if (_rf_settings.lora.bandwidth < 9) {\n    //             write_to_register(REG_LR_DETECTOPTIMIZE,\n    //                               read_register(REG_LR_DETECTOPTIMIZE) & 0x7F);\n    //             write_to_register(REG_LR_TEST30, 0x00);\n    //             switch (_rf_settings.lora.bandwidth) {\n    //                 case 0: // 7.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x48);\n    //                     set_channel(_rf_settings.channel + 7.81e3);\n    //                     break;\n    //                 case 1: // 10.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 10.42e3);\n    //                     break;\n    //                 case 2: // 15.6 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 15.62e3);\n    //                     break;\n    //                 case 3: // 20.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 20.83e3);\n    //                     break;\n    //                 case 4: // 31.2 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 31.25e3);\n    //                     break;\n    //                 case 5: // 41.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 41.67e3);\n    //                     break;\n    //                 case 6: // 62.5 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 7: // 125 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 8: // 250 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //             }\n    //         } else {\n    //             write_to_register( REG_LR_DETECTOPTIMIZE,\n    //                               read_register( REG_LR_DETECTOPTIMIZE) | 0x80);\n    //         }\n\n    //         if (_rf_settings.lora.freq_hop_on == true) {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                               | RFLR_IRQFLAGS_TXDONE\n    //                               | RFLR_IRQFLAGS_CADDONE\n    //                               | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone, DIO2=FhssChangeChannel\n    //             write_to_register(REG_DIOMAPPING1, (read_register(REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK\n    //                             & RFLR_DIOMAPPING1_DIO2_MASK)\n    //                             | RFLR_DIOMAPPING1_DIO0_00\n    //                             | RFLR_DIOMAPPING1_DIO2_00);\n    //         } else {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                                | RFLR_IRQFLAGS_TXDONE\n    //                                | RFLR_IRQFLAGS_CADDONE\n    //                                | RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL\n    //                                | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone\n    //             write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK)\n    //                               | RFLR_DIOMAPPING1_DIO0_00);\n    //         }\n    //         write_to_register(REG_LR_FIFORXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         break;\n    // }\n\n    // _rf_settings.state = RF_RX_RUNNING;\n\n    // if (timeout != 0) {\n    //     rx_timeout_timer.attach_us(\n    //             callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //             timeout * 1e3);\n    // }\n\n    // if (_rf_settings.modem == MODEM_FSK) {\n    //     set_operation_mode(RF_OPMODE_RECEIVER);\n\n    //     if (_rf_settings.fsk.rx_continuous == false) {\n    //         rx_timeout_sync_word.attach_us(\n    //                 callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //                 _rf_settings.fsk.rx_single_timeout * 1e3);\n    //     }\n\n    //     return;\n    // }\n\n    // If mode is LoRa set mode\n    if (_rf_settings.lora.rx_continuous == true) {\n        set_operation_mode(RFLR_OPMODE_RECEIVER);\n    } else {\n        set_operation_mode(RFLR_OPMODE_RECEIVER_SINGLE);\n    }\n}\n\n\n/**\n * Perform carrier sensing\n *\n * Checks for a certain time if the RSSI is above a given threshold.\n * This threshold determines if there is already a transmission going on\n * in the channel or not.\n *\n */\nbool SX1276_LoRaRadio::perform_carrier_sense(radio_modems_t modem,\n                                   uint32_t freq,\n                                   int16_t rssi_threshold,\n                                   uint32_t max_carrier_sense_time)\n{\n    tr_info(\"perform_carrier_sense\");\n\n    bool status = true;\n    int16_t rssi = 0;\n\n    set_modem(modem);\n    set_channel(freq);\n    set_operation_mode(RF_OPMODE_RECEIVER);\n\n    // hold on a bit, radio turn-around time\n    wait_ms(1);\n\n    Timer elapsed_time;\n    elapsed_time.start();\n\n    // Perform carrier sense for maxCarrierSenseTime\n    while (elapsed_time.read_ms() < (int)max_carrier_sense_time) {\n        rssi = get_rssi(modem);\n\n        if (rssi > rssi_threshold) {\n            status = false;\n            break;\n        }\n    }\n\n    sleep();\n    return status;\n}\n\n/**\n * TODO: Making sure if this API is valid only for LoRa modulation ?\n *\n * Indicates if the node is part of a private or public network\n */\nvoid SX1276_LoRaRadio::set_public_network(bool enable)\n{\n    set_modem(MODEM_LORA);\n\n    _rf_settings.lora.public_network = enable;\n\n    tr_info(\"set_public_network %d\", enable);\n\n}\n\n/**\n * Puts a limit on the size of payload the module can handle\n * By default it is MAX, i.e., 256 bytes\n */\nvoid SX1276_LoRaRadio::set_max_payload_length(radio_modems_t modem, uint8_t max)\n{\n    set_modem(modem);\n\n    tr_info(\"set_max_payload_length (modem=%d, max=%u)\", modem, max);\n}\n\n/**\n * Channel Activity detection (can be done only in LoRa mode)\n *\n * If any activity on the channel is detected, an interrupt is asserted on\n * DIO3. A callback will be generated to the stack/application upon the\n * assertion of DIO3.\n */\nvoid SX1276_LoRaRadio::start_cad()\n{\n    tr_info(\"start_cad\");\n}\n\n/**\n * Set transmission in continuous wave mode\n */\nvoid SX1276_LoRaRadio::set_tx_continuous_wave(uint32_t freq, int8_t power,\n                                              uint16_t time)\n{\n    tr_info(\"set_tx_continious_wave (freq=%u, power=%u, time=%u)\", freq, power, time);\n\n    uint8_t reg_val;\n\n    set_channel(freq);\n    set_tx_config(MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, time);\n    // reg_val = read_register(REG_PACKETCONFIG2);\n\n    // write_to_register( REG_PACKETCONFIG2, (reg_val & RF_PACKETCONFIG2_DATAMODE_MASK ) );\n    // // Disable radio interrupts\n    // write_to_register( REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11 );\n    // write_to_register( REG_DIOMAPPING2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10 );\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::timeout_irq_isr), time*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n}\n\n/*****************************************************************************\n * Private APIs                                                              *\n ****************************************************************************/\n#ifdef MBED_CONF_RTOS_PRESENT\n/**\n * Thread task handling IRQs\n */\nvoid SX1276_LoRaRadio::rf_irq_task(void)\n{\n    for (;;) {\n        osEvent event = irq_thread.signal_wait(0, osWaitForever);\n        if (event.status != osEventSignal) {\n            continue;\n        }\n\n        lock();\n        if (event.value.signals & SIG_DIO0) {\n            handle_dio0_irq();\n        }\n        if (event.value.signals & SIG_DIO1) {\n            handle_dio1_irq();\n        }\n        if (event.value.signals & SIG_DIO2) {\n            handle_dio2_irq();\n        }\n        if (event.value.signals & SIG_DIO3) {\n            handle_dio3_irq();\n        }\n        if (event.value.signals & SIG_DIO4) {\n            handle_dio4_irq();\n        }\n        if (event.value.signals & SIG_DIO5) {\n            handle_dio5_irq();\n        }\n        if (event.value.signals & SIG_TIMOUT) {\n            handle_timeout_irq();\n        }\n        unlock();\n    }\n}\n#endif\n\n/**\n * Writes to FIIO provided by the chip\n */\nvoid SX1276_LoRaRadio::write_fifo(uint8_t *buffer, uint8_t size)\n{\n    tr_info(\"write_fifo (size=%u)\", size);\n}\n\n/**\n * Reads from the FIFO provided by the chip\n */\nvoid SX1276_LoRaRadio::read_fifo(uint8_t *buffer, uint8_t size)\n{\n    tr_info(\"read_fifo (size=%u)\", size);\n}\n\n/**\n * Sets up operation mode\n */\nvoid SX1276_LoRaRadio::set_operation_mode(uint8_t mode)\n{\n    tr_info(\"set_operation_mode (mode=%u)\", mode);\n\n    if (mode == RF_OPMODE_SLEEP) {\n        set_low_power_mode();\n    } else {\n        set_low_power_mode();\n        set_antenna_switch(mode);\n    }\n}\n\n/**\n * Sets the modem type to use\n *\n * At initialization FSK is chosen. Later stack or application\n * can choose to change.\n */\nvoid SX1276_LoRaRadio::set_modem(uint8_t modem )\n{\n    _rf_settings.modem = modem;\n\n    tr_info(\"set_modem %d\", _rf_settings.modem);\n}\n\n/**\n * Set the radio module variant\n */\nvoid SX1276_LoRaRadio::set_sx1276_variant_type()\n{\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch.input();\n        wait_ms(1);\n        if (_ant_switch == 1) {\n            radio_variant = SX1276MB1LAS;\n        } else {\n            radio_variant = SX1276MB1MAS;\n        }\n        _ant_switch.output();\n        wait_ms(1);\n    } else {\n        radio_variant = SX1276UNDEFINED;\n    }\n}\n\n/**\n * Sets the radio registers to defaults\n */\nvoid SX1276_LoRaRadio::setup_registers()\n{\n    tr_info(\"setup_registers\");\n}\n\n/**\n * Performs the Rx chain calibration for LF and HF bands\n *\n * Must be called just after the reset so all registers are at their\n * default values.\n */\nvoid SX1276_LoRaRadio::rx_chain_calibration(void)\n{\n    tr_info(\"rx_chain_calibration\");\n}\n\n/**\n * Gets FSK bandwidth values\n *\n * Gives either normal bandwidths or bandwidths for\n * AFC (auto frequency correction)\n */\nuint8_t SX1276_LoRaRadio::get_fsk_bw_reg_val(uint32_t bandwidth)\n{\n    uint8_t i;\n\n    for (i = 0; i < (sizeof(fsk_bandwidths) / sizeof(fsk_bw_t)) - 1; i++) {\n        if ((bandwidth >= fsk_bandwidths[i].bandwidth)\n                && (bandwidth < fsk_bandwidths[i + 1].bandwidth)) {\n            return fsk_bandwidths[i].register_value;\n        }\n    }\n    // ERROR: Value not found\n    // This should never happen\n    while (1);\n}\n\nuint8_t SX1276_LoRaRadio::get_pa_conf_reg(uint32_t channel)\n{\n    if (radio_variant == SX1276UNDEFINED) {\n        return RF_PACONFIG_PASELECT_PABOOST;\n    } else if (channel > RF_MID_BAND_THRESH) {\n        if (radio_variant == SX1276MB1LAS) {\n            return RF_PACONFIG_PASELECT_PABOOST;\n        } else {\n            return RF_PACONFIG_PASELECT_RFO;\n        }\n    } else {\n        return RF_PACONFIG_PASELECT_RFO;\n    }\n}\n\n/**\n * Sets the transmit power for the module\n */\nvoid SX1276_LoRaRadio::set_rf_tx_power(int8_t power)\n{\n    tr_info(\"set_rf_tx_power (power=%u)\", power);\n}\n\n/**\n * Actual TX - Transmit routine\n *\n * A DIO0 interrupt let the state machine know that a a packet is\n * successfully sent, otherwise a TxTimeout is invoked.\n * TxTimeout should never happen in normal circumstances as the radio should\n * be able to send a packet out in the air no matter what.\n */\nvoid SX1276_LoRaRadio::transmit(uint32_t timeout)\n{\n    tr_info(\"transmit (timeout=%u)\", timeout);\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this,\n    //                            &SX1276_LoRaRadio::timeout_irq_isr), timeout*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n\n    // after 100ms. we fire the tx_done event\n    tx_done_timer.attach_us(callback(this, &SX1276_LoRaRadio::tx_done_irq), 100 * 1e3);\n}\n\nvoid SX1276_LoRaRadio::tx_done_irq() {\n    tx_done_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->tx_done)) {\n\n        _radio_events->tx_done();\n    }\n}\n\nvoid SX1276_LoRaRadio::rx_done_irq() {\n    tr_info(\"rx_done_irq\");\n\n    rx_timeout_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->rx_done)) {\n\n        _radio_events->rx_done(_data_buffer,\n                _rf_settings.lora_packet_handler.size,\n                _rf_settings.lora_packet_handler.rssi_value,\n                _rf_settings.lora_packet_handler.snr_value);\n    }\n}\n\n/**\n * Get RSSI from the module\n */\nint16_t SX1276_LoRaRadio::get_rssi(radio_modems_t modem)\n{\n    tr_info(\"get_rssi\");\n\n    return -1;\n}\n\n/**\n * Sets the module in low power mode by disconnecting\n * TX and RX submodules, turning off power amplifier etc.\n */\nvoid SX1276_LoRaRadio::set_low_power_mode()\n{\n\n    tr_info(\"set_low_power_mode\");\n\n    if (_rf_ctrls.rf_switch_ctl1 != NC) {\n        _rf_switch_ctl1 = 0;\n    }\n\n    if (_rf_ctrls.rf_switch_ctl2 != NC) {\n        _rf_switch_ctl2 = 0;\n    }\n\n    if (_rf_ctrls.pwr_amp_ctl != NC) {\n        _pwr_amp_ctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _txctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _rxctl = 0;\n    }\n\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch = 0;\n    }\n}\n\n/**\n * Attaches ISRs to interrupt pins\n */\nvoid SX1276_LoRaRadio::setup_interrupts()\n{\n    tr_info(\"setup_interrupts\");\n\n    _dio0_ctl.rise(callback(this, &SX1276_LoRaRadio::dio0_irq_isr));\n    _dio1_ctl.rise(callback(this, &SX1276_LoRaRadio::dio1_irq_isr));\n    _dio2_ctl.rise(callback(this, &SX1276_LoRaRadio::dio2_irq_isr));\n    _dio3_ctl.rise(callback(this, &SX1276_LoRaRadio::dio3_irq_isr));\n    if (_dio4_pin != NC) {\n        _dio4_ctl.rise(callback(this, &SX1276_LoRaRadio::dio4_irq_isr));\n    }\n    if (_dio5_pin != NC) {\n        _dio5_ctl.rise(callback(this, &SX1276_LoRaRadio::dio5_irq_isr));\n    }\n}\n\n/**\n * Sets up radio latch position according to the\n * radio mode\n */\nvoid SX1276_LoRaRadio::set_antenna_switch(uint8_t mode)\n{\n    tr_info(\"set_antenna_switch (mode=%u)\", mode);\n\n    // // here we got to do ifdef for changing controls\n    // // as some pins might be NC\n    // switch (mode) {\n    //     case RFLR_OPMODE_TRANSMITTER:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // module is in transmit mode and RF latch switches\n    //             // are connected. Check if power amplifier boost is\n    //             // setup or not\n    //             if ((read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST)\n    //                                    == RF_PACONFIG_PASELECT_PABOOST) {\n    //                 _rf_switch_ctl1 = 1;\n    //                 _rf_switch_ctl2 = 0;\n    //             } else {\n    //                 // power amplifier not selected\n    //                 _rf_switch_ctl1 = 0;\n    //                 _rf_switch_ctl2 = 1;\n    //             }\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             // module is in transmit mode and tx/rx submodule control\n    //             // pins are connected\n    //             if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //                 if (read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST) {\n    //                     _pwr_amp_ctl = 1;\n    //                     _txctl = 0;\n    //                 } else {\n    //                     _pwr_amp_ctl = 0;\n    //                     _txctl = 1;\n    //                 }\n    //             } else {\n    //                 _txctl = 1;\n    //             }\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC){\n    //             _ant_switch = 1;\n    //         }\n    //         break;\n    //     case RFLR_OPMODE_RECEIVER:\n    //     case RFLR_OPMODE_RECEIVER_SINGLE:\n    //     case RFLR_OPMODE_CAD:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 1;\n    //             _rf_switch_ctl2 = 1;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 1;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    //     default:\n    //         // Enforce default case  when any connected control pin is kept low.\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 0;\n    //             _rf_switch_ctl2 = 0;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    // }\n}\n\n/*****************************************************************************\n * Interrupt service routines (ISRs) - set signals to the irq_thread         *\n ****************************************************************************/\nvoid SX1276_LoRaRadio::dio0_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n   irq_thread.signal_set(SIG_DIO0);\n#else\n   handle_dio0_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio1_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO1);\n#else\n    handle_dio1_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio2_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO2);\n#else\n    handle_dio2_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio3_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO3);\n#else\n    handle_dio3_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio4_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO4);\n#else\n    handle_dio4_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio5_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO5);\n#else\n    handle_dio5_irq();\n#endif\n}\n\n// This is not a hardware interrupt\n// we invoke it ourselves based upon\n// our timers\nvoid SX1276_LoRaRadio::timeout_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_TIMOUT);\n#else\n    handle_timeout_irq();\n#endif\n}\n\n/******************************************************************************\n * Interrupt Handlers                                                         *\n *****************************************************************************/\n\nvoid SX1276_LoRaRadio::handle_dio0_irq()\n{\n    // volatile uint8_t irqFlags = 0;\n\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 if (_rf_settings.fsk.crc_on == true) {\n    //                     irqFlags = read_register(REG_IRQFLAGS2);\n    //                     if ((irqFlags & RF_IRQFLAGS2_CRCOK)\n    //                             != RF_IRQFLAGS2_CRCOK) {\n    //                         // Clear Irqs\n    //                         write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n    //                                           RF_IRQFLAGS1_PREAMBLEDETECT |\n    //                                           RF_IRQFLAGS1_SYNCADDRESSMATCH);\n    //                         write_to_register(REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n\n    //                         if (_rf_settings.fsk.rx_continuous == false) {\n    //                             rx_timeout_sync_word.detach();\n    //                             _rf_settings.state = RF_IDLE;\n    //                         } else {\n    //                             // Continuous mode restart Rx chain\n    //                             write_to_register(REG_RXCONFIG,\n    //                                               read_register(REG_RXCONFIG) |\n    //                                               RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                         }\n\n    //                         rx_timeout_timer.detach();\n\n    //                         if ((_radio_events != NULL)\n    //                                 && (_radio_events->rx_error)) {\n    //                             _radio_events->rx_error();\n    //                         }\n    //                         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                         _rf_settings.fsk_packet_handler.size = 0;\n    //                         // break from here, a CRC error happened, RX_ERROR\n    //                         // was notified. No need to go any further\n    //                         break;\n    //                     }\n    //                 }\n\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size = read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 } else {\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 if (_rf_settings.fsk.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                     rx_timeout_sync_word.detach();\n    //                 } else {\n    //                     // Continuous mode restart Rx chain\n    //                     write_to_register(REG_RXCONFIG, read_register(REG_RXCONFIG)\n    //                                     | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                 }\n\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(\n    //                             _data_buffer,\n    //                             _rf_settings.fsk_packet_handler.size,\n    //                             _rf_settings.fsk_packet_handler.rssi_value, 0);\n    //                 }\n    //                 _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                 _rf_settings.fsk_packet_handler.size = 0;\n    //                 break;\n\n    //             case MODEM_LORA: {\n    //                 int8_t snr = 0;\n\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE);\n\n    //                 irqFlags = read_register(REG_LR_IRQFLAGS);\n    //                 if ((irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK)\n    //                         == RFLR_IRQFLAGS_PAYLOADCRCERROR) {\n    //                     // Clear Irq\n    //                     write_to_register( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR);\n\n    //                     if (_rf_settings.lora.rx_continuous == false) {\n    //                         _rf_settings.state = RF_IDLE;\n    //                     }\n    //                     rx_timeout_timer.detach();\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->rx_error)) {\n    //                         _radio_events->rx_error();\n    //                     }\n    //                     break;\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.snr_value = read_register(\n    //                         REG_LR_PKTSNRVALUE);\n    //                 if (_rf_settings.lora_packet_handler.snr_value & 0x80) // The SNR sign bit is 1\n    //                         {\n    //                     // Invert and divide by 4\n    //                     snr = ((~_rf_settings.lora_packet_handler.snr_value + 1)\n    //                             & 0xFF) >> 2;\n    //                     snr = -snr;\n    //                 } else {\n    //                     // Divide by 4\n    //                     snr =\n    //                             (_rf_settings.lora_packet_handler.snr_value\n    //                                     & 0xFF) >> 2;\n    //                 }\n\n    //                 int16_t rssi = read_register( REG_LR_PKTRSSIVALUE);\n    //                 if (snr < 0) {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4) + snr;\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4) + snr;\n    //                     }\n    //                 } else {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4);\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4);\n    //                     }\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.size = read_register(REG_LR_RXNBBYTES);\n    //                 read_fifo(_data_buffer, _rf_settings.lora_packet_handler.size);\n\n    //                 if (_rf_settings.lora.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                 }\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(_data_buffer,\n    //                             _rf_settings.lora_packet_handler.size,\n    //                             _rf_settings.lora_packet_handler.rssi_value,\n    //                             _rf_settings.lora_packet_handler.snr_value);\n    //                 }\n    //             }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     case RF_TX_RUNNING:\n    //         tx_timeout_timer.detach();\n    //         // TxDone interrupt\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_LORA:\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE);\n    //                 // Intentional fall through\n    //             case MODEM_FSK:\n    //             default:\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->tx_done)) {\n    //                     _radio_events->tx_done();\n    //                 }\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio1_irq()\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size =\n    //                                 read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                 }\n\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.fifo_thresh) {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh;\n    //                 } else {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 // Sync time out\n    //                 rx_timeout_timer.detach();\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXTIMEOUT);\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->rx_timeout)) {\n    //                     _radio_events->rx_timeout();\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.chunk_size) {\n    //                     write_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.chunk_size);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.chunk_size;\n    //                 } else {\n    //                     // Write the last chunk of data\n    //                     write_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio2_irq(void)\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // DIO4 must have been asserted to set preamble_detected to true\n    //                 if ((_rf_settings.fsk_packet_handler.preamble_detected == 1)\n    //                         && (_rf_settings.fsk_packet_handler.sync_word_detected == 0)) {\n    //                     if (_rf_settings.fsk.rx_continuous == false) {\n    //                         rx_timeout_sync_word.detach();\n    //                     }\n\n    //                     _rf_settings.fsk_packet_handler.sync_word_detected = 1;\n\n    //                     _rf_settings.fsk_packet_handler.rssi_value =\n    //                             -(read_register(REG_RSSIVALUE) >> 1);\n\n    //                     _rf_settings.fsk_packet_handler.afc_value =\n    //                             (int32_t) (double) (((uint16_t) read_register(\n    //                                     REG_AFCMSB) << 8)\n    //                                     | (uint16_t) read_register( REG_AFCLSB))\n    //                                     * (double) FREQ_STEP;\n    //                     _rf_settings.fsk_packet_handler.rx_gain =\n    //                             (read_register( REG_LNA) >> 5) & 0x07;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n\n    //                 break;\n\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 break;\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio3_irq(void)\n{\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         break;\n    //     case MODEM_LORA:\n    //         if ((read_register(REG_LR_IRQFLAGS) & RFLR_IRQFLAGS_CADDETECTED)\n    //                 == RFLR_IRQFLAGS_CADDETECTED) {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS,\n    //                     RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(true);\n    //             }\n    //         } else {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(false);\n    //             }\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio4_irq(void)\n{\n    // is asserted when a preamble is detected (FSK modem only)\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK: {\n    //         if (_rf_settings.fsk_packet_handler.preamble_detected == 0) {\n    //             _rf_settings.fsk_packet_handler.preamble_detected = 1;\n    //         }\n    //     }\n    //         break;\n    //     case MODEM_LORA:\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio5_irq()\n{\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            break;\n        case MODEM_LORA:\n            break;\n        default:\n            break;\n    }\n}\n\n\nvoid SX1276_LoRaRadio::handle_timeout_irq()\n{\n    tr_info(\"handle_timeout_irq\");\n\n    switch (_rf_settings.state) {\n        case RF_RX_RUNNING:\n            if (_rf_settings.modem == MODEM_FSK) {\n                _rf_settings.fsk_packet_handler.preamble_detected = 0;\n                _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n                _rf_settings.fsk_packet_handler.nb_bytes = 0;\n                _rf_settings.fsk_packet_handler.size = 0;\n\n                // Clear Irqs\n                // write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n                // RF_IRQFLAGS1_PREAMBLEDETECT |\n                // RF_IRQFLAGS1_SYNCADDRESSMATCH);\n                // write_to_register( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n                if (_rf_settings.fsk.rx_continuous == true) {\n                    // Continuous mode restart Rx chain\n                    // write_to_register( REG_RXCONFIG,\n                    //                   read_register(REG_RXCONFIG) |\n                    //                   RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n                } else {\n                    _rf_settings.state = RF_IDLE;\n                    rx_timeout_sync_word.attach_us(\n                            callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                            _rf_settings.fsk.rx_single_timeout * 1e3);\n                }\n            }\n\n            if ((_radio_events != NULL)\n                    && (_radio_events->rx_timeout)) {\n                _radio_events->rx_timeout();\n            }\n\n            break;\n\n        case RF_TX_RUNNING:\n            // Tx timeout shouldn't happen.\n            // But it has been observed that when it happens it is a result of a\n            // corrupted SPI transfer\n            // The workaround is to put the radio in a known state.\n            // Thus, we re-initialize it.\n\n            // // Reset the radio\n            // radio_reset();\n\n            // // Initialize radio default values\n            // set_operation_mode(RF_OPMODE_SLEEP);\n\n            // // setup_registers();\n\n            // set_modem(MODEM_FSK);\n\n            // // Restore previous network type setting.\n            // set_public_network(_rf_settings.lora.public_network);\n\n            _rf_settings.state = RF_IDLE;\n            if ((_radio_events != NULL)\n                    && (_radio_events->tx_timeout)) {\n                _radio_events->tx_timeout();\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void handle_lora_downlink(uint32_t radioPtr, uint32_t dataPtr, uint32_t size) {\n    ((SX1276_LoRaRadio*)radioPtr)->rx_frame((uint8_t*)dataPtr, size);\n}\n\n// EOF\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALOUT_H\n#define MBED_DIGITALOUT_H\n\n#include \"platform/platform.h\"\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital output, used for setting the state of a pin\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle a LED\n * #include \"mbed.h\"\n *\n * DigitalOut led(LED1);\n *\n * int main() {\n *     while(1) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass DigitalOut {\n\npublic:\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     */\n    DigitalOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out(&gpio, pin);\n    }\n\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     *  @param value the initial pin value\n     */\n    DigitalOut(PinName pin, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out_ex(&gpio, pin, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin,\n     *    0 for logical 0, 1 for logical 1\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (DigitalOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_TIMEOUT_H\n#define MBED_TIMEOUT_H\n\n#include \"drivers/Ticker.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/mbed_power_mgmt.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A Timeout is used to call a function at a point in the future\n *\n * You can use as many seperate Timeout objects as you require.\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Blink until timeout.\n *\n * #include \"mbed.h\"\n *\n * Timeout timeout;\n * DigitalOut led(LED1);\n *\n * int on = 1;\n *\n * void attimeout() {\n *     on = 0;\n * }\n *\n * int main() {\n *     timeout.attach(&attimeout, 5);\n *     while(on) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass Timeout : public Ticker, private NonCopyable<Timeout> {\n\nprotected:\n    virtual void handler();\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/InterruptIn.h\"\n\n#if DEVICE_INTERRUPTIN\n\nnamespace mbed {\n\n// Note: This single-parameter constructor exists to maintain binary\n//       compatibility.\n//       If not for that, we could simplify by having only the 2-param\n//       constructor, with a default value for the PinMode.\nInterruptIn::InterruptIn(PinName pin) : gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in(&gpio, pin);\n}\n\nInterruptIn::InterruptIn(PinName pin, PinMode mode) :\n                                        gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in_ex(&gpio, pin, mode);\n}\n\nvoid InterruptIn::irq_init(PinName pin) {\n   gpio_irq_init(&gpio_irq, pin, (&InterruptIn::_irq_handler), (uint32_t)this);\n}\n\nInterruptIn::~InterruptIn() {\n    // No lock needed in the destructor\n    gpio_irq_free(&gpio_irq);\n}\n\nint InterruptIn::read() {\n    // Read only\n    return gpio_read(&gpio);\n}\n\nvoid InterruptIn::mode(PinMode pull) {\n    core_util_critical_section_enter();\n    gpio_mode(&gpio, pull);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::rise(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _rise = func;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 1);\n    } else {\n        _rise = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::fall(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _fall = func;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 1);\n    } else {\n        _fall = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::_irq_handler(uint32_t id, gpio_irq_event event) {\n    InterruptIn *handler = (InterruptIn*)id;\n    switch (event) {\n        case IRQ_RISE: \n            if (handler->_rise) {\n                handler->_rise();\n            }\n            break;\n        case IRQ_FALL: \n            if (handler->_fall) {\n                handler->_fall(); \n            }\n            break;\n        case IRQ_NONE: break;\n    }\n}\n\nvoid InterruptIn::enable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_enable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::disable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_disable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nInterruptIn::operator int() {\n    // Underlying call is atomic\n    return read();\n}\n\n} // namespace mbed\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"lorastack/mac/LoRaMac.h\"\n#include \"lorastack/mac/LoRaMacMib.h\"\n\nLoRaMacMib::LoRaMacMib()\n: _lora_phy(NULL)\n{\n}\n\nLoRaMacMib::~LoRaMacMib()\n{\n}\n\nvoid LoRaMacMib::activate_mib_subsystem(LoRaPHY *phy)\n{\n    _lora_phy = phy;\n}\n\nlorawan_status_t LoRaMacMib::set_request(loramac_mib_req_confirm_t *mibSet,\n                                        loramac_protocol_params *params)\n{\n    if (mibSet == NULL || _lora_phy == NULL) {\n         return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    switch (mibSet->type) {\n        case MIB_DEVICE_CLASS: {\n            params->dev_class = mibSet->param.dev_class;\n            switch (params->dev_class) {\n                case CLASS_A: {\n                    // Set the radio into sleep to setup a defined state\n                    _lora_phy->put_radio_to_sleep();\n                    break;\n                }\n                case CLASS_B: {\n                    break;\n                }\n                case CLASS_C: {\n                    // Set the is_node_ack_requested indicator to default\n                    params->is_node_ack_requested = false;\n                    // Set the radio into sleep mode in case we are still in RX mode\n                    _lora_phy->put_radio_to_sleep();\n                    // Compute Rx2 windows parameters in case the RX2 datarate has changed\n                    _lora_phy->compute_rx_win_params(\n                            params->sys_params.rx2_channel.datarate,\n                            params->sys_params.min_rx_symb,\n                            params->sys_params.max_sys_rx_error,\n                            &params->rx_window2_config);\n                    break;\n                }\n            }\n            break;\n        }\n        case MIB_NETWORK_JOINED: {\n            params->is_nwk_joined = mibSet->param.is_nwk_joined;\n            break;\n        }\n        case MIB_ADR: {\n            params->sys_params.adr_on = mibSet->param.is_adr_enable;\n            break;\n        }\n        case MIB_NET_ID: {\n            params->net_id = mibSet->param.net_id;\n            break;\n        }\n        case MIB_DEV_ADDR: {\n            params->dev_addr = mibSet->param.dev_addr;\n            break;\n        }\n        case MIB_NWK_SKEY: {\n            if (mibSet->param.nwk_skey != NULL) {\n                memcpy(params->keys.nwk_skey, mibSet->param.nwk_skey,\n                       sizeof(params->keys.nwk_skey));\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_APP_SKEY: {\n            if (mibSet->param.app_skey != NULL) {\n                memcpy(params->keys.app_skey, mibSet->param.app_skey,\n                       sizeof(params->keys.app_skey));\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_PUBLIC_NETWORK: {\n            params->is_nwk_public = mibSet->param.enable_public_nwk;\n            _lora_phy->setup_public_network_mode(params->is_nwk_public);\n            break;\n        }\n        case MIB_REPEATER_SUPPORT: {\n            params->is_repeater_supported = mibSet->param.enable_repeater_support;\n            break;\n        }\n        case MIB_RX2_CHANNEL: {\n            if (_lora_phy->verify_rx_datarate(mibSet->param.rx2_channel.datarate) == true) {\n                params->sys_params.rx2_channel = mibSet->param.rx2_channel;\n\n                if ((params->dev_class == CLASS_C)\n                        && (params->is_nwk_joined == true)) {\n                    // We can only compute the RX window parameters directly, if we are already\n                    // in class c mode and joined. We cannot setup an RX window in case of any other\n                    // class type.\n                    // Set the radio into sleep mode in case we are still in RX mode\n                    _lora_phy->put_radio_to_sleep();\n                    // Compute Rx2 windows parameters\n                    _lora_phy->compute_rx_win_params(\n                            params->sys_params.rx2_channel.datarate,\n                            params->sys_params.min_rx_symb,\n                            params->sys_params.max_sys_rx_error,\n                            &params->rx_window2_config);\n                }\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_RX2_DEFAULT_CHANNEL: {\n            if (_lora_phy->verify_rx_datarate(mibSet->param.rx2_channel.datarate) == true) {\n                params->sys_params.rx2_channel = mibSet->param.default_rx2_channel;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_CHANNELS_DEFAULT_MASK:\n        case MIB_CHANNELS_MASK: {\n            // channel masks must not be tempered with.\n            // They should be manipulated only on request with certain\n            // APIs like add_channel() and remove_channel()\n            // You should be able to get these MIB parameters, not set\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n            break;\n        }\n        case MIB_CHANNELS_NB_REP: {\n            if ((mibSet->param.channel_nb_rep >= 1)\n                    && (mibSet->param.channel_nb_rep <= 15)) {\n                params->sys_params.retry_num = mibSet->param.channel_nb_rep;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_MAX_RX_WINDOW_DURATION: {\n            params->sys_params.max_rx_win_time = mibSet->param.max_rx_window;\n            break;\n        }\n        case MIB_RECEIVE_DELAY_1: {\n            params->sys_params.recv_delay1 = mibSet->param.recv_delay1;\n            break;\n        }\n        case MIB_RECEIVE_DELAY_2: {\n            params->sys_params.recv_delay2 = mibSet->param.recv_delay2;\n            break;\n        }\n        case MIB_JOIN_ACCEPT_DELAY_1: {\n            params->sys_params.join_accept_delay1 = mibSet->param.join_accept_delay1;\n            break;\n        }\n        case MIB_JOIN_ACCEPT_DELAY_2: {\n            params->sys_params.join_accept_delay2 = mibSet->param.join_accept_delay2;\n            break;\n        }\n        case MIB_CHANNELS_DEFAULT_DATARATE: {\n            if (_lora_phy->verify_tx_datarate(mibSet->param.default_channel_data_rate, true)) {\n                params->sys_params.channel_data_rate = mibSet->param.default_channel_data_rate;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_CHANNELS_DATARATE: {\n            if (_lora_phy->verify_tx_datarate(mibSet->param.channel_data_rate, false) == true) {\n                params->sys_params.channel_data_rate = mibSet->param.channel_data_rate;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_CHANNELS_DEFAULT_TX_POWER: {\n            if (_lora_phy->verify_tx_power(mibSet->param.default_channel_tx_pwr)) {\n                params->sys_params.channel_tx_power = mibSet->param.default_channel_tx_pwr;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_CHANNELS_TX_POWER: {\n            if (_lora_phy->verify_tx_power(mibSet->param.channel_tx_pwr)) {\n                params->sys_params.channel_tx_power = mibSet->param.channel_tx_pwr;\n            } else {\n                status = LORAWAN_STATUS_PARAMETER_INVALID;\n            }\n            break;\n        }\n        case MIB_UPLINK_COUNTER: {\n            params->ul_frame_counter = mibSet->param.ul_frame_counter;\n            break;\n        }\n        case MIB_DOWNLINK_COUNTER: {\n            params->dl_frame_counter = mibSet->param.dl_frame_counter;\n            break;\n        }\n        case MIB_SYSTEM_MAX_RX_ERROR: {\n            params->sys_params.max_sys_rx_error = mibSet->param.max_rx_sys_error;\n            break;\n        }\n        case MIB_MIN_RX_SYMBOLS: {\n            params->sys_params.min_rx_symb = mibSet->param.min_rx_symb;\n            break;\n        }\n        case MIB_ANTENNA_GAIN: {\n            params->sys_params.antenna_gain = mibSet->param.antenna_gain;\n            break;\n        }\n        default:\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n            break;\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMacMib::get_request(loramac_mib_req_confirm_t *mibGet,\n                                        loramac_protocol_params *params)\n{\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n    rx2_channel_params rx2_channel;\n\n    if( mibGet == NULL )\n    {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    switch( mibGet->type )\n    {\n        case MIB_DEVICE_CLASS:\n        {\n            mibGet->param.dev_class = params->dev_class;\n            break;\n        }\n        case MIB_NETWORK_JOINED:\n        {\n            mibGet->param.is_nwk_joined = params->is_nwk_joined;\n            break;\n        }\n        case MIB_ADR:\n        {\n            mibGet->param.is_adr_enable = params->sys_params.adr_on;\n            break;\n        }\n        case MIB_NET_ID:\n        {\n            mibGet->param.net_id = params->net_id;\n            break;\n        }\n        case MIB_DEV_ADDR:\n        {\n            mibGet->param.dev_addr = params->dev_addr;\n            break;\n        }\n        case MIB_NWK_SKEY:\n        {\n            mibGet->param.nwk_skey =params->keys.nwk_skey;\n            break;\n        }\n        case MIB_APP_SKEY:\n        {\n            mibGet->param.app_skey = params->keys.app_skey;\n            break;\n        }\n        case MIB_PUBLIC_NETWORK:\n        {\n            mibGet->param.enable_public_nwk = params->is_nwk_public;\n            break;\n        }\n        case MIB_REPEATER_SUPPORT:\n        {\n            mibGet->param.enable_repeater_support = params->is_repeater_supported;\n            break;\n        }\n        case MIB_CHANNELS:\n        {\n            mibGet->param.channel_list = _lora_phy->get_phy_channels();\n            break;\n        }\n        case MIB_RX2_CHANNEL:\n        {\n            mibGet->param.rx2_channel = params->sys_params.rx2_channel;\n            break;\n        }\n        case MIB_RX2_DEFAULT_CHANNEL:\n        {\n            rx2_channel.datarate = _lora_phy->get_default_rx2_datarate();\n            rx2_channel.frequency = _lora_phy->get_default_rx2_frequency();\n            mibGet->param.rx2_channel = rx2_channel;\n            break;\n        }\n        case MIB_CHANNELS_DEFAULT_MASK:\n        {\n            mibGet->param.default_channel_mask = _lora_phy->get_channel_mask(true);\n            break;\n        }\n        case MIB_CHANNELS_MASK:\n        {\n            mibGet->param.channel_mask = _lora_phy->get_channel_mask(false);\n            break;\n        }\n        case MIB_CHANNELS_NB_REP:\n        {\n            mibGet->param.channel_nb_rep = params->sys_params.retry_num;\n            break;\n        }\n        case MIB_MAX_RX_WINDOW_DURATION:\n        {\n            mibGet->param.max_rx_window = params->sys_params.max_rx_win_time;\n            break;\n        }\n        case MIB_RECEIVE_DELAY_1:\n        {\n            mibGet->param.recv_delay1 = params->sys_params.recv_delay1;\n            break;\n        }\n        case MIB_RECEIVE_DELAY_2:\n        {\n            mibGet->param.recv_delay2 = params->sys_params.recv_delay2;\n            break;\n        }\n        case MIB_JOIN_ACCEPT_DELAY_1:\n        {\n            mibGet->param.join_accept_delay1 = params->sys_params.join_accept_delay1;\n            break;\n        }\n        case MIB_JOIN_ACCEPT_DELAY_2:\n        {\n            mibGet->param.join_accept_delay2 = params->sys_params.join_accept_delay2;\n            break;\n        }\n        case MIB_CHANNELS_DEFAULT_DATARATE:\n        {\n            mibGet->param.default_channel_data_rate = _lora_phy->get_default_tx_datarate();\n            break;\n        }\n        case MIB_CHANNELS_DATARATE:\n        {\n            mibGet->param.channel_data_rate = params->sys_params.channel_data_rate;\n            break;\n        }\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\n        {\n            mibGet->param.default_channel_tx_pwr = _lora_phy->get_default_tx_power();\n            break;\n        }\n        case MIB_CHANNELS_TX_POWER:\n        {\n            mibGet->param.channel_tx_pwr = params->sys_params.channel_tx_power;\n            break;\n        }\n        case MIB_UPLINK_COUNTER:\n        {\n            mibGet->param.ul_frame_counter = params->ul_frame_counter;\n            break;\n        }\n        case MIB_DOWNLINK_COUNTER:\n        {\n            mibGet->param.dl_frame_counter = params->dl_frame_counter;\n            break;\n        }\n        case MIB_MULTICAST_CHANNEL:\n        {\n            mibGet->param.multicast_list = params->multicast_channels;\n            break;\n        }\n        case MIB_SYSTEM_MAX_RX_ERROR:\n        {\n            mibGet->param.max_rx_sys_error = params->sys_params.max_sys_rx_error;\n            break;\n        }\n        case MIB_MIN_RX_SYMBOLS:\n        {\n            mibGet->param.min_rx_symb = params->sys_params.min_rx_symb;\n            break;\n        }\n        case MIB_ANTENNA_GAIN:\n        {\n            mibGet->param.antenna_gain = params->sys_params.antenna_gain;\n            break;\n        }\n        default:\n            status = LORAWAN_STATUS_SERVICE_UNKNOWN;\n            break;\n    }\n\n    return status;\n}\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"LoRaMac.h\"\n#include \"lorastack/mac/LoRaMacMlme.h\"\n\nLoRaMacMlme::LoRaMacMlme()\n: _lora_phy(NULL)\n{\n}\n\nLoRaMacMlme::~LoRaMacMlme()\n{\n}\n\nvoid LoRaMacMlme::reset_confirmation()\n{\n    memset((uint8_t*) &confirmation, 0, sizeof(confirmation));\n\n    confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n}\n\nloramac_mlme_confirm_t& LoRaMacMlme::get_confirmation()\n{\n    return confirmation;\n}\n\nloramac_mlme_indication_t& LoRaMacMlme::get_indication()\n{\n    return indication;\n}\n\nvoid LoRaMacMlme::activate_mlme_subsystem(LoRaPHY *phy)\n{\n    _lora_phy = phy;\n}\n\nvoid LoRaMacMlme::set_tx_continuous_wave(uint8_t channel, int8_t datarate, int8_t tx_power,\n                                         float max_eirp, float antenna_gain, uint16_t timeout)\n{\n    cw_mode_params_t continuous_wave;\n\n    continuous_wave.channel = channel;\n    continuous_wave.datarate = datarate;\n    continuous_wave.tx_power = tx_power;\n    continuous_wave.max_eirp = max_eirp;\n    continuous_wave.antenna_gain = antenna_gain;\n    continuous_wave.timeout = timeout;\n\n    _lora_phy->set_tx_cont_mode(&continuous_wave);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALINOUT_H\n#define MBED_DIGITALINOUT_H\n\n#include \"platform/platform.h\"\n\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital input/output, used for setting or reading a bi-directional pin\n *\n * @note Synchronization level: Interrupt safe\n * @ingroup drivers\n */\nclass DigitalInOut {\n\npublic:\n    /** Create a DigitalInOut connected to the specified pin\n     *\n     *  @param pin DigitalInOut pin to connect to\n     */\n    DigitalInOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_in(&gpio, pin);\n    }\n\n    /** Create a DigitalInOut connected to the specified pin\n     *\n     *  @param pin DigitalInOut pin to connect to\n     *  @param direction the initial direction of the pin\n     *  @param mode the initial mode of the pin\n     *  @param value the initial value of the pin if is an output\n     */\n    DigitalInOut(PinName pin, PinDirection direction, PinMode mode, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_inout(&gpio, pin, direction, mode, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin if it is an output,\n     *    or read the input if set as an input\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Set as an output\n     */\n    void output() {\n        core_util_critical_section_enter();\n        gpio_dir(&gpio, PIN_OUTPUT);\n        core_util_critical_section_exit();\n    }\n\n    /** Set as an input\n     */\n    void input() {\n        core_util_critical_section_enter();\n        gpio_dir(&gpio, PIN_INPUT);\n        core_util_critical_section_exit();\n    }\n\n    /** Set the input pin mode\n     *\n     *  @param pull PullUp, PullDown, PullNone, OpenDrain\n     */\n    void mode(PinMode pull) {\n        core_util_critical_section_enter();\n        gpio_mode(&gpio, pull);\n        core_util_critical_section_exit();\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalInOut::write()\n     */\n    DigitalInOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalInOut::write()\n     */\n    DigitalInOut& operator= (DigitalInOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalInOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/*\n * Flexible event queue for dispatching events\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue.h\"\n#include \"mbed_wait_api.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n\n// calculate the relative-difference between absolute times while\n// correctly handling overflow conditions\nstatic inline int equeue_tickdiff(unsigned a, unsigned b) {\n    return (int)(unsigned)(a - b);\n}\n\n// calculate the relative-difference between absolute times, but\n// also clamp to zero, resulting in only non-zero values.\nstatic inline int equeue_clampdiff(unsigned a, unsigned b) {\n    int diff = equeue_tickdiff(a, b);\n    return ~(diff >> (8*sizeof(int)-1)) & diff;\n}\n\n// Increment the unique id in an event, hiding the event from cancel\nstatic inline void equeue_incid(equeue_t *q, struct equeue_event *e) {\n    e->id += 1;\n    if ((e->id << q->npw2) == 0) {\n        e->id = 1;\n    }\n}\n\n\n// equeue lifetime management\nint equeue_create(equeue_t *q, size_t size) {\n    // dynamically allocate the specified buffer\n    void *buffer = malloc(size);\n    if (!buffer) {\n        return -1;\n    }\n\n    int err = equeue_create_inplace(q, size, buffer);\n    q->allocated = buffer;\n    return err;\n}\n\nint equeue_create_inplace(equeue_t *q, size_t size, void *buffer) {\n    // setup queue around provided buffer\n    q->buffer = buffer;\n    q->allocated = 0;\n\n    q->npw2 = 0;\n    for (unsigned s = size; s; s >>= 1) {\n        q->npw2++;\n    }\n\n    q->chunks = 0;\n    q->slab.size = size;\n    q->slab.data = buffer;\n\n    q->queue = 0;\n    q->tick = equeue_tick();\n    q->generation = 0;\n    q->break_requested = false;\n\n    q->background.active = false;\n    q->background.update = 0;\n    q->background.timer = 0;\n\n    // initialize platform resources\n    int err;\n    err = equeue_sema_create(&q->eventsema);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->queuelock);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->memlock);\n    if (err < 0) {\n        return err;\n    }\n\n    return 0;\n}\n\nvoid equeue_destroy(equeue_t *q) {\n    // call destructors on pending events\n    for (struct equeue_event *es = q->queue; es; es = es->next) {\n        for (struct equeue_event *e = q->queue; e; e = e->sibling) {\n            if (e->dtor) {\n                e->dtor(e + 1);\n            }\n        }\n    }\n\n    // notify background timer\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    // clean up platform resources + memory\n    equeue_mutex_destroy(&q->memlock);\n    equeue_mutex_destroy(&q->queuelock);\n    equeue_sema_destroy(&q->eventsema);\n    free(q->allocated);\n}\n\n\n// equeue chunk allocation functions\nstatic struct equeue_event *equeue_mem_alloc(equeue_t *q, size_t size) {\n#ifdef TARGET_SIMULATOR\n        // ok... so for some reason this is necessary\n        // no idea why, maybe something with blocks not actually allocated until we yield back\n        // wait_ms(10);\n#endif\n    // add event overhead\n    size += sizeof(struct equeue_event);\n    size = (size + sizeof(void*)-1) & ~(sizeof(void*)-1);\n\n    equeue_mutex_lock(&q->memlock);\n\n    // check if a good chunk is available\n    for (struct equeue_event **p = &q->chunks; *p; p = &(*p)->next) {\n        if ((*p)->size >= size) {\n            struct equeue_event *e = *p;\n            if (e->sibling) {\n                *p = e->sibling;\n                (*p)->next = e->next;\n            } else {\n                *p = e->next;\n            }\n\n            equeue_mutex_unlock(&q->memlock);\n            return e;\n        }\n    }\n\n    // otherwise allocate a new chunk out of the slab\n    if (q->slab.size >= size) {\n        struct equeue_event *e = (struct equeue_event *)q->slab.data;\n        q->slab.data += size;\n        q->slab.size -= size;\n        e->size = size;\n        e->id = 1;\n\n        equeue_mutex_unlock(&q->memlock);\n        return e;\n    }\n\n    equeue_mutex_unlock(&q->memlock);\n    return 0;\n}\n\nstatic void equeue_mem_dealloc(equeue_t *q, struct equeue_event *e) {\n    equeue_mutex_lock(&q->memlock);\n\n    // stick chunk into list of chunks\n    struct equeue_event **p = &q->chunks;\n    while (*p && (*p)->size < e->size) {\n        p = &(*p)->next;\n    }\n\n    if (*p && (*p)->size == e->size) {\n        e->sibling = *p;\n        e->next = (*p)->next;\n    } else {\n        e->sibling = 0;\n        e->next = *p;\n    }\n    *p = e;\n\n    equeue_mutex_unlock(&q->memlock);\n}\n\nvoid *equeue_alloc(equeue_t *q, size_t size) {\n    struct equeue_event *e = equeue_mem_alloc(q, size);\n    if (!e) {\n        return 0;\n    }\n\n    e->target = 0;\n    e->period = -1;\n    e->dtor = 0;\n\n    return e + 1;\n}\n\nvoid equeue_dealloc(equeue_t *q, void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n\n    if (e->dtor) {\n        e->dtor(e+1);\n    }\n\n    equeue_mem_dealloc(q, e);\n}\n\n\n// equeue scheduling functions\nstatic int equeue_enqueue(equeue_t *q, struct equeue_event *e, unsigned tick) {\n    // setup event and hash local id with buffer offset for unique id\n    int id = (e->id << q->npw2) | ((unsigned char *)e - q->buffer);\n    e->target = tick + equeue_clampdiff(e->target, tick);\n    e->generation = q->generation;\n\n    equeue_mutex_lock(&q->queuelock);\n\n    // find the event slot\n    struct equeue_event **p = &q->queue;\n    while (*p && equeue_tickdiff((*p)->target, e->target) < 0) {\n        p = &(*p)->next;\n    }\n\n    // insert at head in slot\n    if (*p && (*p)->target == e->target) {\n        e->next = (*p)->next;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = *p;\n        e->sibling->ref = &e->sibling;\n    } else {\n        e->next = *p;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = 0;\n    }\n\n    *p = e;\n    e->ref = p;\n\n    // notify background timer\n    if ((q->background.update && q->background.active) &&\n        (q->queue == e && !e->sibling)) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(e->target, tick));\n    }\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    return id;\n}\n\nstatic struct equeue_event *equeue_unqueue(equeue_t *q, int id) {\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id != id >> q->npw2) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // clear the event and check if already in-flight\n    e->cb = 0;\n    e->period = -1;\n\n    int diff = equeue_tickdiff(e->target, q->tick);\n    if (diff < 0 || (diff == 0 && e->generation != q->generation)) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // disentangle from queue\n    if (e->sibling) {\n        e->sibling->next = e->next;\n        if (e->sibling->next) {\n            e->sibling->next->ref = &e->sibling->next;\n        }\n\n        *e->ref = e->sibling;\n        e->sibling->ref = e->ref;\n    } else {\n        *e->ref = e->next;\n        if (e->next) {\n            e->next->ref = e->ref;\n        }\n    }\n\n    equeue_incid(q, e);\n    equeue_mutex_unlock(&q->queuelock);\n\n    return e;\n}\n\nstatic struct equeue_event *equeue_dequeue(equeue_t *q, unsigned target) {\n    equeue_mutex_lock(&q->queuelock);\n\n    // find all expired events and mark a new generation\n    q->generation += 1;\n    if (equeue_tickdiff(q->tick, target) <= 0) {\n        q->tick = target;\n    }\n\n    struct equeue_event *head = q->queue;\n    struct equeue_event **p = &head;\n    while (*p && equeue_tickdiff((*p)->target, target) <= 0) {\n        p = &(*p)->next;\n    }\n\n    q->queue = *p;\n    if (q->queue) {\n        q->queue->ref = &q->queue;\n    }\n\n    *p = 0;\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    // reverse and flatten each slot to match insertion order\n    struct equeue_event **tail = &head;\n    struct equeue_event *ess = head;\n    while (ess) {\n        struct equeue_event *es = ess;\n        ess = es->next;\n\n        struct equeue_event *prev = 0;\n        for (struct equeue_event *e = es; e; e = e->sibling) {\n            e->next = prev;\n            prev = e;\n        }\n\n        *tail = prev;\n        tail = &es->next;\n    }\n\n    return head;\n}\n\nint equeue_post(equeue_t *q, void (*cb)(void*), void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    unsigned tick = equeue_tick();\n    e->cb = cb;\n    e->target = tick + e->target;\n\n    int id = equeue_enqueue(q, e, tick);\n    equeue_sema_signal(&q->eventsema);\n    return id;\n}\n\nvoid equeue_cancel(equeue_t *q, int id) {\n    if (!id) {\n        return;\n    }\n\n    struct equeue_event *e = equeue_unqueue(q, id);\n    if (e) {\n        equeue_dealloc(q, e + 1);\n    }\n}\n\nvoid equeue_break(equeue_t *q) {\n    equeue_mutex_lock(&q->queuelock);\n    q->break_requested = true;\n    equeue_mutex_unlock(&q->queuelock);\n    equeue_sema_signal(&q->eventsema);\n}\n\nvoid equeue_dispatch(equeue_t *q, int ms) {\n    unsigned tick = equeue_tick();\n    unsigned timeout = tick + ms;\n    q->background.active = false;\n\n    while (1) {\n        // collect all the available events and next deadline\n        struct equeue_event *es = equeue_dequeue(q, tick);\n\n        // dispatch events\n        while (es) {\n            struct equeue_event *e = es;\n            es = e->next;\n\n            // actually dispatch the callbacks\n            void (*cb)(void *) = e->cb;\n            if (cb) {\n                cb(e + 1);\n            }\n\n            // reenqueue periodic events or deallocate\n            if (e->period >= 0) {\n                e->target += e->period;\n                equeue_enqueue(q, e, equeue_tick());\n            } else {\n                equeue_incid(q, e);\n                equeue_dealloc(q, e+1);\n            }\n        }\n\n        int deadline = -1;\n        tick = equeue_tick();\n\n        // check if we should stop dispatching soon\n        if (ms >= 0) {\n            deadline = equeue_tickdiff(timeout, tick);\n            if (deadline <= 0) {\n                // update background timer if necessary\n                if (q->background.update) {\n                    equeue_mutex_lock(&q->queuelock);\n                    if (q->background.update && q->queue) {\n                        q->background.update(q->background.timer,\n                                equeue_clampdiff(q->queue->target, tick));\n                    }\n                    q->background.active = true;\n                    equeue_mutex_unlock(&q->queuelock);\n                }\n                q->break_requested = false;\n                return;\n            }\n        }\n\n        // find closest deadline\n        equeue_mutex_lock(&q->queuelock);\n        if (q->queue) {\n            int diff = equeue_clampdiff(q->queue->target, tick);\n            if ((unsigned)diff < (unsigned)deadline) {\n                deadline = diff;\n            }\n        }\n        equeue_mutex_unlock(&q->queuelock);\n\n        // wait for events\n        equeue_sema_wait(&q->eventsema, deadline);\n\n        // check if we were notified to break out of dispatch\n        if (q->break_requested) {\n            equeue_mutex_lock(&q->queuelock);\n            if (q->break_requested) {\n                q->break_requested = false;\n                equeue_mutex_unlock(&q->queuelock);\n                return;\n            }\n            equeue_mutex_unlock(&q->queuelock);\n        }\n\n        // update tick for next iteration\n        tick = equeue_tick();\n\n#ifdef TARGET_SIMULATOR\n        // yield back to browser in between to process events\n        wait_ms(20);\n#endif\n    }\n}\n\n\n// event functions\nvoid equeue_event_delay(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->target = ms;\n}\n\nvoid equeue_event_period(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->period = ms;\n}\n\nvoid equeue_event_dtor(void *p, void (*dtor)(void *)) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->dtor = dtor;\n}\n\n\n// simple callbacks\nstruct ecallback {\n    void (*cb)(void*);\n    void *data;\n};\n\nstatic void ecallback_dispatch(void *p) {\n    struct ecallback *e = (struct ecallback*)p;\n    e->cb(e->data);\n}\n\nint equeue_call(equeue_t *q, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_in(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_every(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    equeue_event_period(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\n\n// backgrounding\nvoid equeue_background(equeue_t *q,\n        void (*update)(void *timer, int ms), void *timer) {\n    equeue_mutex_lock(&q->queuelock);\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    q->background.update = update;\n    q->background.timer = timer;\n\n    if (q->background.update && q->queue) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(q->queue->target, equeue_tick()));\n    }\n    q->background.active = true;\n    equeue_mutex_unlock(&q->queuelock);\n}\n\nstruct equeue_chain_context {\n    equeue_t *q;\n    equeue_t *target;\n    int id;\n};\n\nstatic void equeue_chain_dispatch(void *p) {\n    equeue_dispatch((equeue_t *)p, 0);\n}\n\nstatic void equeue_chain_update(void *p, int ms) {\n    struct equeue_chain_context *c = (struct equeue_chain_context *)p;\n    equeue_cancel(c->target, c->id);\n\n    if (ms >= 0) {\n        c->id = equeue_call_in(c->target, ms, equeue_chain_dispatch, c->q);\n    } else {\n        equeue_dealloc(c->target, c);\n    }\n}\n\nvoid equeue_chain(equeue_t *q, equeue_t *target) {\n    if (!target) {\n        equeue_background(q, 0, 0);\n        return;\n    }\n\n    struct equeue_chain_context *c = equeue_alloc(q,\n            sizeof(struct equeue_chain_context));\n\n    c->q = q;\n    c->target = target;\n    c->id = 0;\n\n    equeue_background(q, equeue_chain_update, c);\n}\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","#include \"mbed_critical.h\"\n\nbool core_util_are_interrupts_enabled(void) {\n    return true;\n}\n\nbool core_util_is_isr_active(void) {\n    return false;\n}\n\nvoid core_util_critical_section_enter(void) {}\n\nvoid core_util_critical_section_exit(void) {}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <time.h>\n#include \"platform/platform.h\"\n#include \"platform/FilePath.h\"\n#if DEVICE_SERIAL\n#include \"hal/serial_api.h\"\n#endif\n#include \"hal/us_ticker_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_semihost_api.h\"\n#endif\n#include \"platform/mbed_interface.h\"\n#include \"platform/SingletonPtr.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"platform/mbed_error.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_stats.h\"\n#endif\n#include \"platform/mbed_critical.h\"\n#include \"platform/mbed_poll.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"drivers/UARTSerial.h\"\n#include \"us_ticker_api.h\"\n#include \"lp_ticker_api.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifndef SSIZE_MAX\n#define SSIZE_MAX INT_MAX\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"platform/mbed_retarget.h\"\n\nstatic SingletonPtr<PlatformMutex> _mutex;\n\n#if defined(__ARMCC_VERSION)\n#   if __ARMCC_VERSION >= 6010050\n#      include <arm_compat.h>\n#   endif\n#   include <rt_sys.h>\n#   include <rt_misc.h>\n#   include <stdint.h>\n#   define PREFIX(x)    _sys##x\n#   define OPEN_MAX     _SYS_OPEN\n#   ifdef __MICROLIB\n#       pragma import(__use_full_stdio)\n#   endif\n\n#elif defined(__ICCARM__)\n#   include <yfuns.h>\n#   define PREFIX(x)        _##x\n#   define OPEN_MAX         16\n\n#   define STDIN_FILENO     0\n#   define STDOUT_FILENO    1\n#   define STDERR_FILENO    2\n\n#else\n#   include <sys/stat.h>\n#   define PREFIX(x)    x\n#   define OPEN_MAX         16\n#endif\n\n#define FILE_HANDLE_RESERVED    ((FileHandle*)0xFFFFFFFF)\n\nusing namespace mbed;\n\n#if defined(__MICROLIB) && (__ARMCC_VERSION>5030000)\n// Before version 5.03, we were using a patched version of microlib with proper names\nextern const char __stdin_name[]  = \":tt\";\nextern const char __stdout_name[] = \":tt\";\nextern const char __stderr_name[] = \":tt\";\n\n#else\nextern const char __stdin_name[]  = \"/stdin\";\nextern const char __stdout_name[] = \"/stdout\";\nextern const char __stderr_name[] = \"/stderr\";\n#endif\n\nunsigned char *mbed_heap_start = 0;\nuint32_t mbed_heap_size = 0;\n\n/* newlib has the filehandle field in the FILE struct as a short, so\n * we can't just return a Filehandle* from _open and instead have to\n * put it in a filehandles array and return the index into that array\n */\nstatic FileHandle *filehandles[OPEN_MAX] = { FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED };\nstatic char stdio_in_prev[OPEN_MAX];\nstatic char stdio_out_prev[OPEN_MAX];\nstatic SingletonPtr<PlatformMutex> filehandle_mutex;\n\nnamespace mbed {\nvoid mbed_set_unbuffered_stream(std::FILE *_file);\n\nvoid remove_filehandle(FileHandle *file) {\n    filehandle_mutex->lock();\n    /* Remove all open filehandles for this */\n    for (unsigned int fh_i = 0; fh_i < sizeof(filehandles)/sizeof(*filehandles); fh_i++) {\n        if (filehandles[fh_i] == file) {\n            filehandles[fh_i] = NULL;\n        }\n    }\n    filehandle_mutex->unlock();\n}\n}\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n\n/* Private FileHandle to implement backwards-compatible functionality of\n * direct HAL serial access for default stdin/stdout/stderr.\n * This is not a particularly well-behaved FileHandle for a stream, which\n * is why it's not public. People should be using UARTSerial.\n */\nclass DirectSerial : public FileHandle {\npublic:\n    DirectSerial(PinName tx, PinName rx, int baud);\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) {\n        return -ESPIPE;\n    }\n    virtual off_t size() {\n        return -EINVAL;\n    }\n    virtual int isatty() {\n        return true;\n    }\n    virtual int close() {\n        return 0;\n    }\n    virtual short poll(short events) const;\n};\n\nDirectSerial::DirectSerial(PinName tx, PinName rx, int baud) {\n    if (stdio_uart_inited) return;\n    serial_init(&stdio_uart, tx, rx);\n    serial_baud(&stdio_uart, baud);\n}\n\nssize_t DirectSerial::write(const void *buffer, size_t size) {\n    const unsigned char *buf = static_cast<const unsigned char *>(buffer);\n    for (size_t i = 0; i < size; i++) {\n        serial_putc(&stdio_uart, buf[i]);\n    }\n    return size;\n}\n\nssize_t DirectSerial::read(void *buffer, size_t size) {\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    if (size == 0) {\n        return 0;\n    }\n    buf[0] = serial_getc(&stdio_uart);\n    return 1;\n}\n\nshort DirectSerial::poll(short events) const {\n    short revents = 0;\n    if ((events & POLLIN) && serial_readable(&stdio_uart)) {\n        revents |= POLLIN;\n    }\n    if ((events & POLLOUT) && serial_writable(&stdio_uart)) {\n        revents |= POLLOUT;\n    }\n    return revents;\n}\n\nclass Sink : public FileHandle {\npublic:\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) { return ESPIPE; }\n    virtual off_t size() { return -EINVAL; }\n    virtual int isatty() { return true; }\n    virtual int close() { return 0; }\n};\n\nssize_t Sink::write(const void *buffer, size_t size) {\n    // Just swallow the data - this is historical non-DEVICE_SERIAL behaviour\n    return size;\n}\n\nssize_t Sink::read(void *buffer, size_t size) {\n    // Produce 1 zero byte - historical behaviour returned 1 without touching\n    // the buffer\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    buf[0] = 0;\n    return 1;\n}\n#endif\n\nMBED_WEAK FileHandle* mbed::mbed_target_override_console(int fd)\n{\n    return NULL;\n}\n\nMBED_WEAK FileHandle* mbed::mbed_override_console(int fd)\n{\n    return NULL;\n}\n\nstatic int reserve_filehandle() {\n    // find the first empty slot in filehandles, after the slots reserved for stdin/stdout/stderr\n    filehandle_mutex->lock();\n    int fh_i;\n    for (fh_i = 3; fh_i < OPEN_MAX; fh_i++) {\n        /* Take a next free filehandle slot available. */\n        if (filehandles[fh_i] == NULL) break;\n    }\n    if (fh_i >= OPEN_MAX) {\n        /* Too many file handles have been opened */\n        errno = EMFILE;\n        filehandle_mutex->unlock();\n        return -1;\n    }\n    filehandles[fh_i] = FILE_HANDLE_RESERVED;\n    filehandle_mutex->unlock();\n\n    return fh_i;\n}\n\nint mbed::bind_to_fd(FileHandle *fh) {\n    int fh_i = reserve_filehandle();\n    if (fh_i < 0) {\n        return fh_i;\n    }\n\n    filehandles[fh_i] = fh;\n    stdio_in_prev[fh_i] = 0;\n    stdio_out_prev[fh_i] = 0;\n\n    return fh_i;\n}\n\n#ifdef __ARMCC_VERSION\nextern \"C\" char *_sys_command_string(char *cmd, int len) {\n    return NULL;\n}\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n/* prevents the exception handling name demangling code getting pulled in */\n#include \"mbed_error.h\"\nnamespace __gnu_cxx {\n    void __verbose_terminate_handler() {\n        error(\"Exception\");\n    }\n}\nextern \"C\" WEAK void __cxa_pure_virtual(void);\nextern \"C\" WEAK void __cxa_pure_virtual(void) {\n    exit(1);\n}\n\n#endif\n\n// Provide implementation of _sbrk (low-level dynamic memory allocation\n// routine) for GCC_ARM which compares new heap pointer with MSP instead of\n// SP.  This make it compatible with RTX RTOS thread stacks.\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\n\n#if defined(TARGET_CORTEX_A)\nextern \"C\" uint32_t  __HeapLimit;\n#endif\n\n// Turn off the errno macro and use actual global variable instead.\n#undef errno\nextern \"C\" int errno;\n\n// Dynamic memory allocation related syscall.\n#if (defined(TARGET_NUVOTON) || defined(TWO_RAM_REGIONS))\n\n// Overwrite _sbrk() to support two region model (heap and stack are two distinct regions).\n// __wrap__sbrk() is implemented in:\n// TARGET_NUMAKER_PFM_NUC472    targets/TARGET_NUVOTON/TARGET_NUC472/TARGET_NUMAKER_PFM_NUC472/TOOLCHAIN_GCC_ARM/nuc472_retarget.c\n// TARGET_NUMAKER_PFM_M453      targets/TARGET_NUVOTON/TARGET_M451/TARGET_NUMAKER_PFM_M453/TOOLCHAIN_GCC_ARM/m451_retarget.c\n// TARGET_STM32L4               targets/TARGET_STM/TARGET_STM32L4/TARGET_STM32L4/l4_retarget.c\nextern \"C\" void *__wrap__sbrk(int incr);\nextern \"C\" caddr_t _sbrk(int incr) {\n    return (caddr_t) __wrap__sbrk(incr);\n}\n#else\n// Linker defined symbol used by _sbrk to indicate where heap should start.\nextern \"C\" uint32_t __end__;\n// Weak attribute allows user to override, e.g. to use external RAM for dynamic memory.\nextern \"C\" WEAK caddr_t _sbrk(int incr) {\n    static unsigned char* heap = (unsigned char*)&__end__;\n    unsigned char*        prev_heap = heap;\n    unsigned char*        new_heap = heap + incr;\n\n#if defined(TARGET_CORTEX_A)\n    if (new_heap >= (unsigned char*)&__HeapLimit) {     /* __HeapLimit is end of heap section */\n#else\n    if (new_heap >= (unsigned char*)__get_MSP()) {\n#endif\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    // Additional heap checking if set\n    if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    heap = new_heap;\n    return (caddr_t) prev_heap;\n}\n#endif\n#endif\n\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\nextern \"C\" void _exit(int return_code) {\n#else\nnamespace std {\nextern \"C\" void exit(int return_code) {\n#endif\n\n#if DEVICE_STDIO_MESSAGES\n#if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT\n    fflush(stdout);\n    fflush(stderr);\n#endif\n#endif\n\n#if DEVICE_SEMIHOST\n    if (mbed_interface_connected()) {\n        semihost_exit();\n    }\n#endif\n    if (return_code) {\n        mbed_die();\n    }\n\n    while (1);\n}\n\n#if !defined(TOOLCHAIN_GCC_ARM) && !defined(TOOLCHAIN_GCC_CR)\n} //namespace std\n#endif\n\n#if defined(TOOLCHAIN_ARM) || defined(TOOLCHAIN_GCC)\n\n// This series of function disable the registration of global destructors\n// in a dynamic table which will be called when the application exit.\n// In mbed, program never exit properly, it dies.\n// More informations about this topic for ARMCC here:\n// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html\nextern \"C\" {\nint __aeabi_atexit(void *object, void (*dtor)(void* /*this*/), void *handle) {\n    return 1;\n}\n\nint __cxa_atexit(void (*dtor)(void* /*this*/), void *object, void *handle) {\n    return 1;\n}\n\nvoid __cxa_finalize(void *handle) {\n}\n\n} // end of extern \"C\"\n\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n\n/*\n * Depending on how newlib is  configured, it is often not enough to define\n * __aeabi_atexit, __cxa_atexit and __cxa_finalize in order to override the\n * behavior regarding the registration of handlers with atexit.\n *\n * To overcome this limitation, exit and atexit are overriden here.\n */\nextern \"C\"{\n\n/**\n * @brief Retarget of exit for GCC.\n * @details Unlike the standard version, this function doesn't call any function\n * registered with atexit before calling _exit.\n */\nvoid __wrap_exit(int return_code) {\n    _exit(return_code);\n}\n\n/**\n * @brief Retarget atexit from GCC.\n * @details This function will always fail and never register any handler to be\n * called at exit.\n */\nint __wrap_atexit(void (*func)()) {\n    return 1;\n}\n\n}\n\n#endif\n\n\n\nnamespace mbed {\n\nvoid mbed_set_unbuffered_stream(std::FILE *_file) {\n#if defined (__ICCARM__)\n    char buf[2];\n    std::setvbuf(_file,buf,_IONBF,NULL);\n#else\n    setbuf(_file, NULL);\n#endif\n}\n\n/* Applications are expected to use fdopen()\n * not this function directly. This code had to live here because FILE and FileHandle\n * processes are all linked together here.\n */\nstd::FILE *fdopen(FileHandle *fh, const char *mode)\n{\n    // This is to avoid scanf(buf, \":%.4s\", fh) and the bloat it brings.\n    char buf[1 + sizeof(fh)]; /* :(pointer) */\n    MBED_STATIC_ASSERT(sizeof(buf) == 5, \"Pointers should be 4 bytes.\");\n    buf[0] = ':';\n    memcpy(buf + 1, &fh, sizeof(fh));\n\n    std::FILE *stream = std::fopen(buf, mode);\n    /* newlib-nano doesn't appear to ever call _isatty itself, so\n     * happily fully buffers an interactive stream. Deal with that here.\n     */\n    if (stream && fh->isatty()) {\n        mbed_set_unbuffered_stream(stream);\n    }\n    return stream;\n}\n\nint mbed_getc(std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    int res = std::fgetc(_file);\n    if (res>=0){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return res;\n#else\n    return std::fgetc(_file);\n#endif\n}\n\nchar* mbed_gets(char*s, int size, std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    char *str = fgets(s,size,_file);\n    if (str!=NULL){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return str;\n#else\n    return std::fgets(s,size,_file);\n#endif\n}\n\n} // namespace mbed\n\n#if defined (__ICCARM__)\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __iar_system_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxunlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxunlock(__iar_Rmtx *mutex) {}\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ >= 8000000)\n#pragma section=\"__iar_tls$$DATA\"\nextern \"C\" WEAK void *__aeabi_read_tp (void) {\n  // Thread Local storage is not supported, using main thread memory for errno\n  return __section_begin(\"__iar_tls$$DATA\");\n}\n#endif\n#elif defined(__CC_ARM)\n// Do nothing\n#elif defined (__GNUC__)\nstruct _reent;\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __rtos_malloc_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_malloc_unlock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_unlock( struct _reent *_r ) {}\n\nextern \"C\" void __malloc_lock( struct _reent *_r )\n{\n    __rtos_malloc_lock(_r);\n}\n\nextern \"C\" void __malloc_unlock( struct _reent *_r )\n{\n    __rtos_malloc_unlock(_r);\n}\n\nextern \"C\" void __env_lock( struct _reent *_r )\n{\n    __rtos_env_lock(_r);\n}\n\nextern \"C\" void __env_unlock( struct _reent *_r )\n{\n    __rtos_env_unlock(_r);\n}\n\n#endif\n\n\n/* @brief   standard c library clock() function.\n *\n * This function returns the number of clock ticks elapsed since the start of the program.\n *\n * @note Synchronization level: Thread safe\n *\n * @return\n *  the number of clock ticks elapsed since the start of the program.\n *\n * */\nextern \"C\" clock_t clock()\n{\n    _mutex->lock();\n    clock_t t = ticker_read(get_us_ticker_data());\n    t /= 1000000 / CLOCKS_PER_SEC; // convert to processor time\n    _mutex->unlock();\n    return t;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have us_ticker_get_info\nMBED_WEAK const ticker_info_t* us_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have lp_ticker_get_info\nMBED_WEAK const ticker_info_t* lp_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/***************************************************\r\n  This is a library for the SHT31 Digital Humidity & Temp Sht31\r\n\r\n  Designed specifically to work with the SHT31 Digital Sht31 from Adafruit\r\n  ----> https://www.adafruit.com/products/2857\r\n\r\n  These displays use I2C to communicate, 2 pins are required to\r\n  interface\r\n  Adafruit invests time and resources providing this open source code,\r\n  please support Adafruit and open-source hardware by purchasing\r\n  products from Adafruit!\r\n\r\n  Written by Limor Fried/Ladyada for Adafruit Industries.\r\n  BSD license, all text above must be included in any redistribution\r\n ****************************************************/\r\n\r\n#include \"Sht31.h\"\r\n#include \"mbed.h\"\r\n#include \"emscripten.h\"\r\n\r\nSht31::Sht31(PinName sda, PinName scl) {\r\n    EM_ASM_({\r\n        window.MbedJSHal.sht31.init($0, $1, $2);\r\n    }, this, sda, scl);\r\n}\r\n\r\nfloat Sht31::readTemperature(void) {\r\n    int temp = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_temperature($0);\r\n    }, this);\r\n    return ((float)temp) / 100.0f;\r\n}\r\n\r\nfloat Sht31::readHumidity(void) {\r\n    int humidity = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_humidity($0);\r\n    }, this);\r\n    return ((float)humidity) / 100.0f;\r\n}\r\n","#include \"mbed.h\"\n#include \"mbed_events.h\"\n#include \"LoRaWANInterface.h\"\n#include \"Sht31.h\"\n#include \"SX1276_LoRaRadio.h\"\n\n// ABP Credentials - please copy them from the TTN Console\n// static uint32_t devaddr = 0x26011272;\n// static uint8_t nwk_s_key[] = { 0x61, 0x87, 0x7C, 0x75, 0x38, 0xB1, 0xE1, 0xCC, 0x12, 0x39, 0xD0, 0x2A, 0x2A, 0x8F, 0x3C, 0x54 };\n// static uint8_t app_s_key[] = { 0xB9, 0x60, 0xC6, 0x3D, 0x37, 0xA8, 0x79, 0x40, 0x6B, 0x97, 0x92, 0xC3, 0xFF, 0x9A, 0x95, 0x83 };\n\nstatic uint8_t DEV_EUI[] = { 0x00, 0xA9, 0x9D, 0x49, 0x21, 0xB2, 0x6D, 0x75 };\nstatic uint8_t APP_EUI[] = { 0x70, 0xB3, 0xD5, 0x7E, 0xD0, 0x00, 0xC1, 0x84 };\nstatic uint8_t APP_KEY[] = { 0xE1, 0x13, 0x6D, 0x7E, 0xB6, 0x91, 0x7F, 0xC4, 0xD5, 0x1F, 0x00, 0x14, 0x51, 0x1B, 0x86, 0xB1 };\n\n\n// The port we're sending and receiving on\n#define MBED_CONF_LORA_APP_PORT     15\n\n// Peripherals (LoRa radio, temperature sensor and button)\nSX1276_LoRaRadio radio(D11, D12, D13, D10, A0, D2, D3, D4, D5, D8, D9, NC, NC, NC, NC, A4, NC, NC);\nSht31 sht31(I2C_SDA, I2C_SCL);\nInterruptIn btn(BUTTON1);\n\n// EventQueue is required to dispatch events around\nstatic EventQueue ev_queue;\n\n// Constructing Mbed LoRaWANInterface and passing it down the radio object.\nstatic LoRaWANInterface lorawan(radio);\n\n// Application specific callbacks\nstatic lorawan_app_callbacks_t callbacks;\n\n// LoRaWAN stack event handler\nstatic void lora_event_handler(lorawan_event_t event);\n\n// Send a message over LoRaWAN\nstatic void send_message() {\n    uint8_t tx_buffer[50] = { 0 };\n\n    // Sending strings over LoRaWAN is not recommended\n    sprintf((char*) tx_buffer, \"Temperature = %3.1f\",\n                                   sht31.readTemperature());\n\n    int packet_len = strlen((char*) tx_buffer);\n\n    printf(\"Sending %d bytes: \\\"%s\\\"\\n\", packet_len, tx_buffer);\n\n    int16_t retcode = lorawan.send(MBED_CONF_LORA_APP_PORT, tx_buffer, packet_len, MSG_UNCONFIRMED_FLAG);\n\n    if (retcode < 0) {\n        retcode == LORAWAN_STATUS_WOULD_BLOCK ? printf(\"send - duty cycle violation\\n\")\n                : printf(\"send() - Error code %d\\n\", retcode);\n        return;\n    }\n\n    printf(\"%d bytes scheduled for transmission\\n\", retcode);\n}\n\nint main() {\n    printf(\"Press BUTTON1 to send the current value of the temperature sensor!\\n\");\n\n    if (lorawan.initialize(&ev_queue) != LORAWAN_STATUS_OK) {\n        printf(\"LoRa initialization failed!\\n\");\n        return -1;\n    }\n\n    // Fire a message when the button is pressed\n    btn.fall(&send_message);\n\n    // prepare application callbacks\n    callbacks.events = mbed::callback(lora_event_handler);\n    lorawan.add_app_callbacks(&callbacks);\n\n    // Disable adaptive data rating\n    if (lorawan.disable_adaptive_datarate() != LORAWAN_STATUS_OK) {\n        printf(\"disable_adaptive_datarate failed!\\n\");\n        return -1;\n    }\n\n    lorawan.set_datarate(4); // SF8BW500\n\n    lorawan_connect_t connect_params;\n    connect_params.connect_type = LORAWAN_CONNECTION_OTAA;\n    // connect_params.connection_u.abp.dev_addr = devaddr;\n    // connect_params.connection_u.abp.nwk_skey = nwk_s_key;\n    // connect_params.connection_u.abp.app_skey = app_s_key;\n\n    connect_params.connection_u.otaa.dev_eui = DEV_EUI;\n    connect_params.connection_u.otaa.app_eui = APP_EUI;\n    connect_params.connection_u.otaa.app_key = APP_KEY;\n    connect_params.connection_u.otaa.nb_trials = 3;\n\n    lorawan_status_t retcode = lorawan.connect(connect_params);\n\n    if (retcode == LORAWAN_STATUS_OK ||\n        retcode == LORAWAN_STATUS_CONNECT_IN_PROGRESS) {\n    } else {\n        printf(\"Connection error, code = %d\\n\", retcode);\n        return -1;\n    }\n\n    printf(\"Connection - In Progress ...\\r\\n\");\n\n    // make your event queue dispatching events forever\n    ev_queue.dispatch_forever();\n\n    return 0;\n}\n\n// This is called from RX_DONE, so whenever a message came in\nstatic void receive_message()\n{\n    uint8_t rx_buffer[50] = { 0 };\n    int16_t retcode;\n    retcode = lorawan.receive(MBED_CONF_LORA_APP_PORT, rx_buffer,\n                              sizeof(rx_buffer),\n                              MSG_CONFIRMED_FLAG|MSG_UNCONFIRMED_FLAG);\n\n    if (retcode < 0) {\n        printf(\"receive() - Error code %d\\n\", retcode);\n        return;\n    }\n\n    printf(\"Data received on port %d (length %d):\", MBED_CONF_LORA_APP_PORT, retcode);\n\n    for (uint8_t i = 0; i < retcode; i++) {\n        printf(\"%02x \", rx_buffer[i]);\n    }\n\n    printf(\"\\n\");\n}\n\n// Event handler\nstatic void lora_event_handler(lorawan_event_t event) {\n    switch (event) {\n        case CONNECTED:\n            printf(\"Connection - Successful\\n\");\n            break;\n        case DISCONNECTED:\n            ev_queue.break_dispatch();\n            printf(\"Disconnected Successfully\\n\");\n            break;\n        case TX_DONE:\n            printf(\"Message Sent to Network Server\\n\");\n            break;\n        case TX_TIMEOUT:\n        case TX_ERROR:\n        case TX_CRYPTO_ERROR:\n        case TX_SCHEDULING_ERROR:\n            printf(\"Transmission Error - EventCode = %d\\n\", event);\n            break;\n        case RX_DONE:\n            printf(\"Received message from Network Server\\n\");\n            receive_message();\n            break;\n        case RX_TIMEOUT:\n        case RX_ERROR:\n            printf(\"Error in reception - Code = %d\\n\", event);\n            break;\n        case JOIN_FAILURE:\n            printf(\"OTAA Failed - Check Keys\\n\");\n            break;\n        default:\n            MBED_ASSERT(\"Unknown Event\");\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/Timeout.h\"\n\nnamespace mbed {\n\nvoid Timeout::handler() {\n    _function.call();\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n\n#include \"gpio_irq_api.h\"\n#include \"mbed_error.h\"\n#include \"emscripten.h\"\n\nstatic gpio_irq_handler irq_handler;\n\nEMSCRIPTEN_KEEPALIVE\nvoid handle_interrupt_in(uint32_t id, gpio_irq_event event) {\n    irq_handler(id, event);\n}\n\nint gpio_irq_init(gpio_irq_t *obj, PinName pin, gpio_irq_handler handler, uint32_t id) {\n    if (pin == NC) return -1;\n\n    irq_handler = handler;\n\n    obj->port = pin;\n    obj->pin = pin;\n\n    EM_ASM_({\n        MbedJSHal.gpio.irq_init($0, $1);\n    }, id, obj->pin);\n\n    return 0;\n}\n\nvoid gpio_irq_free(gpio_irq_t *obj) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_free($0);\n    }, obj->pin, obj->id);\n}\n\nvoid gpio_irq_set(gpio_irq_t *obj, gpio_irq_event event, uint32_t enable) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_set($0, $1, $2);\n    }, obj->pin, event, enable);\n}\n\nvoid gpio_irq_enable(gpio_irq_t *obj) {\n}\n\nvoid gpio_irq_disable(gpio_irq_t *obj) {\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n#include \"us_ticker_api.h\"\n\nvoid us_ticker_init(void)\n{\n\n}\n\n\nuint32_t us_ticker_read()\n{\n    return 0;\n}\n\nvoid us_ticker_disable_interrupt(void)\n{\n\n}\n\nvoid us_ticker_clear_interrupt(void)\n{\n\n}\n\nvoid us_ticker_set_interrupt(timestamp_t timestamp)\n{\n}\n\nvoid us_ticker_fire_interrupt(void)\n{\n}\n","/*\n * Implementation for Posix compliant platforms\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue_platform.h\"\n\n#if defined(EQUEUE_PLATFORM_POSIX)\n\n#include <time.h>\n#include <sys/time.h>\n#include <errno.h>\n\n\n// Tick operations\nunsigned equeue_tick(void) {\n    struct timeval tv;\n    gettimeofday(&tv, 0);\n    return (unsigned)(tv.tv_sec*1000 + tv.tv_usec/1000);\n}\n\n\n// Mutex operations\nint equeue_mutex_create(equeue_mutex_t *m) {\n    return pthread_mutex_init(m, 0);\n}\n\nvoid equeue_mutex_destroy(equeue_mutex_t *m) {\n    pthread_mutex_destroy(m);\n}\n\nvoid equeue_mutex_lock(equeue_mutex_t *m) {\n    pthread_mutex_lock(m);\n}\n\nvoid equeue_mutex_unlock(equeue_mutex_t *m) {\n    pthread_mutex_unlock(m);\n}\n\n\n// Semaphore operations\nint equeue_sema_create(equeue_sema_t *s) {\n    int err = pthread_mutex_init(&s->mutex, 0);\n    if (err) {\n        return err;\n    }\n\n    err = pthread_cond_init(&s->cond, 0);\n    if (err) {\n        return err;\n    }\n\n    s->signal = false;\n    return 0;\n}\n\nvoid equeue_sema_destroy(equeue_sema_t *s) {\n    pthread_cond_destroy(&s->cond);\n    pthread_mutex_destroy(&s->mutex);\n}\n\nvoid equeue_sema_signal(equeue_sema_t *s) {\n    pthread_mutex_lock(&s->mutex);\n    s->signal = true;\n    pthread_cond_signal(&s->cond);\n    pthread_mutex_unlock(&s->mutex);\n}\n\nbool equeue_sema_wait(equeue_sema_t *s, int ms) {\n    pthread_mutex_lock(&s->mutex);\n    if (!s->signal) {\n        if (ms < 0) {\n            pthread_cond_wait(&s->cond, &s->mutex);\n        } else {\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n\n            struct timespec ts = {\n                .tv_sec = ms/1000 + tv.tv_sec,\n                .tv_nsec = ms*1000000 + tv.tv_usec*1000,\n            };\n\n            pthread_cond_timedwait(&s->cond, &s->mutex, &ts);\n        }\n    }\n\n    bool signal = s->signal;\n    s->signal = false;\n    pthread_mutex_unlock(&s->mutex);\n\n    return signal;\n}\n\n#endif\n","/**\n * @file\n *\n * @brief      Implementation of LoRaWANBase\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"lorawan/LoRaWANInterface.h\"\n\n#define tr_debug(...) void(0) //dummies if feature common pal is not added\n#define tr_info(...)  printf(\"[LWIF][INF] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_error(...) printf(\"[LWIF][ERR] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n#define tr_warn(...) printf(\"[LWIF][WRN] \"); printf(__VA_ARGS__); printf(\"\\n\") //dummies if feature common pal is not added\n\nusing namespace events;\n\ninline LoRaWANStack& stk_obj()\n{\n    return LoRaWANStack::get_lorawan_stack();\n}\n\nLoRaWANInterface::LoRaWANInterface(LoRaRadio& radio) : _link_check_requested(false)\n{\n    // Pass mac_handlers to radio to the radio driver after\n    // binding radio driver to PHY layer\n    radio_events_t *events = stk_obj().bind_radio_driver(radio);\n    radio.lock();\n    radio.init_radio(events);\n    radio.unlock();\n}\n\nLoRaWANInterface::~LoRaWANInterface()\n{\n}\n\nlorawan_status_t LoRaWANInterface::initialize(EventQueue *queue)\n{\n    if(!queue) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    return stk_obj().initialize_mac_layer(queue);\n}\n\nlorawan_status_t LoRaWANInterface::connect()\n{\n    // connection attempt without parameters.\n    // System tries to look for configuration in mbed_lib.json that can be\n    // overridden by mbed_app.json. However, if none of the json files are\n    // available (highly unlikely), we still fallback to some default parameters.\n    // Check lorawan_data_structure for fallback defaults.\n\n    lorawan_connect_t connection_params;\n\n    if (MBED_CONF_LORA_OVER_THE_AIR_ACTIVATION) {\n        static uint8_t dev_eui[] = MBED_CONF_LORA_DEVICE_EUI;\n        static uint8_t app_eui[] = MBED_CONF_LORA_APPLICATION_EUI;\n        static uint8_t app_key[] = MBED_CONF_LORA_APPLICATION_KEY;\n        /**\n         *\n         * OTAA join\n         */\n        connection_params.connect_type = LORAWAN_CONNECTION_OTAA;\n        connection_params.connection_u.otaa.app_eui = app_eui;\n        connection_params.connection_u.otaa.dev_eui = dev_eui;\n        connection_params.connection_u.otaa.app_key = app_key;\n        connection_params.connection_u.otaa.nb_trials = MBED_CONF_LORA_NB_TRIALS;\n\n        return connect(connection_params);\n    } else {\n        static uint8_t nwk_skey[] = MBED_CONF_LORA_NWKSKEY;\n        static uint8_t app_skey[] = MBED_CONF_LORA_APPSKEY;\n        static uint32_t dev_addr = MBED_CONF_LORA_DEVICE_ADDRESS;\n        static uint32_t nwk_id = (MBED_CONF_LORA_DEVICE_ADDRESS & LORAWAN_NETWORK_ID_MASK);\n\n        /**\n         *\n         * ABP connection\n         */\n        connection_params.connect_type = LORAWAN_CONNECTION_ABP;\n        connection_params.connection_u.abp.nwk_id = nwk_id;\n        connection_params.connection_u.abp.dev_addr = dev_addr;\n        connection_params.connection_u.abp.nwk_skey = nwk_skey;\n        connection_params.connection_u.abp.app_skey = app_skey;\n\n        return connect(connection_params);\n    }\n}\n\nlorawan_status_t LoRaWANInterface::connect(const lorawan_connect_t &connect)\n{\n    lorawan_status_t mac_status;\n\n    if (connect.connect_type == LORAWAN_CONNECTION_OTAA) {\n        mac_status = stk_obj().join_request_by_otaa(connect);\n    } else if (connect.connect_type == LORAWAN_CONNECTION_ABP) {\n        mac_status = stk_obj().activation_by_personalization(connect);\n    } else {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    return mac_status;\n}\n\nlorawan_status_t LoRaWANInterface::disconnect()\n{\n    return stk_obj().shutdown();\n}\n\nlorawan_status_t LoRaWANInterface::add_link_check_request()\n{\n    _link_check_requested = true;\n    return stk_obj().set_link_check_request();\n}\n\nvoid LoRaWANInterface::remove_link_check_request()\n{\n    _link_check_requested = false;\n}\n\nlorawan_status_t LoRaWANInterface::set_datarate(uint8_t data_rate)\n{\n    return stk_obj().set_channel_data_rate(data_rate);\n}\n\nlorawan_status_t LoRaWANInterface::set_confirmed_msg_retries(uint8_t count)\n{\n    return stk_obj().set_confirmed_msg_retry(count);\n}\n\nlorawan_status_t LoRaWANInterface::enable_adaptive_datarate()\n{\n    return stk_obj().enable_adaptive_datarate(true);\n}\n\nlorawan_status_t LoRaWANInterface::disable_adaptive_datarate()\n{\n    return stk_obj().enable_adaptive_datarate(false);\n}\n\nlorawan_status_t LoRaWANInterface::set_channel_plan(const lorawan_channelplan_t &channel_plan)\n{\n    return stk_obj().add_channels(channel_plan);\n}\n\nlorawan_status_t LoRaWANInterface::get_channel_plan(lorawan_channelplan_t &channel_plan)\n{\n    return stk_obj().get_enabled_channels(channel_plan);\n}\n\nlorawan_status_t LoRaWANInterface::remove_channel(uint8_t id)\n{\n    return stk_obj().remove_a_channel(id);\n}\n\nlorawan_status_t LoRaWANInterface::remove_channel_plan()\n{\n    return stk_obj().drop_channel_list();\n}\n\nint16_t LoRaWANInterface::send(uint8_t port, const uint8_t* data,\n                               uint16_t length, int flags)\n{\n    if (_link_check_requested) {\n        // add a link check request with normal data, until the application\n        // explicitly removes it.\n        add_link_check_request();\n    }\n\n    tr_info(\"send\");\n\n    if (data) {\n        return stk_obj().handle_tx(port, data, length, flags);\n    } else {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n}\n\nint16_t LoRaWANInterface::receive(uint8_t port, uint8_t* data, uint16_t length,\n                                  int flags)\n{\n    if (data && length > 0) {\n        return stk_obj().handle_rx(port, data, length, flags);\n    } else {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n}\n\nlorawan_status_t LoRaWANInterface::add_app_callbacks(lorawan_app_callbacks_t *callbacks)\n  {\n\n     if (!callbacks || !callbacks->events) {\n         // Event Callback is mandatory\n         return LORAWAN_STATUS_PARAMETER_INVALID;\n     }\n\n     stk_obj().set_lora_callbacks(callbacks);\n     return LORAWAN_STATUS_OK;\n  }\n","/* mbed Microcontroller Library\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <stddef.h>\n#include \"hal/ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n#include \"mbed_assert.h\"\n\nstatic void schedule_interrupt(const ticker_data_t *const ticker);\nstatic void update_present_time(const ticker_data_t *const ticker);\n\n/*\n * Initialize a ticker instance.  \n */\nstatic void initialize(const ticker_data_t *ticker)\n{\n    // return if the queue has already been initialized, in that case the \n    // interface used by the queue is already initialized.\n    if (ticker->queue->initialized) { \n        return;\n    }\n\n    ticker->interface->init();\n\n    const ticker_info_t *info = ticker->interface->get_info();\n    uint32_t frequency = info->frequency;\n    if (info->frequency == 0) {\n        MBED_ASSERT(0);\n        frequency = 1000000;\n    }\n\n    uint32_t bits = info->bits;\n    if ((info->bits > 32) || (info->bits < 4)) {\n        MBED_ASSERT(0);\n        bits = 32;\n    }\n    uint32_t max_delta = 0x7 << (bits - 4); // 7/16th\n    uint64_t max_delta_us =\n            ((uint64_t)max_delta * 1000000 + frequency - 1) / frequency;\n\n    ticker->queue->event_handler = NULL;\n    ticker->queue->head = NULL;\n    ticker->queue->tick_last_read = ticker->interface->read();\n    ticker->queue->tick_remainder = 0;\n    ticker->queue->frequency = frequency;\n    ticker->queue->bitmask = ((uint64_t)1 << bits) - 1;\n    ticker->queue->max_delta = max_delta;\n    ticker->queue->max_delta_us = max_delta_us;\n    ticker->queue->present_time = 0;\n    ticker->queue->initialized = true;\n    \n    update_present_time(ticker);\n    schedule_interrupt(ticker);\n}\n\n/**\n * Set the event handler function of a ticker instance. \n */\nstatic void set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)\n{\n    ticker->queue->event_handler = handler;\n}\n\n/*\n * Convert a 32 bit timestamp into a 64 bit timestamp.\n *\n * A 64 bit timestamp is used as the point of time of reference while the \n * timestamp to convert is relative to this point of time. \n *\n * The lower 32 bits of the timestamp returned will be equal to the timestamp to \n * convert. \n * \n * If the timestamp to convert is less than the lower 32 bits of the time \n * reference then the timestamp to convert is seen as an overflowed value and \n * the upper 32 bit of the timestamp returned will be equal to the upper 32 bit \n * of the reference point + 1. \n * Otherwise, the upper 32 bit returned will be equal to the upper 32 bit of the \n * reference point. \n *\n * @param ref: The 64 bit timestamp of reference.\n * @param timestamp: The timestamp to convert.\n */\nstatic us_timestamp_t convert_timestamp(us_timestamp_t ref, timestamp_t timestamp)\n{\n    bool overflow = timestamp < ((timestamp_t) ref) ? true : false;\n\n    us_timestamp_t result = (ref & ~((us_timestamp_t)UINT32_MAX)) | timestamp;\n    if (overflow) { \n        result += (1ULL<<32);\n    }\n\n    return result;\n}\n\n/**\n * Update the present timestamp value of a ticker.\n */\nstatic void update_present_time(const ticker_data_t *const ticker)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    uint32_t ticker_time = ticker->interface->read();\n    if (ticker_time == ticker->queue->tick_last_read) {\n        // No work to do\n        return;\n    }\n\n    uint64_t elapsed_ticks = (ticker_time - queue->tick_last_read) & queue->bitmask;\n    queue->tick_last_read = ticker_time;\n\n    uint64_t elapsed_us;\n    if (1000000 == queue->frequency) {\n        // Optimized for 1MHz\n\n        elapsed_us = elapsed_ticks;\n    } else if (32768 == queue->frequency) {\n        // Optimized for 32KHz\n\n        uint64_t us_x_ticks = elapsed_ticks * 1000000;\n        elapsed_us = us_x_ticks >> 15;\n\n        // Update remainder\n        queue->tick_remainder += us_x_ticks - (elapsed_us << 15);\n        if (queue->tick_remainder >= queue->frequency) {\n            elapsed_us += 1;\n            queue->tick_remainder -= queue->frequency;\n        }\n    } else {\n        // General case\n\n        uint64_t us_x_ticks = elapsed_ticks * 1000000;\n        elapsed_us = us_x_ticks / queue->frequency;\n\n        // Update remainder\n        queue->tick_remainder += us_x_ticks - elapsed_us * queue->frequency;\n        if (queue->tick_remainder >= queue->frequency) {\n            elapsed_us += 1;\n            queue->tick_remainder -= queue->frequency;\n        }\n    }\n\n    // Update current time\n    queue->present_time += elapsed_us;\n}\n\n/**\n * Given the absolute timestamp compute the hal tick timestamp.\n */\nstatic timestamp_t compute_tick(const ticker_data_t *const ticker, us_timestamp_t timestamp)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    us_timestamp_t delta_us = timestamp - queue->present_time;\n\n    timestamp_t delta = ticker->queue->max_delta;\n    if (delta_us <=  ticker->queue->max_delta_us) {\n        // Checking max_delta_us ensures the operation will not overflow\n\n        if (1000000 == queue->frequency) {\n            // Optimized for 1MHz\n\n            delta = delta_us;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        } else if (32768 == queue->frequency) {\n            // Optimized for 32KHz\n\n            delta = (delta_us << 15) / 1000000;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        } else {\n            // General case\n\n            delta = delta_us * queue->frequency / 1000000;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        }\n    }\n    return (queue->tick_last_read + delta) & queue->bitmask;\n}\n\n/**\n * Return 1 if the tick has incremented to or past match_tick, otherwise 0.\n */\nint _ticker_match_interval_passed(timestamp_t prev_tick, timestamp_t cur_tick, timestamp_t match_tick)\n{\n    if (match_tick > prev_tick) {\n        return (cur_tick >= match_tick) || (cur_tick < prev_tick);\n    } else {\n        return (cur_tick < prev_tick) && (cur_tick >= match_tick);\n    }\n}\n\n/**\n * Compute the time when the interrupt has to be triggered and schedule it.  \n * \n * If there is no event in the queue or the next event to execute is in more \n * than ticker.queue.max_delta ticks from now then the ticker irq will be\n * scheduled in ticker.queue.max_delta ticks. Otherwise the irq will be\n * scheduled to happen when the running counter reach the timestamp of the\n * first event in the queue.\n * \n * @note If there is no event in the queue then the interrupt is scheduled to \n * in ticker.queue.max_delta. This is necessary to keep track\n * of the timer overflow.\n */\nstatic void schedule_interrupt(const ticker_data_t *const ticker)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    update_present_time(ticker);\n\n    if (ticker->queue->head) {\n        us_timestamp_t present = ticker->queue->present_time;\n        us_timestamp_t match_time = ticker->queue->head->timestamp;\n\n        // if the event at the head of the queue is in the past then schedule\n        // it immediately.\n        if (match_time <= present) {\n            ticker->interface->fire_interrupt();\n            return;\n        }\n\n        timestamp_t match_tick = compute_tick(ticker, match_time);\n        // The time has been checked to be future, but it could still round\n        // to the last tick as a result of us to ticks conversion\n        if (match_tick == queue->tick_last_read) {\n            // Match time has already expired so fire immediately\n            ticker->interface->fire_interrupt();\n            return;\n        }\n\n        ticker->interface->set_interrupt(match_tick);\n        timestamp_t cur_tick = ticker->interface->read();\n\n        if (_ticker_match_interval_passed(queue->tick_last_read, cur_tick, match_tick)) {\n            ticker->interface->fire_interrupt();\n        }\n    } else {\n        uint32_t match_tick =\n                (queue->tick_last_read + queue->max_delta) & queue->bitmask;\n        ticker->interface->set_interrupt(match_tick);\n    }\n}\n\nvoid ticker_set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)\n{\n    initialize(ticker);\n\n    core_util_critical_section_enter();\n    set_handler(ticker, handler);\n    core_util_critical_section_exit();\n}\n\nvoid ticker_irq_handler(const ticker_data_t *const ticker)\n{\n    core_util_critical_section_enter();\n\n    ticker->interface->clear_interrupt();\n\n    /* Go through all the pending TimerEvents */\n    while (1) {\n        if (ticker->queue->head == NULL) {\n            break;\n        }\n\n        // update the current timestamp used by the queue \n        update_present_time(ticker);\n\n        if (ticker->queue->head->timestamp <= ticker->queue->present_time) { \n            // This event was in the past:\n            //      point to the following one and execute its handler\n            ticker_event_t *p = ticker->queue->head;\n            ticker->queue->head = ticker->queue->head->next;\n            if (ticker->queue->event_handler != NULL) {\n                (*ticker->queue->event_handler)(p->id); // NOTE: the handler can set new events\n            }\n            /* Note: We continue back to examining the head because calling the\n             * event handler may have altered the chain of pending events. */\n        } else {\n            break;\n        } \n    }\n\n    schedule_interrupt(ticker);\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_insert_event(const ticker_data_t *const ticker, ticker_event_t *obj, timestamp_t timestamp, uint32_t id)\n{\n    core_util_critical_section_enter();\n\n    // update the current timestamp\n    update_present_time(ticker);\n    us_timestamp_t absolute_timestamp = convert_timestamp(\n        ticker->queue->present_time, \n        timestamp\n    );\n\n    // defer to ticker_insert_event_us\n    ticker_insert_event_us(\n        ticker, \n        obj, absolute_timestamp, id\n    );\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_insert_event_us(const ticker_data_t *const ticker, ticker_event_t *obj, us_timestamp_t timestamp, uint32_t id)\n{\n    core_util_critical_section_enter();\n\n    // update the current timestamp\n    update_present_time(ticker);\n\n    // initialise our data\n    obj->timestamp = timestamp;\n    obj->id = id;\n\n    /* Go through the list until we either reach the end, or find\n       an element this should come before (which is possibly the\n       head). */\n    ticker_event_t *prev = NULL, *p = ticker->queue->head;\n    while (p != NULL) {\n        /* check if we come before p */\n        if (timestamp < p->timestamp) {\n            break;\n        }\n        /* go to the next element */\n        prev = p;\n        p = p->next;\n    }\n    \n    /* if we're at the end p will be NULL, which is correct */\n    obj->next = p;\n\n    /* if prev is NULL we're at the head */\n    if (prev == NULL) {\n        ticker->queue->head = obj;\n    } else {\n        prev->next = obj;\n    }\n\n    schedule_interrupt(ticker);\n\n    core_util_critical_section_exit();\n\n}\n\nvoid ticker_remove_event(const ticker_data_t *const ticker, ticker_event_t *obj)\n{\n    core_util_critical_section_enter();\n\n    // remove this object from the list\n    if (ticker->queue->head == obj) {\n        // first in the list, so just drop me\n        ticker->queue->head = obj->next;\n        schedule_interrupt(ticker);\n    } else {\n        // find the object before me, then drop me\n        ticker_event_t* p = ticker->queue->head;\n        while (p != NULL) {\n            if (p->next == obj) {\n                p->next = obj->next;\n                break;\n            }\n            p = p->next;\n        }\n    }\n\n    core_util_critical_section_exit();\n}\n\ntimestamp_t ticker_read(const ticker_data_t *const ticker)\n{\n    return ticker_read_us(ticker);\n}\n\nus_timestamp_t ticker_read_us(const ticker_data_t *const ticker)\n{\n    initialize(ticker);\n\n    core_util_critical_section_enter();\n    update_present_time(ticker);\n    core_util_critical_section_exit();\n\n    return ticker->queue->present_time;\n}\n\nint ticker_get_next_timestamp(const ticker_data_t *const data, timestamp_t *timestamp)\n{\n    int ret = 0;\n\n    /* if head is NULL, there are no pending events */\n    core_util_critical_section_enter();\n    if (data->queue->head != NULL) {\n        *timestamp = data->queue->head->timestamp;\n        ret = 1;\n    }\n    core_util_critical_section_exit();\n\n    return ret;\n}\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"lorastack/mac/LoRaMacChannelPlan.h\"\n\nLoRaMacChannelPlan::LoRaMacChannelPlan() : _lora_phy(NULL)\n{\n}\n\nLoRaMacChannelPlan::~LoRaMacChannelPlan()\n{\n}\n\nvoid LoRaMacChannelPlan::activate_channelplan_subsystem(LoRaPHY *phy)\n{\n    _lora_phy = phy;\n}\n\nlorawan_status_t LoRaMacChannelPlan::set_plan(const lorawan_channelplan_t& plan)\n{\n    channel_params_t mac_layer_ch_params;\n    lorawan_status_t status;\n\n    uint8_t max_num_channels;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    // check if user is setting more channels than supported\n    if (plan.nb_channels > max_num_channels) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    for (uint8_t i = 0; i < plan.nb_channels; i++) {\n\n        mac_layer_ch_params.band = plan.channels[i].ch_param.band;\n\n        mac_layer_ch_params.dr_range.fields.max = plan.channels[i].ch_param.dr_range.fields.max;\n        mac_layer_ch_params.dr_range.fields.min = plan.channels[i].ch_param.dr_range.fields.min;\n        mac_layer_ch_params.dr_range.value = plan.channels[i].ch_param.dr_range.value;\n        mac_layer_ch_params.frequency = plan.channels[i].ch_param.frequency;\n        mac_layer_ch_params.rx1_frequency = plan.channels[i].ch_param.rx1_frequency;\n\n        status = _lora_phy->add_channel(&mac_layer_ch_params, plan.channels[i].id);\n\n        if (status != LORAWAN_STATUS_OK) {\n            return status;\n        }\n    }\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMacChannelPlan::get_plan(lorawan_channelplan_t& plan,\n                                             const loramac_mib_req_confirm_t* mib_confirm)\n{\n    if (mib_confirm == NULL) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    uint8_t max_num_channels;\n    uint16_t *channel_mask;\n    uint8_t count = 0;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    channel_mask = _lora_phy->get_channel_mask(false);\n\n    for (uint8_t i = 0; i < max_num_channels; i++) {\n        // skip the channels which are not enabled\n        if (_lora_phy->mask_bit_test(channel_mask, i) == 0) {\n            continue;\n        }\n\n        // otherwise add them to the channel_plan struct\n        plan.channels[count].id = i;\n        plan.channels[count].ch_param.frequency = mib_confirm->param.channel_list[i].frequency;\n        plan.channels[count].ch_param.dr_range.value = mib_confirm->param.channel_list[i].dr_range.value;\n        plan.channels[count].ch_param.dr_range.fields.min = mib_confirm->param.channel_list[i].dr_range.fields.min;\n        plan.channels[count].ch_param.dr_range.fields.max = mib_confirm->param.channel_list[i].dr_range.fields.max;\n        plan.channels[count].ch_param.band = mib_confirm->param.channel_list[i].band;\n        plan.channels[count].ch_param.rx1_frequency = mib_confirm->param.channel_list[i].rx1_frequency;\n        count++;\n    }\n\n    plan.nb_channels = count;\n\n    return LORAWAN_STATUS_OK;\n}\n\nlorawan_status_t LoRaMacChannelPlan::remove_plan()\n{\n    lorawan_status_t status = LORAWAN_STATUS_OK;\n\n    uint8_t max_num_channels;\n    uint16_t *channel_mask;\n    uint16_t *default_channel_mask;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    channel_mask = _lora_phy->get_channel_mask(false);\n\n    default_channel_mask = _lora_phy->get_channel_mask(true);\n\n    for (uint8_t i = 0; i < max_num_channels; i++) {\n        // skip any default channels\n        if (_lora_phy->mask_bit_test(default_channel_mask, i) != 0) {\n            continue;\n        }\n\n        // skip any channels which are not currently enabled\n        if (_lora_phy->mask_bit_test(channel_mask, i) == 0) {\n            continue;\n        }\n\n        status = remove_single_channel(i);\n\n        if (status != LORAWAN_STATUS_OK) {\n            return status;\n        }\n    }\n\n    return status;\n}\n\nlorawan_status_t LoRaMacChannelPlan::remove_single_channel(uint8_t channel_id)\n{\n    uint8_t max_num_channels;\n\n    if (!_lora_phy->is_custom_channel_plan_supported()) {\n        return LORAWAN_STATUS_SERVICE_UNKNOWN;\n    }\n\n    max_num_channels = _lora_phy->get_max_nb_channels();\n\n    // According to specification channel IDs start from 0 and last valid\n    // channel ID is N-1 where N=MAX_NUM_CHANNELS.\n    // So any ID which is larger or equal to the Max number of channels is invalid\n    if (channel_id >= max_num_channels) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    if (_lora_phy->remove_channel(channel_id) == false) {\n        return LORAWAN_STATUS_PARAMETER_INVALID;\n    }\n\n    _lora_phy->put_radio_to_sleep();\n\n    return LORAWAN_STATUS_OK;\n}\n\n","/*\n *  NIST SP800-38D compliant GCM implementation\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n/*\n * http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf\n *\n * See also:\n * [MGV] http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-revised-spec.pdf\n *\n * We use the algorithm described as Shoup's method with 4-bit tables in\n * [MGV] 4.1, pp. 12-13, to enhance speed without using too much memory.\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_GCM_C)\n\n#include \"mbedtls/gcm.h\"\n\n#include <string.h>\n\n#if defined(MBEDTLS_AESNI_C)\n#include \"mbedtls/aesni.h\"\n#endif\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n#include \"mbedtls/aes.h\"\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdio.h>\n#define mbedtls_printf printf\n#endif /* MBEDTLS_PLATFORM_C */\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#if !defined(MBEDTLS_GCM_ALT)\n\n/*\n * 32-bit integer manipulation macros (big endian)\n */\n#ifndef GET_UINT32_BE\n#define GET_UINT32_BE(n,b,i)                            \\\n{                                                       \\\n    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \\\n        | ( (uint32_t) (b)[(i) + 1] << 16 )             \\\n        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \\\n        | ( (uint32_t) (b)[(i) + 3]       );            \\\n}\n#endif\n\n#ifndef PUT_UINT32_BE\n#define PUT_UINT32_BE(n,b,i)                            \\\n{                                                       \\\n    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \\\n    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \\\n    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \\\n    (b)[(i) + 3] = (unsigned char) ( (n)       );       \\\n}\n#endif\n\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n\n/*\n * Initialize a context\n */\nvoid mbedtls_gcm_init( mbedtls_gcm_context *ctx )\n{\n    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );\n}\n\n/*\n * Precompute small multiples of H, that is set\n *      HH[i] || HL[i] = H times i,\n * where i is seen as a field element as in [MGV], ie high-order bits\n * correspond to low powers of P. The result is stored in the same way, that\n * is the high-order bit of HH corresponds to P^0 and the low-order bit of HL\n * corresponds to P^127.\n */\nstatic int gcm_gen_table( mbedtls_gcm_context *ctx )\n{\n    int ret, i, j;\n    uint64_t hi, lo;\n    uint64_t vl, vh;\n    unsigned char h[16];\n    size_t olen = 0;\n\n    memset( h, 0, 16 );\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, h, 16, h, &olen ) ) != 0 )\n        return( ret );\n\n    /* pack h as two 64-bits ints, big-endian */\n    GET_UINT32_BE( hi, h,  0  );\n    GET_UINT32_BE( lo, h,  4  );\n    vh = (uint64_t) hi << 32 | lo;\n\n    GET_UINT32_BE( hi, h,  8  );\n    GET_UINT32_BE( lo, h,  12 );\n    vl = (uint64_t) hi << 32 | lo;\n\n    /* 8 = 1000 corresponds to 1 in GF(2^128) */\n    ctx->HL[8] = vl;\n    ctx->HH[8] = vh;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    /* With CLMUL support, we need only h, not the rest of the table */\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_CLMUL ) )\n        return( 0 );\n#endif\n\n    /* 0 corresponds to 0 in GF(2^128) */\n    ctx->HH[0] = 0;\n    ctx->HL[0] = 0;\n\n    for( i = 4; i > 0; i >>= 1 )\n    {\n        uint32_t T = ( vl & 1 ) * 0xe1000000U;\n        vl  = ( vh << 63 ) | ( vl >> 1 );\n        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);\n\n        ctx->HL[i] = vl;\n        ctx->HH[i] = vh;\n    }\n\n    for( i = 2; i <= 8; i *= 2 )\n    {\n        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;\n        vh = *HiH;\n        vl = *HiL;\n        for( j = 1; j < i; j++ )\n        {\n            HiH[j] = vh ^ ctx->HH[j];\n            HiL[j] = vl ^ ctx->HL[j];\n        }\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_setkey( mbedtls_gcm_context *ctx,\n                        mbedtls_cipher_id_t cipher,\n                        const unsigned char *key,\n                        unsigned int keybits )\n{\n    int ret;\n    const mbedtls_cipher_info_t *cipher_info;\n\n    cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );\n    if( cipher_info == NULL )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    if( cipher_info->block_size != 16 )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n\n    if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,\n                               MBEDTLS_ENCRYPT ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = gcm_gen_table( ctx ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\n/*\n * Shoup's method for multiplication use this table with\n *      last4[x] = x times P^128\n * where x and last4[x] are seen as elements of GF(2^128) as in [MGV]\n */\nstatic const uint64_t last4[16] =\n{\n    0x0000, 0x1c20, 0x3840, 0x2460,\n    0x7080, 0x6ca0, 0x48c0, 0x54e0,\n    0xe100, 0xfd20, 0xd940, 0xc560,\n    0x9180, 0x8da0, 0xa9c0, 0xb5e0\n};\n\n/*\n * Sets output to x times H using the precomputed tables.\n * x and output are seen as elements of GF(2^128) as in [MGV].\n */\nstatic void gcm_mult( mbedtls_gcm_context *ctx, const unsigned char x[16],\n                      unsigned char output[16] )\n{\n    int i = 0;\n    unsigned char lo, hi, rem;\n    uint64_t zh, zl;\n\n#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_CLMUL ) ) {\n        unsigned char h[16];\n\n        PUT_UINT32_BE( ctx->HH[8] >> 32, h,  0 );\n        PUT_UINT32_BE( ctx->HH[8],       h,  4 );\n        PUT_UINT32_BE( ctx->HL[8] >> 32, h,  8 );\n        PUT_UINT32_BE( ctx->HL[8],       h, 12 );\n\n        mbedtls_aesni_gcm_mult( output, x, h );\n        return;\n    }\n#endif /* MBEDTLS_AESNI_C && MBEDTLS_HAVE_X86_64 */\n\n    lo = x[15] & 0xf;\n\n    zh = ctx->HH[lo];\n    zl = ctx->HL[lo];\n\n    for( i = 15; i >= 0; i-- )\n    {\n        lo = x[i] & 0xf;\n        hi = x[i] >> 4;\n\n        if( i != 15 )\n        {\n            rem = (unsigned char) zl & 0xf;\n            zl = ( zh << 60 ) | ( zl >> 4 );\n            zh = ( zh >> 4 );\n            zh ^= (uint64_t) last4[rem] << 48;\n            zh ^= ctx->HH[lo];\n            zl ^= ctx->HL[lo];\n\n        }\n\n        rem = (unsigned char) zl & 0xf;\n        zl = ( zh << 60 ) | ( zl >> 4 );\n        zh = ( zh >> 4 );\n        zh ^= (uint64_t) last4[rem] << 48;\n        zh ^= ctx->HH[hi];\n        zl ^= ctx->HL[hi];\n    }\n\n    PUT_UINT32_BE( zh >> 32, output, 0 );\n    PUT_UINT32_BE( zh, output, 4 );\n    PUT_UINT32_BE( zl >> 32, output, 8 );\n    PUT_UINT32_BE( zl, output, 12 );\n}\n\nint mbedtls_gcm_starts( mbedtls_gcm_context *ctx,\n                int mode,\n                const unsigned char *iv,\n                size_t iv_len,\n                const unsigned char *add,\n                size_t add_len )\n{\n    int ret;\n    unsigned char work_buf[16];\n    size_t i;\n    const unsigned char *p;\n    size_t use_len, olen = 0;\n\n    /* IV and AD are limited to 2^64 bits, so 2^61 bytes */\n    /* IV is not allowed to be zero length */\n    if( iv_len == 0 ||\n      ( (uint64_t) iv_len  ) >> 61 != 0 ||\n      ( (uint64_t) add_len ) >> 61 != 0 )\n    {\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n    }\n\n    memset( ctx->y, 0x00, sizeof(ctx->y) );\n    memset( ctx->buf, 0x00, sizeof(ctx->buf) );\n\n    ctx->mode = mode;\n    ctx->len = 0;\n    ctx->add_len = 0;\n\n    if( iv_len == 12 )\n    {\n        memcpy( ctx->y, iv, iv_len );\n        ctx->y[15] = 1;\n    }\n    else\n    {\n        memset( work_buf, 0x00, 16 );\n        PUT_UINT32_BE( iv_len * 8, work_buf, 12 );\n\n        p = iv;\n        while( iv_len > 0 )\n        {\n            use_len = ( iv_len < 16 ) ? iv_len : 16;\n\n            for( i = 0; i < use_len; i++ )\n                ctx->y[i] ^= p[i];\n\n            gcm_mult( ctx, ctx->y, ctx->y );\n\n            iv_len -= use_len;\n            p += use_len;\n        }\n\n        for( i = 0; i < 16; i++ )\n            ctx->y[i] ^= work_buf[i];\n\n        gcm_mult( ctx, ctx->y, ctx->y );\n    }\n\n    if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ctx->base_ectr,\n                             &olen ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    ctx->add_len = add_len;\n    p = add;\n    while( add_len > 0 )\n    {\n        use_len = ( add_len < 16 ) ? add_len : 16;\n\n        for( i = 0; i < use_len; i++ )\n            ctx->buf[i] ^= p[i];\n\n        gcm_mult( ctx, ctx->buf, ctx->buf );\n\n        add_len -= use_len;\n        p += use_len;\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_update( mbedtls_gcm_context *ctx,\n                size_t length,\n                const unsigned char *input,\n                unsigned char *output )\n{\n    int ret;\n    unsigned char ectr[16];\n    size_t i;\n    const unsigned char *p;\n    unsigned char *out_p = output;\n    size_t use_len, olen = 0;\n\n    if( output > input && (size_t) ( output - input ) < length )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes\n     * Also check for possible overflow */\n    if( ctx->len + length < ctx->len ||\n        (uint64_t) ctx->len + length > 0xFFFFFFFE0ull )\n    {\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n    }\n\n    ctx->len += length;\n\n    p = input;\n    while( length > 0 )\n    {\n        use_len = ( length < 16 ) ? length : 16;\n\n        for( i = 16; i > 12; i-- )\n            if( ++ctx->y[i - 1] != 0 )\n                break;\n\n        if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,\n                                   &olen ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        for( i = 0; i < use_len; i++ )\n        {\n            if( ctx->mode == MBEDTLS_GCM_DECRYPT )\n                ctx->buf[i] ^= p[i];\n            out_p[i] = ectr[i] ^ p[i];\n            if( ctx->mode == MBEDTLS_GCM_ENCRYPT )\n                ctx->buf[i] ^= out_p[i];\n        }\n\n        gcm_mult( ctx, ctx->buf, ctx->buf );\n\n        length -= use_len;\n        p += use_len;\n        out_p += use_len;\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_finish( mbedtls_gcm_context *ctx,\n                unsigned char *tag,\n                size_t tag_len )\n{\n    unsigned char work_buf[16];\n    size_t i;\n    uint64_t orig_len = ctx->len * 8;\n    uint64_t orig_add_len = ctx->add_len * 8;\n\n    if( tag_len > 16 || tag_len < 4 )\n        return( MBEDTLS_ERR_GCM_BAD_INPUT );\n\n    memcpy( tag, ctx->base_ectr, tag_len );\n\n    if( orig_len || orig_add_len )\n    {\n        memset( work_buf, 0x00, 16 );\n\n        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );\n        PUT_UINT32_BE( ( orig_add_len       ), work_buf, 4  );\n        PUT_UINT32_BE( ( orig_len     >> 32 ), work_buf, 8  );\n        PUT_UINT32_BE( ( orig_len           ), work_buf, 12 );\n\n        for( i = 0; i < 16; i++ )\n            ctx->buf[i] ^= work_buf[i];\n\n        gcm_mult( ctx, ctx->buf, ctx->buf );\n\n        for( i = 0; i < tag_len; i++ )\n            tag[i] ^= ctx->buf[i];\n    }\n\n    return( 0 );\n}\n\nint mbedtls_gcm_crypt_and_tag( mbedtls_gcm_context *ctx,\n                       int mode,\n                       size_t length,\n                       const unsigned char *iv,\n                       size_t iv_len,\n                       const unsigned char *add,\n                       size_t add_len,\n                       const unsigned char *input,\n                       unsigned char *output,\n                       size_t tag_len,\n                       unsigned char *tag )\n{\n    int ret;\n\n    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len, add, add_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_gcm_update( ctx, length, input, output ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_gcm_finish( ctx, tag, tag_len ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\nint mbedtls_gcm_auth_decrypt( mbedtls_gcm_context *ctx,\n                      size_t length,\n                      const unsigned char *iv,\n                      size_t iv_len,\n                      const unsigned char *add,\n                      size_t add_len,\n                      const unsigned char *tag,\n                      size_t tag_len,\n                      const unsigned char *input,\n                      unsigned char *output )\n{\n    int ret;\n    unsigned char check_tag[16];\n    size_t i;\n    int diff;\n\n    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,\n                                   iv, iv_len, add, add_len,\n                                   input, output, tag_len, check_tag ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* Check tag in \"constant-time\" */\n    for( diff = 0, i = 0; i < tag_len; i++ )\n        diff |= tag[i] ^ check_tag[i];\n\n    if( diff != 0 )\n    {\n        mbedtls_zeroize( output, length );\n        return( MBEDTLS_ERR_GCM_AUTH_FAILED );\n    }\n\n    return( 0 );\n}\n\nvoid mbedtls_gcm_free( mbedtls_gcm_context *ctx )\n{\n    mbedtls_cipher_free( &ctx->cipher_ctx );\n    mbedtls_zeroize( ctx, sizeof( mbedtls_gcm_context ) );\n}\n\n#endif /* !MBEDTLS_GCM_ALT */\n\n#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)\n/*\n * AES-GCM test vectors from:\n *\n * http://csrc.nist.gov/groups/STM/cavp/documents/mac/gcmtestvectors.zip\n */\n#define MAX_TESTS   6\n\nstatic const int key_index[MAX_TESTS] =\n    { 0, 0, 1, 1, 1, 1 };\n\nstatic const unsigned char key[MAX_TESTS][32] =\n{\n    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n    { 0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,\n      0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,\n      0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,\n      0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 },\n};\n\nstatic const size_t iv_len[MAX_TESTS] =\n    { 12, 12, 12, 12, 8, 60 };\n\nstatic const int iv_index[MAX_TESTS] =\n    { 0, 0, 1, 1, 1, 2 };\n\nstatic const unsigned char iv[MAX_TESTS][64] =\n{\n    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00 },\n    { 0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,\n      0xde, 0xca, 0xf8, 0x88 },\n    { 0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5,\n      0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,\n      0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1,\n      0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,\n      0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39,\n      0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,\n      0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57,\n      0xa6, 0x37, 0xb3, 0x9b },\n};\n\nstatic const size_t add_len[MAX_TESTS] =\n    { 0, 0, 0, 20, 20, 20 };\n\nstatic const int add_index[MAX_TESTS] =\n    { 0, 0, 0, 1, 1, 1 };\n\nstatic const unsigned char additional[MAX_TESTS][64] =\n{\n    { 0x00 },\n    { 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,\n      0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,\n      0xab, 0xad, 0xda, 0xd2 },\n};\n\nstatic const size_t pt_len[MAX_TESTS] =\n    { 0, 16, 64, 60, 60, 60 };\n\nstatic const int pt_index[MAX_TESTS] =\n    { 0, 0, 1, 1, 1, 1 };\n\nstatic const unsigned char pt[MAX_TESTS][64] =\n{\n    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n    { 0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,\n      0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,\n      0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,\n      0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,\n      0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,\n      0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,\n      0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,\n      0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55 },\n};\n\nstatic const unsigned char ct[MAX_TESTS * 3][64] =\n{\n    { 0x00 },\n    { 0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92,\n      0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78 },\n    { 0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,\n      0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,\n      0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,\n      0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,\n      0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,\n      0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,\n      0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,\n      0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85 },\n    { 0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,\n      0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,\n      0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,\n      0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,\n      0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,\n      0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,\n      0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,\n      0x3d, 0x58, 0xe0, 0x91 },\n    { 0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a,\n      0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55,\n      0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8,\n      0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23,\n      0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2,\n      0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42,\n      0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07,\n      0xc2, 0x3f, 0x45, 0x98 },\n    { 0x8c, 0xe2, 0x49, 0x98, 0x62, 0x56, 0x15, 0xb6,\n      0x03, 0xa0, 0x33, 0xac, 0xa1, 0x3f, 0xb8, 0x94,\n      0xbe, 0x91, 0x12, 0xa5, 0xc3, 0xa2, 0x11, 0xa8,\n      0xba, 0x26, 0x2a, 0x3c, 0xca, 0x7e, 0x2c, 0xa7,\n      0x01, 0xe4, 0xa9, 0xa4, 0xfb, 0xa4, 0x3c, 0x90,\n      0xcc, 0xdc, 0xb2, 0x81, 0xd4, 0x8c, 0x7c, 0x6f,\n      0xd6, 0x28, 0x75, 0xd2, 0xac, 0xa4, 0x17, 0x03,\n      0x4c, 0x34, 0xae, 0xe5 },\n    { 0x00 },\n    { 0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41,\n      0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00 },\n    { 0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41,\n      0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,\n      0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84,\n      0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,\n      0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,\n      0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,\n      0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9,\n      0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56 },\n    { 0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41,\n      0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,\n      0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84,\n      0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,\n      0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,\n      0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,\n      0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9,\n      0xcc, 0xda, 0x27, 0x10 },\n    { 0x0f, 0x10, 0xf5, 0x99, 0xae, 0x14, 0xa1, 0x54,\n      0xed, 0x24, 0xb3, 0x6e, 0x25, 0x32, 0x4d, 0xb8,\n      0xc5, 0x66, 0x63, 0x2e, 0xf2, 0xbb, 0xb3, 0x4f,\n      0x83, 0x47, 0x28, 0x0f, 0xc4, 0x50, 0x70, 0x57,\n      0xfd, 0xdc, 0x29, 0xdf, 0x9a, 0x47, 0x1f, 0x75,\n      0xc6, 0x65, 0x41, 0xd4, 0xd4, 0xda, 0xd1, 0xc9,\n      0xe9, 0x3a, 0x19, 0xa5, 0x8e, 0x8b, 0x47, 0x3f,\n      0xa0, 0xf0, 0x62, 0xf7 },\n    { 0xd2, 0x7e, 0x88, 0x68, 0x1c, 0xe3, 0x24, 0x3c,\n      0x48, 0x30, 0x16, 0x5a, 0x8f, 0xdc, 0xf9, 0xff,\n      0x1d, 0xe9, 0xa1, 0xd8, 0xe6, 0xb4, 0x47, 0xef,\n      0x6e, 0xf7, 0xb7, 0x98, 0x28, 0x66, 0x6e, 0x45,\n      0x81, 0xe7, 0x90, 0x12, 0xaf, 0x34, 0xdd, 0xd9,\n      0xe2, 0xf0, 0x37, 0x58, 0x9b, 0x29, 0x2d, 0xb3,\n      0xe6, 0x7c, 0x03, 0x67, 0x45, 0xfa, 0x22, 0xe7,\n      0xe9, 0xb7, 0x37, 0x3b },\n    { 0x00 },\n    { 0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e,\n      0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18 },\n    { 0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07,\n      0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,\n      0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9,\n      0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,\n      0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,\n      0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,\n      0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a,\n      0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad },\n    { 0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07,\n      0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,\n      0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9,\n      0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,\n      0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,\n      0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,\n      0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a,\n      0xbc, 0xc9, 0xf6, 0x62 },\n    { 0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32,\n      0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb,\n      0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa,\n      0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0,\n      0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0,\n      0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78,\n      0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99,\n      0xf4, 0x7c, 0x9b, 0x1f },\n    { 0x5a, 0x8d, 0xef, 0x2f, 0x0c, 0x9e, 0x53, 0xf1,\n      0xf7, 0x5d, 0x78, 0x53, 0x65, 0x9e, 0x2a, 0x20,\n      0xee, 0xb2, 0xb2, 0x2a, 0xaf, 0xde, 0x64, 0x19,\n      0xa0, 0x58, 0xab, 0x4f, 0x6f, 0x74, 0x6b, 0xf4,\n      0x0f, 0xc0, 0xc3, 0xb7, 0x80, 0xf2, 0x44, 0x45,\n      0x2d, 0xa3, 0xeb, 0xf1, 0xc5, 0xd8, 0x2c, 0xde,\n      0xa2, 0x41, 0x89, 0x97, 0x20, 0x0e, 0xf8, 0x2e,\n      0x44, 0xae, 0x7e, 0x3f },\n};\n\nstatic const unsigned char tag[MAX_TESTS * 3][16] =\n{\n    { 0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61,\n      0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a },\n    { 0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd,\n      0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf },\n    { 0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6,\n      0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4 },\n    { 0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,\n      0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47 },\n    { 0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85,\n      0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb },\n    { 0x61, 0x9c, 0xc5, 0xae, 0xff, 0xfe, 0x0b, 0xfa,\n      0x46, 0x2a, 0xf4, 0x3c, 0x16, 0x99, 0xd0, 0x50 },\n    { 0xcd, 0x33, 0xb2, 0x8a, 0xc7, 0x73, 0xf7, 0x4b,\n      0xa0, 0x0e, 0xd1, 0xf3, 0x12, 0x57, 0x24, 0x35 },\n    { 0x2f, 0xf5, 0x8d, 0x80, 0x03, 0x39, 0x27, 0xab,\n      0x8e, 0xf4, 0xd4, 0x58, 0x75, 0x14, 0xf0, 0xfb },\n    { 0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf,\n      0xb1, 0x18, 0x02, 0x4d, 0xb8, 0x67, 0x4a, 0x14 },\n    { 0x25, 0x19, 0x49, 0x8e, 0x80, 0xf1, 0x47, 0x8f,\n      0x37, 0xba, 0x55, 0xbd, 0x6d, 0x27, 0x61, 0x8c },\n    { 0x65, 0xdc, 0xc5, 0x7f, 0xcf, 0x62, 0x3a, 0x24,\n      0x09, 0x4f, 0xcc, 0xa4, 0x0d, 0x35, 0x33, 0xf8 },\n    { 0xdc, 0xf5, 0x66, 0xff, 0x29, 0x1c, 0x25, 0xbb,\n      0xb8, 0x56, 0x8f, 0xc3, 0xd3, 0x76, 0xa6, 0xd9 },\n    { 0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9,\n      0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b },\n    { 0xd0, 0xd1, 0xc8, 0xa7, 0x99, 0x99, 0x6b, 0xf0,\n      0x26, 0x5b, 0x98, 0xb5, 0xd4, 0x8a, 0xb9, 0x19 },\n    { 0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd,\n      0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c },\n    { 0x76, 0xfc, 0x6e, 0xce, 0x0f, 0x4e, 0x17, 0x68,\n      0xcd, 0xdf, 0x88, 0x53, 0xbb, 0x2d, 0x55, 0x1b },\n    { 0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4,\n      0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2 },\n    { 0xa4, 0x4a, 0x82, 0x66, 0xee, 0x1c, 0x8e, 0xb0,\n      0xc8, 0xb5, 0xd4, 0xcf, 0x5a, 0xe9, 0xf1, 0x9a },\n};\n\nint mbedtls_gcm_self_test( int verbose )\n{\n    mbedtls_gcm_context ctx;\n    unsigned char buf[64];\n    unsigned char tag_buf[16];\n    int i, j, ret;\n    mbedtls_cipher_id_t cipher = MBEDTLS_CIPHER_ID_AES;\n\n    for( j = 0; j < 3; j++ )\n    {\n        int key_len = 128 + 64 * j;\n\n        for( i = 0; i < MAX_TESTS; i++ )\n        {\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d (%s): \",\n                                key_len, i, \"enc\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            /*\n             * AES-192 is an optional feature that may be unavailable when\n             * there is an alternative underlying implementation i.e. when\n             * MBEDTLS_AES_ALT is defined.\n             */\n            if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && key_len == 192 )\n            {\n                mbedtls_printf( \"skipped\\n\" );\n                break;\n            }\n            else if( ret != 0 )\n            {\n                goto exit;\n            }\n\n            ret = mbedtls_gcm_crypt_and_tag( &ctx, MBEDTLS_GCM_ENCRYPT,\n                                        pt_len[i],\n                                        iv[iv_index[i]], iv_len[i],\n                                        additional[add_index[i]], add_len[i],\n                                        pt[pt_index[i]], buf, 16, tag_buf );\n            if( ret != 0 )\n                goto exit;\n\n            if ( memcmp( buf, ct[j * 6 + i], pt_len[i] ) != 0 ||\n                 memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d (%s): \",\n                                key_len, i, \"dec\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            if( ret != 0 )\n                goto exit;\n\n            ret = mbedtls_gcm_crypt_and_tag( &ctx, MBEDTLS_GCM_DECRYPT,\n                                        pt_len[i],\n                                        iv[iv_index[i]], iv_len[i],\n                                        additional[add_index[i]], add_len[i],\n                                        ct[j * 6 + i], buf, 16, tag_buf );\n\n            if( ret != 0 )\n                goto exit;\n\n            if( memcmp( buf, pt[pt_index[i]], pt_len[i] ) != 0 ||\n                memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d split (%s): \",\n                                key_len, i, \"enc\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            if( ret != 0 )\n                goto exit;\n\n            ret = mbedtls_gcm_starts( &ctx, MBEDTLS_GCM_ENCRYPT,\n                                      iv[iv_index[i]], iv_len[i],\n                                      additional[add_index[i]], add_len[i] );\n            if( ret != 0 )\n                goto exit;\n\n            if( pt_len[i] > 32 )\n            {\n                size_t rest_len = pt_len[i] - 32;\n                ret = mbedtls_gcm_update( &ctx, 32, pt[pt_index[i]], buf );\n                if( ret != 0 )\n                    goto exit;\n\n                ret = mbedtls_gcm_update( &ctx, rest_len, pt[pt_index[i]] + 32,\n                                  buf + 32 );\n                if( ret != 0 )\n                    goto exit;\n            }\n            else\n            {\n                ret = mbedtls_gcm_update( &ctx, pt_len[i], pt[pt_index[i]], buf );\n                if( ret != 0 )\n                    goto exit;\n            }\n\n            ret = mbedtls_gcm_finish( &ctx, tag_buf, 16 );\n            if( ret != 0 )\n                goto exit;\n\n            if( memcmp( buf, ct[j * 6 + i], pt_len[i] ) != 0 ||\n                memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n\n            mbedtls_gcm_init( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"  AES-GCM-%3d #%d split (%s): \",\n                                key_len, i, \"dec\" );\n\n            ret = mbedtls_gcm_setkey( &ctx, cipher, key[key_index[i]],\n                                      key_len );\n            if( ret != 0 )\n                goto exit;\n\n            ret = mbedtls_gcm_starts( &ctx, MBEDTLS_GCM_DECRYPT,\n                              iv[iv_index[i]], iv_len[i],\n                              additional[add_index[i]], add_len[i] );\n            if( ret != 0 )\n                goto exit;\n\n            if( pt_len[i] > 32 )\n            {\n                size_t rest_len = pt_len[i] - 32;\n                ret = mbedtls_gcm_update( &ctx, 32, ct[j * 6 + i], buf );\n                if( ret != 0 )\n                    goto exit;\n\n                ret = mbedtls_gcm_update( &ctx, rest_len, ct[j * 6 + i] + 32,\n                                          buf + 32 );\n                if( ret != 0 )\n                    goto exit;\n            }\n            else\n            {\n                ret = mbedtls_gcm_update( &ctx, pt_len[i], ct[j * 6 + i],\n                                          buf );\n                if( ret != 0 )\n                    goto exit;\n            }\n\n            ret = mbedtls_gcm_finish( &ctx, tag_buf, 16 );\n            if( ret != 0 )\n                goto exit;\n\n            if( memcmp( buf, pt[pt_index[i]], pt_len[i] ) != 0 ||\n                memcmp( tag_buf, tag[j * 6 + i], 16 ) != 0 )\n            {\n                ret = 1;\n                goto exit;\n            }\n\n            mbedtls_gcm_free( &ctx );\n\n            if( verbose != 0 )\n                mbedtls_printf( \"passed\\n\" );\n        }\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    ret = 0;\n\nexit:\n    if( ret != 0 )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"failed\\n\" );\n        mbedtls_gcm_free( &ctx );\n    }\n\n    return( ret );\n}\n\n#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */\n\n#endif /* MBEDTLS_GCM_C */\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","/**\n *  / _____)             _              | |\n * ( (____  _____ ____ _| |_ _____  ____| |__\n *  \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *  _____) ) ____| | | || |_| ____( (___| | | |\n * (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *    (C)2013 Semtech\n *  ___ _____ _   ___ _  _____ ___  ___  ___ ___\n * / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n * \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n * |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n * embedded.connectivity.solutions===============\n *\n * Description: LoRa MAC crypto implementation\n *\n * License: Revised BSD License, see LICENSE.TXT file include in the project\n *\n * Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jckle ( STACKFORCE )\n *\n *\n * Copyright (c) 2017, Arm Limited and affiliates.\n *\n * SPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdlib.h>\n#include <stdint.h>\n#include \"lorastack/mac/LoRaMacCrypto.h\"\n#include \"lorawan/system/lorawan_data_structures.h\"\n\n#include \"mbedtls/aes.h\"\n#include \"mbedtls/cmac.h\"\n\n#if defined(MBEDTLS_CMAC_C) && defined(MBEDTLS_AES_C) && defined(MBEDTLS_CIPHER_C)\n\n/**\n * CMAC/AES Message Integrity Code (MIC) Block B0 size\n */\n#define LORAMAC_MIC_BLOCK_B0_SIZE                   16\n\n/**\n * MIC field computation initial data\n */\nstatic uint8_t mic_block_b0[] = {0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n/**\n * Contains the computed MIC field.\n *\n * \\remark Only the 4 first bytes are used\n */\nstatic uint8_t computed_mic[16];\n\n/**\n * Encryption aBlock and sBlock\n */\nstatic uint8_t a_block[] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\nstatic uint8_t s_block[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n/**\n * AES computation context variable\n */\nstatic mbedtls_aes_context aes_ctx;\n\n/**\n * CMAC computation context variable\n */\nstatic mbedtls_cipher_context_t aes_cmac_ctx[1];\n\n#define AES_CMAC_KEY_LENGTH     16\n\nint compute_mic(const uint8_t *buffer, uint16_t size, const uint8_t *key,\n                uint32_t address, uint8_t dir, uint32_t seq_counter,\n                uint32_t *mic)\n{\n\n    int ret = 0;\n\n    mic_block_b0[5] = dir;\n\n    mic_block_b0[6] = (address) & 0xFF;\n    mic_block_b0[7] = (address >> 8) & 0xFF;\n    mic_block_b0[8] = (address >> 16) & 0xFF;\n    mic_block_b0[9] = (address >> 24) & 0xFF;\n\n    mic_block_b0[10] = (seq_counter) & 0xFF;\n    mic_block_b0[11] = (seq_counter >> 8) & 0xFF;\n    mic_block_b0[12] = (seq_counter >> 16) & 0xFF;\n    mic_block_b0[13] = (seq_counter >> 24) & 0xFF;\n\n    mic_block_b0[15] = size & 0xFF;\n\n    mbedtls_cipher_init(aes_cmac_ctx);\n\n    const mbedtls_cipher_info_t* cipher_info = mbedtls_cipher_info_from_type(MBEDTLS_CIPHER_AES_128_ECB);\n\n    if (NULL != cipher_info) {\n        ret = mbedtls_cipher_setup(aes_cmac_ctx, cipher_info);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_starts(aes_cmac_ctx, key,\n                                         AES_CMAC_KEY_LENGTH * 8);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_update(aes_cmac_ctx, mic_block_b0,\n                                         LORAMAC_MIC_BLOCK_B0_SIZE);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_update(aes_cmac_ctx, buffer, size & 0xFF);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_finish(aes_cmac_ctx, computed_mic);\n        if (0 != ret)\n            goto exit;\n\n        *mic = (uint32_t) ((uint32_t) computed_mic[3] << 24\n                | (uint32_t) computed_mic[2] << 16\n                | (uint32_t) computed_mic[1] << 8 | (uint32_t) computed_mic[0]);\n    } else {\n        ret = MBEDTLS_ERR_CIPHER_ALLOC_FAILED;\n    }\n\nexit: mbedtls_cipher_free(aes_cmac_ctx);\n    return ret;\n}\n\nint encrypt_payload(const uint8_t *buffer, uint16_t size, const uint8_t *key,\n                    uint32_t address, uint8_t dir, uint32_t seq_counter,\n                    uint8_t *enc_buffer)\n{\n    uint16_t i;\n    uint8_t bufferIndex = 0;\n    uint16_t ctr = 1;\n    int ret = 0;\n\n    mbedtls_aes_init(&aes_ctx);\n    ret = mbedtls_aes_setkey_enc(&aes_ctx, key, 16 * 8);\n    if (0 != ret)\n        goto exit;\n\n    a_block[5] = dir;\n\n    a_block[6] = (address) & 0xFF;\n    a_block[7] = (address >> 8) & 0xFF;\n    a_block[8] = (address >> 16) & 0xFF;\n    a_block[9] = (address >> 24) & 0xFF;\n\n    a_block[10] = (seq_counter) & 0xFF;\n    a_block[11] = (seq_counter >> 8) & 0xFF;\n    a_block[12] = (seq_counter >> 16) & 0xFF;\n    a_block[13] = (seq_counter >> 24) & 0xFF;\n\n    while (size >= 16) {\n        a_block[15] = ((ctr) & 0xFF);\n        ctr++;\n        ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, a_block,\n                                    s_block);\n        if (0 != ret)\n            goto exit;\n\n        for (i = 0; i < 16; i++) {\n            enc_buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ s_block[i];\n        }\n        size -= 16;\n        bufferIndex += 16;\n    }\n\n    if (size > 0) {\n        a_block[15] = ((ctr) & 0xFF);\n        ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, a_block,\n                                    s_block);\n        if (0 != ret)\n            goto exit;\n\n        for (i = 0; i < size; i++) {\n            enc_buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ s_block[i];\n        }\n    }\n\nexit: mbedtls_aes_free(&aes_ctx);\n    return ret;\n}\n\nint decrypt_payload(const uint8_t *buffer, uint16_t size, const uint8_t *key,\n                    uint32_t address, uint8_t dir, uint32_t seq_counter,\n                    uint8_t *dec_buffer)\n{\n    return encrypt_payload(buffer, size, key, address, dir, seq_counter,\n                           dec_buffer);\n}\n\nint compute_join_frame_mic(const uint8_t *buffer, uint16_t size,\n                           const uint8_t *key, uint32_t *mic)\n{\n    int ret = 0;\n\n    mbedtls_cipher_init(aes_cmac_ctx);\n    const mbedtls_cipher_info_t* cipher_info = mbedtls_cipher_info_from_type(MBEDTLS_CIPHER_AES_128_ECB);\n\n    if (NULL != cipher_info) {\n        ret = mbedtls_cipher_setup(aes_cmac_ctx, cipher_info);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_starts(aes_cmac_ctx, key,\n                                         AES_CMAC_KEY_LENGTH * 8);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_update(aes_cmac_ctx, buffer, size & 0xFF);\n        if (0 != ret)\n            goto exit;\n\n        ret = mbedtls_cipher_cmac_finish(aes_cmac_ctx, computed_mic);\n        if (0 != ret)\n            goto exit;\n\n        *mic = (uint32_t) ((uint32_t) computed_mic[3] << 24\n                | (uint32_t) computed_mic[2] << 16\n                | (uint32_t) computed_mic[1] << 8 | (uint32_t) computed_mic[0]);\n    } else {\n        ret = MBEDTLS_ERR_CIPHER_ALLOC_FAILED;\n    }\n\nexit: mbedtls_cipher_free(aes_cmac_ctx);\n    return ret;\n}\n\nint decrypt_join_frame(const uint8_t *buffer, uint16_t size, const uint8_t *key,\n                       uint8_t *dec_buffer)\n{\n    int ret = 0;\n\n    mbedtls_aes_init(&aes_ctx);\n\n    ret = mbedtls_aes_setkey_enc(&aes_ctx, key, 16 * 8);\n    if (0 != ret)\n        goto exit;\n\n    ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, buffer,\n                                dec_buffer);\n    if (0 != ret)\n        goto exit;\n\n    // Check if optional CFList is included\n    if (size >= 16) {\n        ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, buffer + 16,\n                                    dec_buffer + 16);\n    }\n\nexit: mbedtls_aes_free(&aes_ctx);\n    return ret;\n}\n\nint compute_skeys_for_join_frame(const uint8_t *key, const uint8_t *app_nonce,\n                                 uint16_t dev_nonce, uint8_t *nwk_skey,\n                                 uint8_t *app_skey)\n{\n    uint8_t nonce[16];\n    uint8_t *p_dev_nonce = (uint8_t *) &dev_nonce;\n    int ret = 0;\n\n    mbedtls_aes_init(&aes_ctx);\n\n    ret = mbedtls_aes_setkey_enc(&aes_ctx, key, 16 * 8);\n    if (0 != ret)\n        goto exit;\n\n    memset(nonce, 0, sizeof(nonce));\n    nonce[0] = 0x01;\n    memcpy(nonce + 1, app_nonce, 6);\n    memcpy(nonce + 7, p_dev_nonce, 2);\n    ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, nonce, nwk_skey);\n    if (0 != ret)\n        goto exit;\n\n    memset(nonce, 0, sizeof(nonce));\n    nonce[0] = 0x02;\n    memcpy(nonce + 1, app_nonce, 6);\n    memcpy(nonce + 7, p_dev_nonce, 2);\n    ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, nonce, app_skey);\n\n    exit: mbedtls_aes_free(&aes_ctx);\n    return ret;\n}\n#else\n\n// If mbedTLS is not configured properly, these dummies will ensure that\n// user knows what is wrong and in addition to that these ensure that\n// Mbed-OS compiles properly under normal conditions where LoRaWAN in conjunction\n// with mbedTLS is not being used.\nint compute_mic(const uint8_t *, uint16_t , const uint8_t *, uint32_t,\n                uint8_t dir, uint32_t, uint32_t *)\n{\n    printf(\"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint encrypt_payload(const uint8_t *, uint16_t , const uint8_t *, uint32_t,\n                    uint8_t , uint32_t , uint8_t *)\n{\n    printf(\"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint decrypt_payload(const uint8_t *, uint16_t , const uint8_t *, uint32_t,\n                    uint8_t , uint32_t , uint8_t *)\n{\n    printf(\"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint compute_join_frame_mic(const uint8_t *, uint16_t , const uint8_t *, uint32_t *)\n{\n    printf(\"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint decrypt_join_frame(const uint8_t *, uint16_t , const uint8_t *, uint8_t *)\n{\n    printf(\"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\nint compute_skeys_for_join_frame(const uint8_t *, const uint8_t *, uint16_t ,\n                                 uint8_t *, uint8_t *)\n{\n    printf(\"[LoRaCrypto] Must enable AES, CMAC & CIPHER from mbedTLS\");\n\n    // Never actually reaches here\n    return LORAWAN_STATUS_CRYPTO_FAIL;\n}\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include \"LoRaMac.h\"\n#include \"lorastack/mac/LoRaMacMcps.h\"\n\nLoRaMacMcps::LoRaMacMcps()\n{\n}\n\nLoRaMacMcps::~LoRaMacMcps()\n{\n}\n\nvoid LoRaMacMcps::reset_confirmation()\n{\n    memset((uint8_t*) &confirmation, 0, sizeof(confirmation));\n\n    confirmation.status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n}\n\nloramac_mcps_confirm_t& LoRaMacMcps::get_confirmation()\n{\n    return confirmation;\n}\n\nloramac_mcps_indication_t& LoRaMacMcps::get_indication()\n{\n    return indication;\n}\n\nvoid LoRaMacMcps::activate_mcps_subsystem()\n{\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/Timer.h\"\n#include \"hal/ticker_api.h\"\n#include \"hal/us_ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/lp_ticker_api.h\"\n\nnamespace mbed {\n\nTimer::Timer() : _running(), _start(), _time(), _ticker_data(get_us_ticker_data()), _lock_deepsleep(true) {\n    reset();\n}\n\nTimer::Timer(const ticker_data_t *data) : _running(), _start(), _time(), _ticker_data(data), _lock_deepsleep(true) {\n    reset();\n#if DEVICE_LOWPOWERTIMER\n    _lock_deepsleep = (data != get_lp_ticker_data());\n#endif\n}\n\nTimer::~Timer() {\n    core_util_critical_section_enter();\n    if (_running) {\n        if(_lock_deepsleep) {\n            sleep_manager_unlock_deep_sleep();\n        }\n    }\n    _running = 0;\n    core_util_critical_section_exit();\n}\n\nvoid Timer::start() {\n    core_util_critical_section_enter();\n    if (!_running) {\n        if(_lock_deepsleep) {\n            sleep_manager_lock_deep_sleep();\n        }\n        _start = ticker_read_us(_ticker_data);\n        _running = 1;\n    }\n    core_util_critical_section_exit();\n}\n\nvoid Timer::stop() {\n    core_util_critical_section_enter();\n    _time += slicetime();\n    if (_running) {\n        if(_lock_deepsleep) {\n            sleep_manager_unlock_deep_sleep();\n        }\n    }\n    _running = 0;\n    core_util_critical_section_exit();\n}\n\nint Timer::read_us() {\n    return read_high_resolution_us();\n}\n\nfloat Timer::read() {\n    return (float)read_us() / 1000000.0f;\n}\n\nint Timer::read_ms() {\n    return read_high_resolution_us() / 1000;\n}\n\nus_timestamp_t Timer::read_high_resolution_us() {\n    core_util_critical_section_enter();\n    us_timestamp_t time = _time + slicetime();\n    core_util_critical_section_exit();\n    return time;\n}\n\nus_timestamp_t Timer::slicetime() {\n    us_timestamp_t ret = 0;\n    core_util_critical_section_enter();\n    if (_running) {\n        ret = ticker_read_us(_ticker_data) - _start;\n    }\n    core_util_critical_section_exit();\n    return ret;\n}\n\nvoid Timer::reset() {\n    core_util_critical_section_enter();\n    _start = ticker_read_us(_ticker_data);\n    _time = 0;\n    core_util_critical_section_exit();\n}\n\nTimer::operator float() {\n    return read();\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/TimerEvent.h\"\n#include \"cmsis.h\"\n\n#include <stddef.h>\n#include \"hal/ticker_api.h\"\n#include \"hal/us_ticker_api.h\"\n\nnamespace mbed {\n\nTimerEvent::TimerEvent() : event(), _ticker_data(get_us_ticker_data()) {\n    ticker_set_handler(_ticker_data, (&TimerEvent::irq));\n}\n\nTimerEvent::TimerEvent(const ticker_data_t *data) : event(), _ticker_data(data) {\n    ticker_set_handler(_ticker_data, (&TimerEvent::irq));\n}\n\nvoid TimerEvent::irq(uint32_t id) {\n    TimerEvent *timer_event = (TimerEvent*)id;\n    timer_event->handler();\n}\n\nTimerEvent::~TimerEvent() {\n    remove();\n}\n\n// insert in to linked list\nvoid TimerEvent::insert(timestamp_t timestamp) {\n    ticker_insert_event(_ticker_data, &event, timestamp, (uint32_t)this);\n}\n\nvoid TimerEvent::insert_absolute(us_timestamp_t timestamp) {\n    ticker_insert_event_us(_ticker_data, &event, timestamp, (uint32_t)this);\n}\n\nvoid TimerEvent::remove() {\n    ticker_remove_event(_ticker_data, &event);\n}\n\n} // namespace mbed\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"events/EventQueue.h\"\n\n#include \"events/mbed_events.h\"\n#include \"mbed.h\"\n\n\nEventQueue::EventQueue(unsigned event_size, unsigned char *event_pointer) {\n    if (!event_pointer) {\n        equeue_create(&_equeue, event_size);\n    } else {\n        equeue_create_inplace(&_equeue, event_size, event_pointer);\n    }\n}\n\nEventQueue::~EventQueue() {\n    equeue_destroy(&_equeue);\n}\n\nvoid EventQueue::dispatch(int ms) {\n    return equeue_dispatch(&_equeue, ms);\n}\n\nvoid EventQueue::break_dispatch() {\n    return equeue_break(&_equeue);\n}\n\nunsigned EventQueue::tick() {\n    return equeue_tick();\n}\n\nvoid EventQueue::cancel(int id) {\n    return equeue_cancel(&_equeue, id);\n}\n\nvoid EventQueue::background(Callback<void(int)> update) {\n    _update = update;\n\n    if (_update) {\n        equeue_background(&_equeue, &Callback<void(int)>::thunk, &_update);\n    } else {\n        equeue_background(&_equeue, 0, 0);\n    }\n}\n\nvoid EventQueue::chain(EventQueue *target) {\n    if (target) {\n        equeue_chain(&_equeue, &target->_equeue);\n    } else {\n        equeue_chain(&_equeue, 0);\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"mbed_assert.h\"\n#include \"mbed_power_mgmt.h\"\n#include \"mbed_critical.h\"\n#include \"sleep_api.h\"\n#include \"mbed_error.h\"\n#include \"mbed_debug.h\"\n#include <limits.h>\n#include <stdio.h>\n\n#if DEVICE_SLEEP\n\n// deep sleep locking counter. A target is allowed to deep sleep if counter == 0\nstatic uint16_t deep_sleep_lock = 0U;\n\n#ifdef MBED_SLEEP_TRACING_ENABLED\n\n// Number of drivers that can be stored in the structure\n#define STATISTIC_COUNT  10\n\ntypedef struct sleep_statistic {\n    const char* identifier;\n    uint8_t count;\n} sleep_statistic_t;\n\nstatic sleep_statistic_t sleep_stats[STATISTIC_COUNT];\n\nstatic sleep_statistic_t* sleep_tracker_find(const char *const filename)\n{\n    for (int i = 0; i < STATISTIC_COUNT; ++i) {\n        if (sleep_stats[i].identifier == filename) {\n            return &sleep_stats[i];\n        }\n    }\n\n    return NULL;\n}\n\nstatic sleep_statistic_t* sleep_tracker_add(const char* const filename)\n{\n    for (int i = 0; i < STATISTIC_COUNT; ++i) {\n        if (sleep_stats[i].identifier == NULL) {\n            sleep_stats[i].identifier = filename;\n\n            return &sleep_stats[i];\n        }\n    }\n\n    debug(\"No free indexes left to use in mbed sleep tracker.\\r\\n\");\n\n    return NULL;\n}\n\nstatic void sleep_tracker_print_stats(void)\n{\n    debug(\"Sleep locks held:\\r\\n\");\n    for (int i = 0; i < STATISTIC_COUNT; ++i) {\n        if (sleep_stats[i].count == 0) {\n            continue;\n        }\n\n        if (sleep_stats[i].identifier == NULL) {\n            return;\n        }\n\n        debug(\"[id: %s, count: %u]\\r\\n\", sleep_stats[i].identifier,\n                                         sleep_stats[i].count);\n    }\n}\n\nvoid sleep_tracker_lock(const char* const filename, int line)\n{\n    sleep_statistic_t *stat = sleep_tracker_find(filename);\n\n    // Entry for this driver does not exist, create one.\n    if (stat == NULL) {\n        stat = sleep_tracker_add(filename);\n    }\n\n    core_util_atomic_incr_u8(&stat->count, 1);\n\n    debug(\"LOCK: %s, ln: %i, lock count: %u\\r\\n\", filename, line, deep_sleep_lock);\n}\n\nvoid sleep_tracker_unlock(const char* const filename, int line)\n{\n    sleep_statistic_t *stat = sleep_tracker_find(filename);\n\n    // Entry for this driver does not exist, something went wrong.\n    if (stat == NULL) {\n        debug(\"Unlocking sleep for driver that was not previously locked: %s, ln: %i\\r\\n\", filename, line);\n        return;\n    }\n\n    core_util_atomic_decr_u8(&stat->count, 1);\n\n    debug(\"UNLOCK: %s, ln: %i, lock count: %u\\r\\n\", filename, line, deep_sleep_lock);\n}\n\n#endif // MBED_SLEEP_TRACING_ENABLED\n\nvoid sleep_manager_lock_deep_sleep_internal(void)\n{\n    core_util_critical_section_enter();\n    if (deep_sleep_lock == USHRT_MAX) {\n        core_util_critical_section_exit();\n        error(\"Deep sleep lock would overflow (> USHRT_MAX)\");\n    }\n    core_util_atomic_incr_u16(&deep_sleep_lock, 1);\n    core_util_critical_section_exit();\n}\n\nvoid sleep_manager_unlock_deep_sleep_internal(void)\n{\n    core_util_critical_section_enter();\n    if (deep_sleep_lock == 0) {\n        core_util_critical_section_exit();\n        error(\"Deep sleep lock would underflow (< 0)\");\n    }\n    core_util_atomic_decr_u16(&deep_sleep_lock, 1);\n    core_util_critical_section_exit();\n}\n\nbool sleep_manager_can_deep_sleep(void)\n{\n    return deep_sleep_lock == 0 ? true : false;\n}\n\nvoid sleep_manager_sleep_auto(void)\n{\n#ifdef MBED_SLEEP_TRACING_ENABLED\n    sleep_tracker_print_stats();\n#endif\n    core_util_critical_section_enter();\n// debug profile should keep debuggers attached, no deep sleep allowed\n#ifdef MBED_DEBUG\n    hal_sleep();\n#else\n    if (sleep_manager_can_deep_sleep()) {\n        hal_deepsleep();\n    } else {\n        hal_sleep();\n    }\n#endif\n    core_util_critical_section_exit();\n}\n\n#else\n\n// locking is valid only if DEVICE_SLEEP is defined\n// we provide empty implementation\n\nvoid sleep_manager_lock_deep_sleep_internal(void)\n{\n\n}\n\nvoid sleep_manager_unlock_deep_sleep_internal(void)\n{\n\n}\n\nbool sleep_manager_can_deep_sleep(void)\n{\n    // no sleep implemented\n    return false;\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"hal/us_ticker_api.h\"\n\nstatic ticker_event_queue_t events = { 0 };\n\nstatic ticker_irq_handler_type irq_handler = ticker_irq_handler;\n\nstatic const ticker_interface_t us_interface = {\n    .init = us_ticker_init,\n    .read = us_ticker_read,\n    .disable_interrupt = us_ticker_disable_interrupt,\n    .clear_interrupt = us_ticker_clear_interrupt,\n    .set_interrupt = us_ticker_set_interrupt,\n    .fire_interrupt = us_ticker_fire_interrupt,\n    .get_info = us_ticker_get_info,\n};\n\nstatic const ticker_data_t us_data = {\n    .interface = &us_interface,\n    .queue = &events\n};\n\nconst ticker_data_t* get_us_ticker_data(void)\n{\n    return &us_data;\n}\n\nticker_irq_handler_type set_us_ticker_irq_handler(ticker_irq_handler_type ticker_irq_handler)\n{\n    ticker_irq_handler_type prev_irq_handler = irq_handler;\n\n    irq_handler = ticker_irq_handler;\n\n    return prev_irq_handler;\n}\n\nvoid us_ticker_irq_handler(void)\n{\n    if (irq_handler) {\n        irq_handler(&us_data);\n    }\n}\n"]}